<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>东风微鸣 Blog - devops</title><link>https://www.EWhisper.cn/</link><description>Focus on Python/Java/DevOps/Observability</description><lastBuildDate>Wed, 19 Jun 2019 20:39:00 +0800</lastBuildDate><item><title>NGINX 实战手册-运维-实用运维Tips和总结</title><link>https://www.EWhisper.cn/nginx-handbook-3-11-operation-best-practices.html</link><description>&lt;h2 id="311-tips"&gt;3.11 实用运维Tips和总结&lt;a class="headerlink" href="#311-tips" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="3110"&gt;3.11.0 介绍&lt;a class="headerlink" href="#3110" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;最后章节会包括使用运维tips和本书的总结. 通过这三个大部分, 我们讨论了与运维工程师有关的很多想法和概念. 然而, 我认为再多讲一点会有助于理解的更加全面. 在本章, 我会确保你的配置文件干净和简洁, 以及如何调试配置文件.&lt;/p&gt;
&lt;h3 id="3111-includes"&gt;3.11.1 使用 Includes 来缩减配置&lt;a class="headerlink" href="#3111-includes" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要清理大量的配置文件来保证你的配置文件以模块化的配置集分组.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;include&lt;/code&gt;指令来引用配置文件, 目录或通配符:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;include&lt;/span&gt; &lt;span class="s"&gt;config.d/compression.conf&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;include&lt;/span&gt; &lt;span class="s"&gt;sites-enabled/*.conf&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="3112"&gt;3.11.2 调试配置&lt;a class="headerlink" href="#3112" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;从NGINX server , 你得到的非预期的结果.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;调试配置, 记住以下建议:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;NGINX进程请求查找最匹配的规则.&lt;/li&gt;
&lt;li&gt;你可以打开调试日志. 对于调试日志, 你需要确保你的NGINX包配置了&lt;code&gt;--with-debug&lt;/code&gt; flag. 大部分常见包都有; 但是如果你构建你自己的包, 或在运行一个最小化的包, 你可能至少需要再次仔细检查. 一旦你确定了你有debug, 你可以设置&lt;code&gt;error_log&lt;/code&gt;指令的日志级别为&lt;code&gt;debug&lt;/code&gt;: &lt;code&gt;error_log /var/log/nginx/error.log debug;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;你可以为特定的连接启用调试. &lt;code&gt;debug_connection&lt;/code&gt;指令在&lt;code&gt;events&lt;/code&gt;上下文是合法的, 使用IP或CIDR range作为参数. 该指令可以声明多次来添加多个要调试的IP地址或CIDR ranges. 这在生产环境, 但是调试所有连接会导致性能下降的情况下, 调试一个问题会很有用&lt;/li&gt;
&lt;li&gt;你可以调试特定的virtual servers. 因为&lt;code&gt;error_log&lt;/code&gt;在&lt;code&gt;main&lt;/code&gt; &lt;code&gt;http&lt;/code&gt; &lt;code&gt;mail&lt;/code&gt; &lt;code&gt;stream&lt;/code&gt; &lt;code&gt;server&lt;/code&gt; 和&lt;code&gt;location&lt;/code&gt;上下文都有效. 你可以在你需要调试的上下文设置&lt;code&gt;debug&lt;/code&gt;日志级别.&lt;/li&gt;
&lt;li&gt;你可以启用core dumps, 来从中获取backtraces. Core dumps可以通过操作系统启用, 或通过NGINX配置文件.&lt;/li&gt;
&lt;li&gt;你可以使用&lt;code&gt;rewrite_log&lt;/code&gt;记录rewrite 声明的日志: &lt;code&gt;rewrite_log on;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;NGINX能做很多神奇的配置, 但是也有性能下降的风险. 调试时, 确保你知道如何通过你的配置来追踪你的请求; 如果有问题, 增加调试日志级别来帮助分析. debug日志时相当详细, 找出NGINX对你的请求做了什么以及你的配置在哪儿出错了很有帮助.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2crNKVM"&gt;NGINX如何处理请求&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2iQYNsZ"&gt;管理员调试向导&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2j96jAH"&gt;Rewrite log&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="3113"&gt;3.11.3 总结&lt;a class="headerlink" href="#3113" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这本书的三个部分集中于高性能负载均衡, 安全, 以及部署和维护NGINX和NGINX Plus servers. 这本书展示了NGINX应用交付平台的一些最强大的功能. NGINX会继续开发神奇的功能, 保持赛道领先.&lt;/p&gt;
&lt;p&gt;这本书展示了很多"简短食谱", 允许你对指令和模块(这些让NGINX成为当今网络之心)有更好的理解. NGINX server不仅仅是web server, 不仅仅时反向代理, 而是一个完整的应用交付平台, 完全有能力通过认证, 并在未来环境中使用.  请知悉.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:39:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-11-operation-best-practices.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-运维-使用`split_clients`进行A-B测试</title><link>https://www.EWhisper.cn/nginx-handbook-3-7-ab-test.html</link><description>&lt;h2 id="37-split_clientsa-b"&gt;3.7 使用&lt;code&gt;split_clients&lt;/code&gt;进行A-B测试&lt;a class="headerlink" href="#37-split_clientsa-b" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="370"&gt;3.7.0 介绍&lt;a class="headerlink" href="#370" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;NGINX有一个叫做&lt;code&gt;split_clients&lt;/code&gt;的模块, 允许你来系统地给予某一个变量key来拆分用户. NGINX通过使用轻量的哈希算法来哈希一个给定的字符串来拆分用户. 然后数学地通过百分比拆分, 映射预定义的值到一个变量, 这个值可以用来改变服务器的响应。&lt;/p&gt;
&lt;h3 id="371-ab"&gt;3.7.1 A/B 测试&lt;a class="headerlink" href="#371-ab" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要拆分两个或更多版本的文件或程序的用户来测试接受度.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;split_clients&lt;/code&gt;模块来直接为你的客户端设置不同的upstream pool:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;split_clients&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;${remote_addr}AAA&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;$variant&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;20.0%&lt;/span&gt;    &lt;span class="s"&gt;&amp;quot;backendv2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;*&lt;/span&gt;        &lt;span class="s"&gt;&amp;quot;backendv1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;split_clients&lt;/code&gt;指令哈希由你提供的字符串作为第一个参数, 并且将散列的百分比提供映射一个变量的值作为第二个参数提供。第三个参数是一个包含key-value对的对象, key是百分比权重, 值是要被分配的值. key可以是一个百分比或一个星号. 星号就是剩下的百分比. 变量&lt;code&gt;$variant&lt;/code&gt;的值将是20%的客户端IP是&lt;code&gt;backendv2&lt;/code&gt;, 剩下的80%是&lt;code&gt;backendv1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;在本例中, &lt;code&gt;backendv1&lt;/code&gt;和&lt;code&gt;backendv2&lt;/code&gt;代表upstream server池, 可以被用于&lt;code&gt;proxy_pass&lt;/code&gt;指令, 如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;proxy_pass&lt;/span&gt; &lt;span class="s"&gt;http://&lt;/span&gt;&lt;span class="nv"&gt;$variant&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用变量&lt;code&gt;$variant&lt;/code&gt;, 我们的流量会被分为2个不同的应用server池.&lt;/p&gt;
&lt;p&gt;另一个案例:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="kn"&gt;split_clients&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;${remote_addr}AAA&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;$variant&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="kn"&gt;0.5%&lt;/span&gt;               &lt;span class="s"&gt;.one&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="kn"&gt;2.0%&lt;/span&gt;               &lt;span class="s"&gt;.two&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                   &lt;span class="kn"&gt;*&lt;/span&gt;                  &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="kn"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
         &lt;span class="kn"&gt;index&lt;/span&gt; &lt;span class="s"&gt;index&lt;/span&gt;&lt;span class="nv"&gt;${variant}.html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;A/B测试的类型很有用, 如测试不同类型的市场和前端功能的电商网站转化率. 对于应用, 使用金丝雀发布很常见. 这种部署中, 流量被缓慢地切换到新的版本. 拆分不同应用版本的客户端是很有用的, 当回滚新版本的代码, 限制因为一个错误导致的爆炸半径. 不论是因为什么原因要拆分两个不同应用集的客户端, NGINX通过使用&lt;code&gt;split_client&lt;/code&gt;模块都能很容易实现.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jsdkw4"&gt;split_client documentation&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:39:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-7-ab-test.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-运维-使用GeoIP模块通过IP地址定位用户</title><link>https://www.EWhisper.cn/nginx-handbook-3-8-use-geoip-to-get-users-location.html</link><description>&lt;h2 id="38-geoipip"&gt;3.8 使用GeoIP模块通过IP地址定位用户&lt;a class="headerlink" href="#38-geoipip" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="380"&gt;3.8.0 介绍&lt;a class="headerlink" href="#380" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;跟踪, 分析, 和利用你的应用或度量的客户端的位置信息可以帮助你加深对客户的理解. 有很多方法获取你的客户的位置信息, NGINX通过使用GeoIP模块和几个指令很容易地定位他们. 该模块让基于客户位置信息记录位置, 控制访问, 或者基于客户位置做决定变得很容易.  它也允许客户的位置信息被内部查找只要请求被传输到upstream应用, 而不需要再进行查找. 该NGINX模块默认不安装, 可以从源码静态编译, 动态导入, 或通过在Ubuntu安装&lt;code&gt;nginx-full&lt;/code&gt;或&lt;code&gt;nginx-extras&lt;/code&gt;来安装. 在RHEL发行版, 如CentOS, 你可以安装&lt;code&gt;nginx-mod-http-geoip&lt;/code&gt;包并通过&lt;code&gt;load_module&lt;/code&gt;动态导入. 本章会覆盖&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;导入GeoIP动态模块,&lt;/li&gt;
&lt;li&gt;安装GeoIP数据库,&lt;/li&gt;
&lt;li&gt;该模块可用的内建变量,&lt;/li&gt;
&lt;li&gt;控制访问,&lt;/li&gt;
&lt;li&gt;和代理一起使用.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="381-geoip"&gt;3.8.1 使用GeoIP模块和数据库&lt;a class="headerlink" href="#381-geoip" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要安装GeoIP数据库, 并启用在NGINX的内建命令, 来记录和告诉你的应用你的客户端的地理位置.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;下载GeoIP国家和城市数据库, 并unzip它们:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# mkdir /etc/nginx/geoip&lt;/span&gt;
&lt;span class="c1"&gt;# cd /etc/nginx/geoip&lt;/span&gt;
&lt;span class="c1"&gt;# wget &amp;quot;http://geolite.maxmind.com/\&lt;/span&gt;
download/geoip/database/GeoLiteCountry/GeoIP.dat.gz&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;# gunzip GeoIP.dat.gz&lt;/span&gt;
&lt;span class="s2"&gt;# wget &amp;quot;&lt;/span&gt;http://geolite.maxmind.com/&lt;span class="se"&gt;\&lt;/span&gt;
download/geoip/database/GeoLiteCity.dat.gz&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;# gunzip GeoLiteCity.dat.gz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这些命令在&lt;em&gt;/etc/nginx&lt;/em&gt;下创建一个&lt;em&gt;geoip&lt;/em&gt;目录, 跳转到新目录, 并下载和解压包.&lt;/p&gt;
&lt;p&gt;通过在本地磁盘上的 国家和城市的GeoIP数据库, 我们可以构建NGINX GeoIP模块并使用它们来暴露出给予客户端IP地址的内建指令:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;load_module&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/usr/lib64/nginx/modules/ngx_http_geoip_module.so&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;geoip_country&lt;/span&gt; &lt;span class="s"&gt;/etc/nginx/geoip/GeoIP.dat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;geoip_city&lt;/span&gt; &lt;span class="s"&gt;/etc/nginx/geoip/GeoLiteCity.dat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;geoip_country&lt;/code&gt;指令指定到&lt;em&gt;GeoIP.dat&lt;/em&gt;文件的路径, &lt;em&gt;GeoIP.dat&lt;/em&gt;包含IP地址到国家代码的映射, 只能在HTTP上下文中使用.&lt;/p&gt;
&lt;h3 id="_1"&gt;讨论&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;模块的&lt;code&gt;geoip_country&lt;/code&gt;和&lt;code&gt;geoip_city&lt;/code&gt;暴露一系列可用变量. &lt;code&gt;geoip_country&lt;/code&gt;指令允许你去本你的客户的国家. 这些变量包括&lt;code&gt;$geoip_country_code&lt;/code&gt;, &lt;code&gt;geoip_country_code3&lt;/code&gt;和&lt;code&gt;geoip_country_name&lt;/code&gt;. 国家代码变量返回一个2位国家字母. &lt;code&gt;geoip_country_code3&lt;/code&gt;返回3位国家字母. 国家名变量返回国家的全名.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;geoip_city&lt;/code&gt;指令也会启用几个变量. 和&lt;code&gt;geoip_country&lt;/code&gt;类似. 有&lt;code&gt;$geoip_city_country_code&lt;/code&gt; &lt;code&gt;geoip_city_country_code3&lt;/code&gt; &lt;code&gt;geoip_city_contry_name&lt;/code&gt;. 其他变量有&lt;code&gt;$geoip_city&lt;/code&gt; &lt;code&gt;$geoip_city_continent_code&lt;/code&gt; &lt;code&gt;$geoip_latitude&lt;/code&gt; &lt;code&gt;$geoip_longitude&lt;/code&gt;和&lt;code&gt;$geoip_postal_code&lt;/code&gt;. &lt;code&gt;$geoip_region&lt;/code&gt; &lt;code&gt;$geoip_region_name&lt;/code&gt;描述区域, 领域, 州, 省, 联邦政府地等. 区域是一个两字符代码, 区域名是全名. &lt;code&gt;geoip_area_code&lt;/code&gt;, 只在美国有效, 返回3位数字电话区域码.&lt;/p&gt;
&lt;p&gt;通过这些变量, 你能够记录你的客户端的信息. 你可以选择传递信息到你的应用作为一个header或变量, 或使用NGINX来以特定方式route流量.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://github.com/maxmind/geoipupdate"&gt;GeoIP 升级&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="382"&gt;3.8.2 基于国家限制访问&lt;a class="headerlink" href="#382" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;根据合约或应用需求, 你需要限制来自特定国家的访问.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;映射你想要屏蔽或允许的国家代码到一个变量&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;load_module&lt;/span&gt;
  &lt;span class="s"&gt;&amp;quot;/usr/lib64/nginx/modules/ngx_http_geoip_module.so&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;map&lt;/span&gt; &lt;span class="nv"&gt;$geoip_country_code&lt;/span&gt; &lt;span class="nv"&gt;$country_access&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;&amp;quot;US&amp;quot;&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;&amp;quot;RU&amp;quot;&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;default&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kn"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个映射会设置新的变量&lt;code&gt;$country_access&lt;/code&gt;为1或0. 如果客户端IP地址来自美国或俄罗斯, 变量会被设置为0, 其他国家会设置为1.&lt;/p&gt;
&lt;p&gt;然后, 在&lt;code&gt;server&lt;/code&gt;快, 使用&lt;code&gt;if&lt;/code&gt;声明来拒绝不是来自美国和俄罗斯的用户访问:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;if&lt;/span&gt; &lt;span class="s"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$country_access&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;1&amp;#39;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;403&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kn"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当条件判断为True时, 会返回403 未认证. 否则正常访问.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;这是一个简短的例子, 来说明如何允许特定国家访问. 这个例子可以被扩展, 以符合你的需要.&lt;/p&gt;
&lt;h3 id="383"&gt;3.8.3 找到源客户端&lt;a class="headerlink" href="#383" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要找到客户源IP, 因为在NGINX server前边有代理.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;geoip_proxy&lt;/code&gt;指令来定义你的代理IP地址范围, &lt;code&gt;geoip_proxy_recursive&lt;/code&gt;指令来查找源IP:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;load_module&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/usr/lib64/nginx/modules/ngx_http_geoip_module.so&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;geoip_country&lt;/span&gt; &lt;span class="s"&gt;/etc/nginx/geoip/GeoIP.dat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;geoip_city&lt;/span&gt; &lt;span class="s"&gt;/etc/nginx/geoip/GeoLiteCity.dat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;geoip_proxy&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="s"&gt;.0.16.0/26&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;geoip_proxy_recursive&lt;/span&gt; &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;geoip_proxy&lt;/code&gt;指令定义我们的代理服务器的CIDR范围, 指示NGINX利用&lt;code&gt;X-Forwarded-For&lt;/code&gt;头来查找客户端IP地址. &lt;code&gt;geoip_proxy_recursive&lt;/code&gt;指令指示NGINX来递归地查找上个知道的客户端IP的&lt;code&gt;X-Forwarded-For&lt;/code&gt; header.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;你可能会发现你在NGINX前边使用了代理, NGINX会选择代理的IP地址而不是客户端的. 对于这种情况你可以使用&lt;code&gt;geoip_proxy&lt;/code&gt;指令来指示在给定的范围内, NGINX使用&lt;code&gt;X-Forwarded-For&lt;/code&gt; header. &lt;code&gt;geoip_proxy&lt;/code&gt;指令配置一个地址或CIDR范围. 当NGINX前边有多个代理, 可以使用&lt;code&gt;geoip_proxy_recursive&lt;/code&gt;指令来递归地查找&lt;code&gt;X-Forwarded-For&lt;/code&gt;指令, 来找到源客户端. 你可能会在如在NGINX前边使用AWS ELB, 谷歌的负载均衡, 或Azure的负载均衡时用到这些.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:39:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-8-use-geoip-to-get-users-location.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-运维-自动化</title><link>https://www.EWhisper.cn/nginx-handbook-3-6-automatation.html</link><description>&lt;h2 id="36"&gt;3.6 自动化&lt;a class="headerlink" href="#36" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="360"&gt;3.6.0 介绍&lt;a class="headerlink" href="#360" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有很多方式来自动化NGINX和NGINX Plus的配置文件, 如: 使用配置管理工具或定时任务来从模板配置文件配置. 随着动态环境的增加, 自动化配置的需求变得更急需. 在上一章, 我们确信NGINX配置文件被配置后需要reload.在本章, 我们会讨论更进一步的使用NGINX Plus API和&lt;strong&gt;Consul Template&lt;/strong&gt;的实时(on-the-fly)NGINX配置文件重配置.&lt;/p&gt;
&lt;h3 id="361-nginx-plus"&gt;3.6.1 使用NGINX Plus自动化&lt;a class="headerlink" href="#361-nginx-plus" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要为动态环境重实时配置NGINX Plus的load balance.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用NGINX Plus API来重配置NGINX Plus upstream 池:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ curl &lt;span class="s1"&gt;&amp;#39;http://nginx.local/upstream_conf?\&lt;/span&gt;
&lt;span class="s1"&gt;  add=&amp;amp;upstream=backend&amp;amp;server=10.0.0.42:8080&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;curl&lt;/code&gt;调用到NGINX Plus的请求, 请求一个把一个新的server加到&lt;code&gt;backend&lt;/code&gt; upstream配置.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;更多第一次安装的细节见 3.8 章节, NGINX Plus提供一个API来重新实时配置NGINX Plus. NGINX Plus API允许从upstream 池中添加和移除server, 同时draining 连接. 你可以使用该API来自动化NGINX Plus的应用服务器的创建和释放的配置.&lt;/p&gt;
&lt;h3 id="362-consul-templating"&gt;3.6.2 使用Consul Templating 自动化配置&lt;a class="headerlink" href="#362-consul-templating" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要自动化NGINX配置来通过使用Consul在环境中做出变更.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;consul-template&lt;/code&gt; daemon和一个模板文件来模板化NGINX配置文件:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;upstream backend { &lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt;&lt;span class="nv"&gt;range&lt;/span&gt; &lt;span class="nv"&gt;service&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;app.backend&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;    server &lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt;&lt;span class="nv"&gt;.Address&lt;/span&gt;&lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt;&lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个例子是Consul模板文件的一个upstream配置块模板. 这个模板会遍历在Consul上标记为&lt;code&gt;app.backend&lt;/code&gt;的节点. 对于Consul上的每个节点, 这个模板会使用那个节点的IP地址产生一条server指令.&lt;/p&gt;
&lt;p&gt;这个&lt;code&gt;consul-template&lt;/code&gt; daemon通过命令行运行, 可以被用于在每次配置文件被模板化变更后reload NGINX:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# consul-template -consul consul.example.internal -template \&lt;/span&gt;
template:/etc/nginx/conf.d/upstream.conf:&lt;span class="s2"&gt;&amp;quot;nginx -s reload&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该指令指示&lt;code&gt;consul-template&lt;/code&gt; daemon 来连接到一个位于&lt;code&gt;consul.example.internal&lt;/code&gt;的Consul 集群, 并使用在当前工作目录的名为&lt;code&gt;template&lt;/code&gt;的文件来模板化该文件, 并输出生成的内容到&lt;code&gt;/etc/nginx/conf.d/upstream.conf&lt;/code&gt;中, 然后在每次模板化文件变更时reload NGINX. &lt;code&gt;-template&lt;/code&gt; 标志接受一个字符串,包括: 模板文件,输出位置,和运行模板过程后执行的命令; 这3个变量以冒号分隔. 如果运行的命令由空格, 确保使用双引号包裹. &lt;code&gt;-consul&lt;/code&gt;标志指示要连接的Consul集群.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;Consul是一个强大的服务发现工具和配置仓库. Consul以key-value 对以类似目录的结构存储节点信息, 允许restful API交互.Consul也在每个客户端上提供一个DNS界面, 允许进行连接到集群的节点的域名查找. 一个单独的, 利用Consul集群的项目是&lt;code&gt;consul-template&lt;/code&gt; daemon; 这个工具模板化在Consul 节点, 服务或 key-value对的文件变化. 这让Consul成为一个自动化NGINX的非常强大的选择. 使用&lt;code&gt;consul-template&lt;/code&gt;你也可以指示该daemon在模板替换变更后来运行一个命令. 通过这样, 可以reload NGINX配置, 并允许NGINX配置在环境中生效. 通过Consul, 你可以在每个客户端上设置健康检查来检查关注的服务的监控状况. 通过失败检测, 你能够通过模板化你的NGINX配置来只给健康的主机发送流量.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://www.consul.io/"&gt;Consul home page&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2iosmkV"&gt;Introduction to Consul Template&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/hashicorp/consul-template"&gt;Consul template GitHub&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:33:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-6-automatation.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-运维-前言和介绍</title><link>https://www.EWhisper.cn/nginx-handbook-3-0-foreword.html</link><description>&lt;h2 id="30"&gt;3.0 前言和介绍&lt;a class="headerlink" href="#30" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在NGINX CookBook的第一部分, 主题是负载均衡和缓存. 第二部分是NGINX的安全功能, 如认证和加密. 第三部分集中于NGINX的运维问你, 包括部署, 性能调优和解决问题.&lt;/p&gt;
&lt;p&gt;在这部分, 你会看到基于三个大型公有云的NGINX部署实践: Amazon Web Services(AWS), Google Cloud Platform(GCP), 和微软Azure, 包括如何自动化在AWS上部署. 如果你计划使用Docker, 也有相关内容.&lt;/p&gt;
&lt;p&gt;安装也会深入讨论使用Puppet, Chef, Ansible和SaltStack的自动化配置管理. 也介绍了使用NGINX Plus API来实施重配置, 使用Consul进行服务发现和模版配置.&lt;/p&gt;
&lt;p&gt;默认情况下, 大部分系统配置是基于兼容性而不是性能. 然后你要根据你的特定需求进行性能调优. 在本书中, 你会找到在保持兼容性的前提下, 详细的最大化NGINX性能的方法.&lt;/p&gt;
&lt;p&gt;当我碰到部署问题, 我首先会看日志文件, 是很多调试信息的来源. NGINX有维护详细的, 高度配置化的日志来帮助你定位问题. 本书中包含NGINX日志的详细内容.&lt;/p&gt;
&lt;p&gt;它会帮助你安装, 监控, 维护NGINX应用交付平台.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:28:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-0-foreword.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-运维-在Docker 上部署</title><link>https://www.EWhisper.cn/nginx-handbook-3-4-nginx-docker.html</link><description>&lt;h2 id="34-docker"&gt;3.4 在Docker上部署&lt;a class="headerlink" href="#34-docker" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="340"&gt;3.4.0 介绍&lt;a class="headerlink" href="#340" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Docker是个开源项目, 会自动把Linux应用部署到软件容器中. Docker提供一个额外的抽象层, 在linux上自动化操作系统级别的虚拟化. 容器化环境已经对生产世界造成了巨大的变革. Docker和其他容器平台允许快速, 可靠, 跨平台的应用部署. 本章中, 我们会讨论NGINX官方NGINX Dockerjingxiang,创建你自己的Docker文件来运行NGINX, 在NGINX中使用环境变量, 通用Docker实践.&lt;/p&gt;
&lt;h3 id="341-nginx"&gt;3.4.1 使用NGINX镜像快速运行&lt;a class="headerlink" href="#341-nginx" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要使用Docker Hub中的NGINX镜像快速启动和运行.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker pull nginx:latest
$ docker run -it -p &lt;span class="m"&gt;80&lt;/span&gt;:80 -v &lt;span class="nv"&gt;$PWD&lt;/span&gt;/nginx-conf:/etc/nginx &lt;span class="se"&gt;\&lt;/span&gt;
                                   nginx:latest
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;NGINX已经在Docker Hub上制作了一个官方Docker镜像. 官方Docker镜像很容易在Docker中启动和快速运行. 在本节中我们通过2个命令就能启动和运行NGINX 容器. 官方镜像是基于Debian Jessie Docker镜像. 但是你也可以选择基于Alpine Linux构建的官方镜像. 这些官方镜像的Dockerfile和源码可以在GitHub中找到.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://hub.docker.com/_/nginx/"&gt;Official NGINX Docker image, NGINX&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/nginxinc/docker-nginx/"&gt;Docker repo on GitHub&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="342-nginx-dockerfile"&gt;3.4.2 创建一个NGINX Dockerfile&lt;a class="headerlink" href="#342-nginx-dockerfile" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要创建一个NGINX Dockerfile, 用Dockerfile创建Docker镜像.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;CMD&lt;/code&gt;来在镜像实例化为容器时启动NGINX. 你需要在前台运行NGINX. 要这么做, 需要启动NGINX使用&lt;code&gt;-g "daemon off;"&lt;/code&gt;或增加&lt;code&gt;daemon off;&lt;/code&gt;到配置. 本例中稍后使用&lt;code&gt;daemon off;&lt;/code&gt;加到main context. 你也想调节你的access日志输出到&lt;code&gt;/dev/stdout&lt;/code&gt;, 错误日志输出到&lt;code&gt;/dev/stderr&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="s"&gt; centos:7&lt;/span&gt;
&lt;span class="c"&gt;# Install epel repo to get nginx and install nginx&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; yum -y install epel-release &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    yum -y install nginx
&lt;span class="c"&gt;# add local configuration files into the image&lt;/span&gt;
&lt;span class="k"&gt;ADD&lt;/span&gt; /nginx-conf /etc/nginx
&lt;span class="k"&gt;EXPOSE&lt;/span&gt;&lt;span class="s"&gt; 80 443&lt;/span&gt;
&lt;span class="k"&gt;CMD&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;nginx&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;目录结构如下所示:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;.
├── Dockerfile
└── nginx-conf
    ├── conf.d
    │   └── default.conf
    ├── fastcgi.conf
    ├── fastcgi_params
    ├── koi-utf
    ├── koi-win
    ├── mime.types
    ├── nginx.conf
    ├── scgi_params
    ├── uwsgi_params
    └── win-utf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在本例中, 我选择直接吧nginx-conf目录下所有我的NGINX配置都添加到Dockerfile中.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;当你需要完全控制包的安装和升级, 你会发现创建自己的Dockerfile很有用. 常见操作是保存在你自己的镜像仓库中, 这样你会知道你的基础镜像在上生产之前是可靠的, 经过团队测试的.&lt;/p&gt;
&lt;h3 id="343-nginx-plus"&gt;3.4.3 构建NGINX Plus镜像&lt;a class="headerlink" href="#343-nginx-plus" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="344-nginx"&gt;3.4.4 在NGINX中使用环境变量&lt;a class="headerlink" href="#344-nginx" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;为了在不同的环境中使用相同的容器镜像, 你需要在NGINX配置文件中使用环境变量.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;ngx_http_perl_module&lt;/code&gt;来从你的环境的NGINX中设置变量.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;daemon&lt;/span&gt; &lt;span class="no"&gt;off&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;env&lt;/span&gt; &lt;span class="s"&gt;APP_DNS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;include&lt;/span&gt; &lt;span class="n"&gt;/usr/share/nginx/modules/*.conf&lt;/span&gt;;
&lt;span class="k"&gt;...&lt;/span&gt;
&lt;span class="s"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kn"&gt;perl_set&lt;/span&gt; &lt;span class="nv"&gt;$upstream_app&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;sub&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="nv"&gt;$ENV{&amp;quot;APP_DNS&amp;quot;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="kn"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kn"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;...&lt;/span&gt;
    &lt;span class="s"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="kn"&gt;proxy_pass&lt;/span&gt; &lt;span class="s"&gt;https://&lt;/span&gt;&lt;span class="nv"&gt;$upstream_app&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;要使用&lt;code&gt;perl_set&lt;/code&gt;, 你必须安装&lt;code&gt;ngx_http_perl_module&lt;/code&gt;; 你可以通过动态模块加载或从源码静态构建. NGINX默认从环境中擦除环境变量; 你需要在&lt;code&gt;env&lt;/code&gt;指令中声明任何你不想移除的变量. &lt;code&gt;perl_set&lt;/code&gt;指令有2个参数: 你想要设置的变量名和渲染结果的perl字符串.&lt;/p&gt;
&lt;p&gt;下面是一个Dockerfile, 会动态加载&lt;code&gt;ngx_http_perl_module&lt;/code&gt;, 从包管理工具安装该模块. 当从CentOS的包管理中安装模块, 他们被放在&lt;code&gt;/usr/lib64/nginx/modules/&lt;/code&gt;目录, 配置文件会动态加载在&lt;code&gt;/usr/share/nginx/modules/&lt;/code&gt;目录的模块. 这就是为什么上面的配置块中, 要包含完整的路径.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="s"&gt; centos:7&lt;/span&gt;
&lt;span class="c"&gt;# Install epel repo to get nginx and install nginx&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; yum -y install epel-release &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    yum -y install nginx nginx-mod-http-perl
&lt;span class="c"&gt;# add local configuration files into the image&lt;/span&gt;
&lt;span class="k"&gt;ADD&lt;/span&gt; /nginx-conf /etc/nginx
&lt;span class="k"&gt;EXPOSE&lt;/span&gt;&lt;span class="s"&gt; 80 443&lt;/span&gt;
&lt;span class="k"&gt;CMD&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;nginx&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;当使用Docker, 典型实践就是利用环境变量来修改容器操作的方式. 你可以在NGINX配置文件中使用环境变量, 这样NGINX可以用于多个, 不同的环境.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:28:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-4-nginx-docker.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category><category>docker</category></item><item><title>NGINX 实战手册-运维-使用Puppet/Chef/Ansible/SaltStack部署</title><link>https://www.EWhisper.cn/nginx-handbook-3-5-nginx-autoconf-tools.html</link><description>&lt;h2 id="35-puppetchefansiblesaltstack"&gt;3.5 使用Puppet/Chef/Ansible/SaltStack&lt;a class="headerlink" href="#35-puppetchefansiblesaltstack" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="350"&gt;3.5.0 介绍&lt;a class="headerlink" href="#350" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在云的时代, 配置管理工具是无价之宝. 大规模web应用的工程师无法通过代码手把手配置servers, 但是使用其中任何一个配置管理工具都可以做到. 配置管理工具允许工程师一次写入配置和代码到很多有相同配置的server, 通过使用一种可重复, 可测试, 模块化的方式. 本章讨论几个流行的配置管理工具, 以及如何使用他们安装NIGINX和从模版创建一个基本配置. 这些例子非常基础, 但是展示了如何通过每个平台来启动NGINX.&lt;/p&gt;
&lt;h3 id="351-puppet"&gt;3.5.1 使用Puppet安装&lt;a class="headerlink" href="#351-puppet" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要通过Puppet安装和配置NGINX, 以代码形式管理NGINX配置, 并确认你的其他Puppet配置.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;创建一个模块, 用于安装NGINX, 管理你需要的文件, 确保NGINX在运行:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;nginx&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;package&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;nginx&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;ensure&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;installed&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,}&lt;/span&gt;
    &lt;span class="n"&gt;service&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;nginx&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;ensure&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;true&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;hasrestart&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;true&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;restart&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/etc/init.d/nginx reload&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;nginx.conf&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;path&lt;/span&gt;    &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/etc/nginx/nginx.conf&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Package&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;nginx&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;notify&lt;/span&gt;  &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Service&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;nginx&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;nginx/templates/nginx.conf.erb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;root&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;root&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;0644&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该模块使用包管理工具来确保NGINX被安装. 也会确保NGINX在启动时在运行和可用. 该配置通知Puppet, 该服务有重启命令, 通过&lt;code&gt;hasrestart&lt;/code&gt;指令, 并且我们用NGINX reload命令覆盖&lt;code&gt;restart&lt;/code&gt;命令. 它通过内置Ruby(ERB)模版语言来管理和模板化&lt;code&gt;nginx.conf&lt;/code&gt;文件. 文件的模板化会发生在NGINX包被安装之后(通过&lt;code&gt;require&lt;/code&gt;指令). 但是, 它会通过&lt;code&gt;notify&lt;/code&gt;指令通知NGINX服务来reload. 该模版化配置文件没有包括. 另外, 它可以简单安装一个默认的NGINX配置文件, 或是使用内置Ruby(ERB)或内置Puppet(EPP)模版语言的循环和变量替换.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;Puppet是基于Ruby语言的配置管理工具. 模块被构建进一个特定域的语言, 并通过定义给定server配置的manifest文件调用. Puppet可以用主从或masterless模式运行. 使用Puppet, manifest运行在master上, 然后发到slave上. 这很重要, 因为它确保slave只是被交付对它有用的配置, 对其他server的其他配置是不会给这个slave的. Puppet有很多非常高级的公用模块. 通过这些模块, 会在配置上帮助你飞起. 在GitHub上来自voxpupuli的公共NGINX模块会为你模板化NGINX配置.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://docs.puppet.com/"&gt;Puppet documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jfgpm4"&gt;Puppet package documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jMq2cx"&gt;Puppet service documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jMz4q3"&gt;Puppet file documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2isqAlP"&gt;Puppet templating documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jMspMn"&gt;Voxpupuli NGINX module&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="352-chef"&gt;3.5.2 使用Chef安装&lt;a class="headerlink" href="#352-chef" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="353-ansible"&gt;3.5.3 使用Ansible安装&lt;a class="headerlink" href="#353-ansible" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要使用Ansible来安装和配置NGINX, 以代码形式管理NGINX配置, 并确认你的其他Ansible配置.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;创建一个安装NGINX和管理&lt;em&gt;nginx.conf&lt;/em&gt;文件playbook. 下列是一个示例的任务文件.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;NGINX | Installing NGINX&lt;/span&gt;
  &lt;span class="nt"&gt;package&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;name=nginx state=present&lt;/span&gt;

&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;NGINX | Starting NGINX&lt;/span&gt;
  &lt;span class="nt"&gt;service&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;nginx&lt;/span&gt;
    &lt;span class="nt"&gt;state&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;started&lt;/span&gt;
    &lt;span class="nt"&gt;enabled&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;yes&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;Copy nginx configuration in place.&lt;/span&gt;
  &lt;span class="nt"&gt;template&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nt"&gt;src&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;nginx.conf.j2&lt;/span&gt;
    &lt;span class="nt"&gt;dest&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/etc/nginx/nginx.conf&amp;quot;&lt;/span&gt;
    &lt;span class="nt"&gt;owner&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;root&lt;/span&gt;
    &lt;span class="nt"&gt;group&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;root&lt;/span&gt;
    &lt;span class="nt"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;0644&lt;/span&gt;
  &lt;span class="nt"&gt;notify&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;reload nginx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;package&lt;/code&gt;块安装NGINX. &lt;code&gt;service&lt;/code&gt;块确保NGINX在启动时被启动和可用. &lt;code&gt;template&lt;/code&gt;块模板化一个&lt;em&gt;Jinja2&lt;/em&gt;文件, 并把结果以root用户和组放到&lt;code&gt;/etc/nginx.conf&lt;/code&gt;中. 该模版块也设置&lt;em&gt;mode&lt;/em&gt;为644, 并通知nginx服务reload. 模板化配置文件没有包含在内. 但是, 可以通过默认的NGINX配置文件来简单, 或者通过Jinja2模版语言的循环和变量替换生成很复杂的模版.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;Ansible是用Python编写的广泛使用的强大配置管理工具. 任务配置使用YAML, 使用Jinja2模版语言生成文件模版. Ansible提供一个有master的叫做Ansible Tower的订阅版. 但是, 它经常用于本地机器或构建服务器直接到客户端或者使用masterless模式. Ansible打包SSH到它的server并运行配置. 和其他配置工具类似, 有很多社区提供的公共roles, Ansible把它叫做Ansible Galaxy. 你可以找到可以用于你的playbook的非常复杂的roles.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://docs.ansible.com/"&gt;Ansible documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jfiwGv"&gt;Ansible packages&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jMGF7E"&gt;Ansible service&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2j8j526"&gt;Ansible template&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://galaxy.ansible.com/"&gt;Ansible Galaxy&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="354-saltstack"&gt;3.5.4 使用SaltStack安装&lt;a class="headerlink" href="#354-saltstack" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要使用SaltStack来安装和配置NGINX, 以代码形式管理NGINX配置, 并确认你的其他SaltStack配置.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;nginx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;pkg&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;installed&lt;/span&gt;
  &lt;span class="nt"&gt;service&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;nginx&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;running&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;enable&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;True&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;reload&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;True&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;watch&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;file&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;/etc/nginx/nginx.conf&lt;/span&gt;

&lt;span class="nt"&gt;/etc/nginx/nginx.conf&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;file&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;managed&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;source&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;salt://path/to/nginx.conf&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;user&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;root&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;group&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;root&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;template&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;jinja&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;644&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;require&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;pkg&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;nginx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:28:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-5-nginx-autoconf-tools.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category></item><item><title>使用OpenShift进行二进制构建</title><link>https://www.EWhisper.cn/binary-builds-with-openshift.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;介绍&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_2"&gt;用例&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;限制&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;教程概述&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_5"&gt;教程：构建本地代码更改&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_6"&gt;教程：构建私有代码&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#pipeline"&gt;教程：来自 pipeline 的二进制工件&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;介绍&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;OpenShift 推荐和常用的构建方式是: 直接从代码仓库(如GIT 或SVN)中拉取源码进行构建(即源码构建). 但是这一种构建方式并不能满足所有的需求, 所以还有一种构建方式就是: 二进制构建. 二进制构建适用于以下2个场景:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;开发人员本地开发调试代码并构建;&lt;/li&gt;
&lt;li&gt;OpenShift和 CI/CD的pipeline进行整合, 获取从前边平台(如自动化开发平台或测试平台)传过来的工件(即二进制包)并构建为镜像.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;OpenShift中的二进制构建功能允许开发人员将源代码或工件直接上传到构建(build)，而不是从Git存储库URL pull需要构建的源。通过源代码，Docker或自定义构建策略的 BuildConfig 都可以作为二进制构建启动。从本地工件启动构建时，现有源引用将替换为来自本地用户计算机的源。&lt;/p&gt;
&lt;p&gt;可以使用几种方式提供源，这些方式对应于使用&lt;code&gt;start-build&lt;/code&gt;命令时可用的参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;从文件（&lt;code&gt;--from-file&lt;/code&gt;）：当构建的整个源包含单个文件时就是这种情况。例如，它可能是用于Docker构建的&lt;code&gt;Dockerfile&lt;/code&gt;，用于Java应用构建的&lt;code&gt;pom.xml&lt;/code&gt;，或用于Ruby构建的&lt;code&gt;Gemfile&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;从目录（&lt;code&gt;--from-directory&lt;/code&gt;）：当源在本地目录中并且未提交到Git存储库时使用此目录。&lt;code&gt;start-build&lt;/code&gt; 命令将创建给定目录的存档，并将其作为源上传到构建器(builder)。&lt;/li&gt;
&lt;li&gt;从存档（&lt;code&gt;--from-archive&lt;/code&gt;）：当具有源的存档已存在时使用此选项。该存档可以是&lt;code&gt;tar&lt;/code&gt;，&lt;code&gt;tar.gz&lt;/code&gt;或&lt;code&gt;zip&lt;/code&gt;格式。&lt;/li&gt;
&lt;li&gt;从Git存储库（&lt;code&gt;--from-repo&lt;/code&gt;）：源是当前用户本地计算机上的Git存储库的一部分。当前存储库的HEAD commit将被存档并发送到OpenShift进行构建。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_2"&gt;用例&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;二进制构建适用于无法从现有Git存储库中提取源的需求。使用二进制构建的原因包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;构建和测试本地代码的变更。克隆来自公共存储库的源，并将本地变更上传到OpenShift进行构建。而无需在任何地方提交或推送本地更改。&lt;/li&gt;
&lt;li&gt;构建私有代码。新构建可以作为二进制构建从头开始。然后可以将源直接从本地工作站上传到OpenShift，而无需将其签入SCM。&lt;/li&gt;
&lt;li&gt;使用其他来源的工件构建镜像。通过Jenkins pipeline，二进制构建可以用于整合使用Maven或C编译器等工具构建的工件，以及使用这些构建的运行时镜像。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_3"&gt;限制&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;二进制构建无法重复。由于二进制构建依赖于在构建开始时用户上传工件，因此OpenShift无法重复相同的构建而无需用户每次都重复相同的上载。&lt;/li&gt;
&lt;li&gt;无法自动触发二进制生成。它们只能在用户上传所需的二进制工件时手动启动。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;&lt;/p&gt;
&lt;p&gt;以二进制构建方式启动的构建版本也可能具有已配置的源URL。如果是这种情况，触发器会成功启动构建，但源将来自配置的源URL，而不是来自上次构建运行时用户提供的源。(比如: 用户先从Git仓库下载了源码并修改, 用本地修改后的源码手动上传、构建，那么OpenShift会获取到Git仓库的URL, 如果配置了触发器, 下次构建就直接通过Git URL pull源码并自动构建, 而不是自动获取本地的源码.)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="_4"&gt;教程概述&lt;a class="headerlink" href="#_4" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;以下教程假设您有一个可用的OpenShift集群，并且您有一个可以创建工件的项目。它要求您拥有本地&lt;code&gt;git&lt;/code&gt;和&lt;code&gt;oc&lt;/code&gt;客户端。&lt;/p&gt;
&lt;h3 id="_5"&gt;教程：构建本地代码更改&lt;a class="headerlink" href="#_5" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;基于现有源存储库创建新应用程序并为其创建路由：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;oc new-app https://github.com/openshift/ruby-hello-world.git
oc expose svc/ruby-hello-world
&lt;/pre&gt;&lt;/div&gt;


&lt;ol start="2"&gt;
&lt;li&gt;等待初始构建完成并通过route来查看应用程序的页面。你应该得到一个欢迎页面：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;oc get route ruby-hello-world
&lt;/pre&gt;&lt;/div&gt;


&lt;ol start="3"&gt;
&lt;li&gt;在本地克隆存储库：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git clone https://github.com/openshift/ruby-hello-world.git
&lt;span class="nb"&gt;cd&lt;/span&gt; ruby-hello-world
&lt;/pre&gt;&lt;/div&gt;


&lt;ol start="4"&gt;
&lt;li&gt;
&lt;p&gt;更改应用程序的视图。使用您喜欢的编辑器编辑 &lt;code&gt;views/main.rb&lt;/code&gt;：将&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;标签更改为&lt;code&gt;&amp;lt;body style="background-color:blue"&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用本地修改的源启动新构建。在存储库的本地目录中，运行：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;oc start-build ruby-hello-world --from-dir&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;.&amp;quot;&lt;/span&gt; --follow
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;构建完成并重新部署应用程序后，指向应用程序主机的route应该会生成一个蓝色背景的页面。&lt;/p&gt;
&lt;p&gt;您可以继续在本地进行更改并使用&lt;code&gt;oc start-build --from-dir&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;您还可以创建代码分支，在本地提交更改，并使用存储库的HEAD作为构建的源：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;git checkout -b my_branch
git add .
git commit -m &lt;span class="s2"&gt;&amp;quot;My changes&amp;quot;&lt;/span&gt;
oc start-build ruby-hello-world --from-repo&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;.&amp;quot;&lt;/span&gt; --follow
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_6"&gt;教程：构建私有代码&lt;a class="headerlink" href="#_6" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;创建一个本地目录来保存您的代码：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mkdir myapp
&lt;span class="nb"&gt;cd&lt;/span&gt; myapp
&lt;/pre&gt;&lt;/div&gt;


&lt;ol start="2"&gt;
&lt;li&gt;在目录中创建一个名为&lt;code&gt;Dockerfile&lt;/code&gt;的文件：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="s"&gt; centos:centos7&lt;/span&gt;
&lt;span class="k"&gt;EXPOSE&lt;/span&gt;&lt;span class="s"&gt; 8080&lt;/span&gt;
&lt;span class="k"&gt;COPY&lt;/span&gt; index.html /var/run/web/index.html
&lt;span class="k"&gt;CMD&lt;/span&gt; &lt;span class="nb"&gt;cd&lt;/span&gt; /var/run/web &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; python -m SimpleHTTPServer &lt;span class="m"&gt;8080&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol start="3"&gt;
&lt;li&gt;创建一个&lt;code&gt;index.html&lt;/code&gt;文件：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;html&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;head&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;title&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;My local app&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;title&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;head&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;body&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;h1&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;Hello World&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;h1&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;This is my local application&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;p&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
  &lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;body&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="p"&gt;&amp;lt;/&lt;/span&gt;&lt;span class="nt"&gt;html&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol start="4"&gt;
&lt;li&gt;为您的应用程序创建一个新的构建：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;oc new-build --strategy docker --binary --docker-image centos:centos7 --name myapp
&lt;/pre&gt;&lt;/div&gt;


&lt;ol start="5"&gt;
&lt;li&gt;使用本地目录的内容启动二进制构建：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;oc start-build myapp --from-dir . --follow
&lt;/pre&gt;&lt;/div&gt;


&lt;ol start="6"&gt;
&lt;li&gt;使用&lt;code&gt;new-app&lt;/code&gt;部署应用程序，然后为其创建路由：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;oc new-app myapp
oc expose svc/myapp
&lt;/pre&gt;&lt;/div&gt;


&lt;ol start="7"&gt;
&lt;li&gt;获取指向对应应用主机的路由：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;oc get route myapp
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在构建和部署代码之后，您可以通过更改本地文件并通过&lt;code&gt;oc start-build myapp --from-dir&lt;/code&gt;再次调用启动新构建来进行迭代。构建完成后，代码将自动部署，更新的内容将在刷新页面时反映在浏览器中。&lt;/p&gt;
&lt;h3 id="pipeline"&gt;教程：来自 pipeline 的二进制工件&lt;a class="headerlink" href="#pipeline" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;OpenShift上的Jenkins允许使用带有合适工具的slave镜像来构建代码。例如，您可以使用&lt;code&gt;maven&lt;/code&gt; slave镜像来从代码存储库构建WAR包。但是，一旦构建了此工件，您需要将其提交到包含正确的运行时工件的镜像以运行您的代码。可以使用二进制构建将这些工件添加到运行时映像。在下面的教程中，我们将创建一个Jenkins pipeline，该pipeline使用&lt;code&gt;maven&lt;/code&gt; slave构建WAR，然后使用带有&lt;code&gt;Dockerfile&lt;/code&gt;的二进制构建将WAR添加到 wildfly 运行时映像。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为您的应用程序创建一个新目录：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mkdir mavenapp
&lt;span class="nb"&gt;cd&lt;/span&gt; mavenapp
&lt;/pre&gt;&lt;/div&gt;


&lt;ol start="2"&gt;
&lt;li&gt;创建一个&lt;code&gt;Dockerfile&lt;/code&gt;将WAR复制到wildfly镜像内的适当位置以供执行。将以下内容复制到名为的本地文件 &lt;code&gt;Dockerfile&lt;/code&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="s"&gt; wildfly:latest&lt;/span&gt;
&lt;span class="k"&gt;COPY&lt;/span&gt; ROOT.war /wildfly/standalone/deployments/ROOT.war
&lt;span class="k"&gt;CMD&lt;/span&gt;  &lt;span class="nv"&gt;$STI_SCRIPTS_PATH&lt;/span&gt;/run
&lt;/pre&gt;&lt;/div&gt;


&lt;ol start="3"&gt;
&lt;li&gt;为该&lt;code&gt;Dockerfile&lt;/code&gt;创建一个新的BuildConfig：&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;&lt;/p&gt;
&lt;p&gt;这将自动启动一个构建, 刚开始会构建失败，因为 &lt;code&gt;ROOT.war&lt;/code&gt;工件尚不可用。下面的pipeline将使用二进制构建将该WAR包传递给构建。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cat Dockerfile &lt;span class="p"&gt;|&lt;/span&gt; oc new-build -D - --name mavenapp
&lt;/pre&gt;&lt;/div&gt;


&lt;ol start="4"&gt;
&lt;li&gt;创建1个使用Jenkins pipeline的BuildConfig, 这个BuildConfig将构建1个WAR包，然后使用该WAR包和先前创建的&lt;code&gt;Dockerfile&lt;/code&gt;来构建镜像。相同的模式可用于其他平台，其中二进制工件由一组工具构建，然后与最终的包含不同运行时的镜像组合。将以下代码保存到&lt;code&gt;mavenapp-pipeline.yml&lt;/code&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;apiVersion&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;v1&lt;/span&gt;
&lt;span class="nt"&gt;kind&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;BuildConfig&lt;/span&gt;
&lt;span class="nt"&gt;metadata&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;mavenapp-pipeline&lt;/span&gt;
&lt;span class="nt"&gt;spec&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;strategy&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nt"&gt;jenkinsPipelineStrategy&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="nt"&gt;jenkinsfile&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p p-Indicator"&gt;|-&lt;/span&gt;
        &lt;span class="no"&gt;pipeline {&lt;/span&gt;
          &lt;span class="no"&gt;agent { label &amp;quot;maven&amp;quot; }&lt;/span&gt;
          &lt;span class="no"&gt;stages {&lt;/span&gt;
            &lt;span class="no"&gt;stage(&amp;quot;Clone Source&amp;quot;) {&lt;/span&gt;
              &lt;span class="no"&gt;steps {&lt;/span&gt;
                &lt;span class="no"&gt;checkout([$class: &amp;#39;GitSCM&amp;#39;,&lt;/span&gt;
                            &lt;span class="no"&gt;branches: [[name: &amp;#39;*/master&amp;#39;]],&lt;/span&gt;
                            &lt;span class="no"&gt;extensions: [&lt;/span&gt;
                              &lt;span class="no"&gt;[$class: &amp;#39;RelativeTargetDirectory&amp;#39;, relativeTargetDir: &amp;#39;mavenapp&amp;#39;]&lt;/span&gt;
                            &lt;span class="no"&gt;],&lt;/span&gt;
                            &lt;span class="no"&gt;userRemoteConfigs: [[url: &amp;#39;https://github.com/openshift/openshift-jee-sample.git&amp;#39;]]&lt;/span&gt;
                        &lt;span class="no"&gt;])&lt;/span&gt;
              &lt;span class="no"&gt;}&lt;/span&gt;
            &lt;span class="no"&gt;}&lt;/span&gt;
            &lt;span class="no"&gt;stage(&amp;quot;Build WAR&amp;quot;) {&lt;/span&gt;
              &lt;span class="no"&gt;steps {&lt;/span&gt;
                &lt;span class="no"&gt;dir(&amp;#39;mavenapp&amp;#39;) {&lt;/span&gt;
                  &lt;span class="no"&gt;sh &amp;#39;mvn clean package -Popenshift&amp;#39;&lt;/span&gt;
                &lt;span class="no"&gt;}&lt;/span&gt;
              &lt;span class="no"&gt;}&lt;/span&gt;
            &lt;span class="no"&gt;}&lt;/span&gt;
            &lt;span class="no"&gt;stage(&amp;quot;Build Image&amp;quot;) {&lt;/span&gt;
              &lt;span class="no"&gt;steps {&lt;/span&gt;
                &lt;span class="no"&gt;dir(&amp;#39;mavenapp/target&amp;#39;) {&lt;/span&gt;
                  &lt;span class="no"&gt;sh &amp;#39;oc start-build mavenapp --from-dir . --follow&amp;#39;&lt;/span&gt;
                &lt;span class="no"&gt;}&lt;/span&gt;
              &lt;span class="no"&gt;}&lt;/span&gt;
            &lt;span class="no"&gt;}&lt;/span&gt;
          &lt;span class="no"&gt;}&lt;/span&gt;
        &lt;span class="no"&gt;}&lt;/span&gt;
    &lt;span class="nt"&gt;type&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;JenkinsPipeline&lt;/span&gt;
  &lt;span class="nt"&gt;triggers&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p p-Indicator"&gt;[]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ol start="5"&gt;
&lt;li&gt;创建pipeline 构建。如果Jenkins未部署到您的项目中，则使用管道创建的BuildConfig会先部署Jenkins。在Jenkins准备建立您的管道之前可能需要几分钟来启动。您可以通过调用&lt;code&gt;oc rollout status dc/jenkins&lt;/code&gt;来检查Jenkins的状态：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;oc create -f ./mavenapp-pipeline.yml
&lt;/pre&gt;&lt;/div&gt;


&lt;ol start="6"&gt;
&lt;li&gt;一旦Jenkins准备就绪，启动之前定义的管道：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;oc start-build mavenapp-pipeline
&lt;/pre&gt;&lt;/div&gt;


&lt;ol start="7"&gt;
&lt;li&gt;管道构建完成后，使用&lt;code&gt;new-app&lt;/code&gt;部署新应用程序并公开其route：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;oc new-app mavenapp
oc expose svc/mavenapp
&lt;/pre&gt;&lt;/div&gt;


&lt;ol start="8"&gt;
&lt;li&gt;使用浏览器，导航到应用程序的路径：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;oc get route mavenapp
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 08 May 2019 18:41:34 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-05-08:/binary-builds-with-openshift.html</guid><category>openshift</category><category>docker</category><category>devops</category><category>git</category><category>containers</category></item><item><title>SRE 宣言</title><link>https://www.EWhisper.cn/the-declaration-of-sre.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#sre"&gt;SRE 宣言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sre_1"&gt;SRE 成立背景&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sre_2"&gt;何为SRE&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#sre_3"&gt;SRE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sre_4"&gt;SRE 的目标&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#sre_5"&gt;SRE 运维体系&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#sre_6"&gt;SRE 建设阶段&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_1"&gt;总结&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="sre"&gt;SRE 宣言&lt;a class="headerlink" href="#sre" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;今天(2019年4月1日)是个对于我来说值得永远铭记的日子.&lt;/p&gt;
&lt;p&gt;从今天起, 我由一名普通的运维转变为一名普通的SRE. 我们专注于: 提高效率, 提高业务连续性, 最终提高用户满意度. 无论是公司的客户, 还是分公司、子公司的用户, 亦或是IT开发分部的同事, 你们都是我们的服务"用户". 我会用我的十分努力, 来换得效率的+1%, 来换得业务连续性的+1s, 来换得你们点赞与笑脸的+1+1.&lt;/p&gt;
&lt;h2 id="sre_1"&gt;SRE 成立背景&lt;a class="headerlink" href="#sre_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;过去一段时间, 我们发现我们运维切实地存在以下问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;运维和开发衔接不畅. 运维分部是专业组的组织架构, 就拿新系统上线来举例, 开发几乎需要问遍运维分部内的各个专业组, 从: 主机、中间件、数据库、网络再到安全、监控等等等等。而且时长面临着对方“不是我负责的，你找其他人吧”式的被踢皮球的感受。&lt;/li&gt;
&lt;li&gt;部署规模越来越庞大。随着各类私有云、公有云的引入，微服务架构的引入，以及数字化转型，竞争的激烈。近些年，系统的部署规模较前年甚至都有成倍数的增长，现有的运维模式对于越来越庞大的规模有些力不从心。&lt;/li&gt;
&lt;li&gt;新技术的引入。还是上面提到的，云的引入，容器的引入，开源技术栈（包括：web server，中间件，MQ，缓存，NoSQL...)的引入以及随之而来的工具链的引入(Ansible, SaltStack, Jenkins, Zabbix, ELK...)也带来技术链的爆炸式增长. 而这些也都是需要运维具有相应的技术储备的.&lt;/li&gt;
&lt;li&gt;开发分部DevOps. 开发分部也在推动DevOps的体系. 我们的体系也要和开发分部相对应.&lt;/li&gt;
&lt;li&gt;技术能力的积累和变现.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="sre_2"&gt;何为SRE&lt;a class="headerlink" href="#sre_2" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="sre_3"&gt;SRE&lt;a class="headerlink" href="#sre_3" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;img alt="SRE logo" src="./images/reliability-icon-t_0.png"&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;定义:&lt;br&gt;
SRE 是谷歌针对DevOps的生产实践和运行模型. 软件由开发团队显示"交接给"运行软件的团队, 即Site Reliability Engineer(SRE, 网站可靠性工程团队). 在这个模型中, Dev团队需要向 SRE 团队提供测试证据(日志, 指标等), 证明他们的软件已经达到一个 SRE 团队认为足够好的标准.&lt;br&gt;
至关重要的是, SRE 团队可以拒绝不符合运维标准的软件(包括开发分部和运维分部的软件), 要求开发人员在投入生产之前改进代码. Dev 和 SRE之间的协作围绕着&lt;strong&gt;运维标准&lt;/strong&gt;展开, 但是, 一旦 SRE 团队对代码满意, 他们(而不是Dev团队)就会在生产环境中提供支持.&lt;/p&gt;
&lt;p&gt;这个模型只适用于工程和组织成熟度较高的组织, 如果运行不当, 可能变为 "Dev 和 Ops筒仓"的模式.&lt;br&gt;
节选自: &lt;a href="https://www.infoq.cn/article/DcIUD_gi17sQjvSt5XSS"&gt;DevOps团队结构类型汇总：总有一款适合你&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img alt="SRE模型" src="./images/devops-models-type-7.png"&gt;&lt;/p&gt;
&lt;p&gt;&lt;img alt="dev ops 筒仓" src="./images/anti-devops-models-1.png"&gt;&lt;/p&gt;
&lt;h3 id="sre_4"&gt;SRE 的目标&lt;a class="headerlink" href="#sre_4" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;SRE的目标有"三化", 也是承接了实现公司的"三化"战略. SRE目标为:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;平台化&lt;/li&gt;
&lt;li&gt;服务化&lt;/li&gt;
&lt;li&gt;自动化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="sre_5"&gt;SRE 运维体系&lt;a class="headerlink" href="#sre_5" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;SRE 运维体系有"三驾马车". &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SRE. 位于金字塔尖, 对外提供服务.&lt;/li&gt;
&lt;li&gt;技术服务. 即: 专业组. "使能"SRE团队.&lt;/li&gt;
&lt;li&gt;运维开发. 新成立(目前还未成立, 过渡期). "赋能"SRE团队. 打造以"三化"为目标的平台, 工具集.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="sre_6"&gt;SRE 建设阶段&lt;a class="headerlink" href="#sre_6" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;这是公司运维分部近十年来的首次变革, 变革需要逐步稳步推进. SRE 建设也会分阶段进行:&lt;br&gt;
当前阶段的主要工作是:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;扎口&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;监控告警扎口&lt;/li&gt;
&lt;li&gt;应用, 数据库发布扎口&lt;/li&gt;
&lt;li&gt;资源, 集成部署扎口&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;工具平台建设&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;自动化运维平台建设&lt;/li&gt;
&lt;li&gt;统一监控告警平台建设&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_1"&gt;总结&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;最终目标&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提高效率&lt;/li&gt;
&lt;li&gt;提高业务连续性&lt;/li&gt;
&lt;li&gt;最终提高客户满意度&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分阶段, 分步骤推进&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;运维团队以往积累了一些优秀的品质, 但也慢慢积累了惰性. 懒惰, 固步自封要被严肃处理.&lt;/li&gt;
&lt;li&gt;用于探索和实践. 敢于试错, 从失败中吸取经验教训.&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Tue, 02 Apr 2019 08:32:07 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-04-02:/the-declaration-of-sre.html</guid><category>DevOps</category><category>SRE</category></item><item><title>DevOps能力成熟度调查问卷</title><link>https://www.EWhisper.cn/devops-questionnaire.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;（一）配置管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;（二）构建与持续集成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;（三）构建与持续集成&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;（四）测试管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_5"&gt;（五）部署与发布管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_6"&gt;（六）环境管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_7"&gt;（七）数据管理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_8"&gt;（八）度量与反馈&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_9"&gt;（九）分布式应用架构&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img align="absmiddle" alt="📓" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f4d3.png" title=":notebook:" width="20px"&gt; 问卷说明:&lt;/p&gt;
&lt;p&gt;本问卷来自互联网.&lt;br&gt;
本问卷由九个板块构成,一共73道题, 全部为单选题.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="_1"&gt;（一）配置管理&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;1、版本控制系统&lt;/p&gt;
&lt;p&gt;·       A、未使用统一的版本控制系统，源代码分散在研发本地设备管理。&lt;/p&gt;
&lt;p&gt;·       B、使用集中式的版本控制系统并将所有源代码纳入系统管理。&lt;/p&gt;
&lt;p&gt;·       C、使用分布式的版本控制系统，并将所有源代码、配置文件、构建和部署等自动化脚本纳入系统管理。&lt;/p&gt;
&lt;p&gt;·       D、将数据库变更脚本和环境配置等纳入版本控制系统管理版本控制系统支持自动化的变更操作。&lt;/p&gt;
&lt;p&gt;·       E、将软件生命周期的所有配置项纳入版本控制系统管理，可完整回溯软件交付过程满足审计要求。&lt;/p&gt;
&lt;p&gt;2、分支管理&lt;/p&gt;
&lt;p&gt;·       A、缺乏明确的分支管理策略，分支生命周期混乱。&lt;/p&gt;
&lt;p&gt;·       B、采取长周期和大批量的方式进行代码提交，代码合并过程存在大量冲突和错误。&lt;/p&gt;
&lt;p&gt;·       C、采取短分支频繁提交的方式，研究人员至少每天完成一次代码提交，代码合并过程顺畅。&lt;/p&gt;
&lt;p&gt;·       D、分支策略满足持续交付需求，可灵活适应产品交付。&lt;/p&gt;
&lt;p&gt;·       E、持续优化的分支管理策略，可支持团队高效协作。&lt;/p&gt;
&lt;p&gt;3、构建产物管理&lt;/p&gt;
&lt;p&gt;·       A、未使用统一的制品库，构建产物通过直接拷贝或本地共享等方式进行分发。&lt;/p&gt;
&lt;p&gt;·       B、使用统一的制品库管理构建产物，有清晰的分级和目录结构及权限管控并通过单一制品库地址进行分发。&lt;/p&gt;
&lt;p&gt;·       C、使用统一的制品库管理构建产物，并将二进制库文件和三方依赖软件工具等纳入只凭库管理。&lt;/p&gt;
&lt;p&gt;·       D、对制品库完成分级管理，有成熟的备份恢复清理策略，如采用分布式制品库。&lt;/p&gt;
&lt;p&gt;4、单一可信数据源&lt;/p&gt;
&lt;p&gt;·       A、版本控制系统和制品库作为单一可信数据源，覆盖生产部署环节。&lt;/p&gt;
&lt;p&gt;·       B、单一可信数据源进一步覆盖研发本地环境。&lt;/p&gt;
&lt;p&gt;·       C、单一可信数据源贯穿整个研发价值流交付过程，在组织内部开放共享，建立知识积累和经验复用体系。&lt;/p&gt;
&lt;p&gt;5、变更过程&lt;/p&gt;
&lt;p&gt;·       A、变更过程不受控且变更信变更问题定位困难且回滚操作具有高风险分散在每个系统内部，缺乏信息的有效共享机制。&lt;/p&gt;
&lt;p&gt;·       B、代码变更过程应附带变更管理信息。&lt;/p&gt;
&lt;p&gt;·       C、所有配置项变更由变更管理系统触发，并作为版本控制系统的强制要求。&lt;/p&gt;
&lt;p&gt;·       D、使用同一套变更管理系统覆盖从需求到部署发布全流程。&lt;/p&gt;
&lt;p&gt;·       E、可视化变更生命周期，支持全程数据分析管理和满足审计要求。&lt;/p&gt;
&lt;p&gt;6、变更追溯&lt;/p&gt;
&lt;p&gt;·       A、变更缺乏基本的可追溯性。&lt;/p&gt;
&lt;p&gt;·       B、有清晰定义的软件版本号规则，实现版本和代码的关联，可追溯版本构建对应的完整源代码信息。&lt;/p&gt;
&lt;p&gt;·       C、实现版本控制系统和变更管理系统的自动化关联，信息双向同步和实时可追溯。&lt;/p&gt;
&lt;p&gt;·       D、变更依赖被识别和标记，实现数据库和环境变更信息的可追溯。&lt;/p&gt;
&lt;p&gt;·       E、实现从需求到部署发布各个环节的相关全部信息的全程可追溯。&lt;/p&gt;
&lt;p&gt;7、变更回滚&lt;/p&gt;
&lt;p&gt;·       A、变更问题定位困难且回滚操作具有高风险。&lt;/p&gt;
&lt;p&gt;·       B、可支持版本间差异对比和代码级别问题定位和回滚。&lt;/p&gt;
&lt;p&gt;·       C、实现变更管理系统和版本控制系统的同步回滚，保证状态的一致性。&lt;/p&gt;
&lt;p&gt;·       D、可根据变更管理系统按需快速导出复用软件代码变更集，如建立从变更管理系统到软件代码变更集的关系数据库。&lt;/p&gt;
&lt;p&gt;·       E、支持任何时间点全部状态的自动化回滚需求。&lt;/p&gt;
&lt;h2 id="_2"&gt;（二）构建与持续集成&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;1、构建方式&lt;/p&gt;
&lt;p&gt;·       A、采用手工方式进行构建，构建过程不可重复。&lt;/p&gt;
&lt;p&gt;·       B、实现脚本自动化，通过手工配置完成构建。&lt;/p&gt;
&lt;p&gt;·       C、定义结构化构建脚本，实现模块级共享复用和统一维护。&lt;/p&gt;
&lt;p&gt;·       D、实现构建服务化，可按需提供接口和用户界面用于可视化构建编排。&lt;/p&gt;
&lt;p&gt;·       E、持续优化的构建服务平台，持续改进服务易用性。&lt;/p&gt;
&lt;p&gt;2、构建环境&lt;/p&gt;
&lt;p&gt;·       A、使用本地设备，构建环境不可靠。&lt;/p&gt;
&lt;p&gt;·       B、有独立的构建服务器，多种任务共享构建环境。&lt;/p&gt;
&lt;p&gt;·       C、构建环境配置实现标准化，有独立的构建集群，单次构建控制在小时级。&lt;/p&gt;
&lt;p&gt;·       D、优化构建速度，实现增量化构建和模块化构建，单次构建控制在分钟级，如可采用分布式构建集群、构建缓存等技术。&lt;/p&gt;
&lt;p&gt;·       E、持续改进构建性能，实现构建资源共享和动态按需分配回收，如搭建基于云服务虚拟化和容器化的分布式构建集群。&lt;/p&gt;
&lt;p&gt;3、构建计划&lt;/p&gt;
&lt;p&gt;·       A、没有明确的版本号规则和构建任务计划。&lt;/p&gt;
&lt;p&gt;·       B、明确定义版本号规则，并根据发布策略细分构建类型，实现每日自动构建。&lt;/p&gt;
&lt;p&gt;·       C、明确定义构建计划和规则，实现代码提交触发构建和定期自动执行构建。&lt;/p&gt;
&lt;p&gt;·       D、分级构建计划，实现按需构建并达到资源和速度的有效平衡。&lt;/p&gt;
&lt;p&gt;·       E、分级构建计划，实现按需构建并达到资源和速度的有效平衡。&lt;/p&gt;
&lt;p&gt;4、构建职责&lt;/p&gt;
&lt;p&gt;·       A、构建工具和环境受限于团队人员能力，频繁手动干预维护。&lt;/p&gt;
&lt;p&gt;·       B、构建工具和环境由专人负责维护，并使用权限隔离。&lt;/p&gt;
&lt;p&gt;·       C、构建工具和环境由专门团队维护，并细分团队人员职责。&lt;/p&gt;
&lt;p&gt;·       D、构建系统服务化提供更多用户使用，构建不再局限于专业团队进行。&lt;/p&gt;
&lt;p&gt;·       E、将构建能力赋予全部团队成员，并按需触发构建实现快速反馈。&lt;/p&gt;
&lt;h2 id="_3"&gt;（三）构建与持续集成&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;1、集成服务&lt;/p&gt;
&lt;p&gt;·       A、没有搭建持续集成服务，团队成员缺乏对持续集成的理解。&lt;/p&gt;
&lt;p&gt;·       B、搭建统一的持续集成服务并对系统进 行日常维护和管理。&lt;/p&gt;
&lt;p&gt;·       C、组建专门的持续集成团队，负责优化持续集成系统和服务。&lt;/p&gt;
&lt;p&gt;·       D、持续集成嵌入每个研发团队日常活动，实现持续集成系统服务化和自助化。&lt;/p&gt;
&lt;p&gt;·       E、持续优化和改进团队持续集成服务，实现组织交付能力提升。&lt;/p&gt;
&lt;p&gt;2、集成频率&lt;/p&gt;
&lt;p&gt;·       A、长期本地开发代码集成频率几周或者几月一次。&lt;/p&gt;
&lt;p&gt;·       B、采用团队定期统一集成的策略，代码集成频率几天或者几周一次。&lt;/p&gt;
&lt;p&gt;·       C、研发人员至少每天向代码主干集成一次。&lt;/p&gt;
&lt;p&gt;·       D、研发人员每天多次向代码主干集成，每次集成代价较低。&lt;/p&gt;
&lt;p&gt;·       E、任何变更(代码，配置，环境)都会触发完整的持续集成流程。&lt;/p&gt;
&lt;p&gt;3、集成方式&lt;/p&gt;
&lt;p&gt;·       A、代码集成作为软件交付流程中的一个独立阶段。&lt;/p&gt;
&lt;p&gt;·       B、在部分分支上进行每天多次的定时构建。&lt;/p&gt;
&lt;p&gt;·       C、每次代码提交触发自动化构建，构建问题通过自动分析精准推送相关人员处理。&lt;/p&gt;
&lt;p&gt;·       D、每次代码提交构建触发自动化测试和静态代码检查，测试问题自动上报变更管理系统，测试结果作为版本质量标准要求，如：采取质量门禁等方式强化主干代码质量。&lt;/p&gt;
&lt;p&gt;·       E、实现持续集成分级和自动化测试分级，满足不同模块和集成阶段的差异化需求。&lt;/p&gt;
&lt;p&gt;4、反馈周期&lt;/p&gt;
&lt;p&gt;·       A、每次集成伴随大量的问题和冲突，集成期间主干分支长期不可用。&lt;/p&gt;
&lt;p&gt;·       B、集成问题反馈和解决需要半天或者更长时间。&lt;/p&gt;
&lt;p&gt;·       C、集成问题反馈和解决可以在几个小时内完成。&lt;/p&gt;
&lt;p&gt;·       D、集成问题反馈和解决控制在 30分钟以内完成。&lt;/p&gt;
&lt;p&gt;·       E、集成问题反馈和解决控制在 10分钟以内完成。&lt;/p&gt;
&lt;h2 id="_4"&gt;（四）测试管理&lt;a class="headerlink" href="#_4" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;1、分层方法&lt;/p&gt;
&lt;p&gt;·       A、只进行用户/业务级的 UI 测试。&lt;/p&gt;
&lt;p&gt;·       B、采用接口/服务级测试对模块/服务进行覆盖全面的接口测试；采用代码级测试对核心模块的函数或类方法进行单元测试；对系统进行基本的性能测试。&lt;/p&gt;
&lt;p&gt;·       C、采用代码级测试对模块的函数或类方法进行覆盖全面的单元测试；系统全面的进行性能、容量、稳定性、可靠性、易用性、兼容性、安全性等非功能性测试。&lt;/p&gt;
&lt;p&gt;·       D、采用测试驱动开发的方式,进行代码级、接口级测试；采用探索性测试方法对需求进行深入挖掘测试&lt;/p&gt;
&lt;p&gt;·       E、采用验收测试驱动开发的方式进行用户/业务级的 UI测试。&lt;/p&gt;
&lt;p&gt;2、分层策略&lt;/p&gt;
&lt;p&gt;·       A、尚未建立测试分层策略，测试不分层。&lt;/p&gt;
&lt;p&gt;·       B、测试开始分层，但对测试分层策略缺乏系统的规划，对用户/业务级测试、接口/服务级、代码级测试分布比例由高到低，各层测试缺乏有效的设计。&lt;/p&gt;
&lt;p&gt;·       C、对测试分层策略进行系统的规划，用户/业务级、接口/服务级、代码级测试分布比例由低到高，充分设计;代码对非功能性测试进行全面系统的设计。&lt;/p&gt;
&lt;p&gt;·       D、测试分层策略的各层测试具有交叉互补性。&lt;/p&gt;
&lt;p&gt;·       E、定期验证测试分层策略，是否完整有效，持续优化策略。&lt;/p&gt;
&lt;p&gt;3、测试时机&lt;/p&gt;
&lt;p&gt;·       A、测试在软件交付过程中在开发完成后才介入。&lt;/p&gt;
&lt;p&gt;·       B、测试在持续交付过程中的介入时间提前到开发的集成阶段，接口/服务级测试在模块的接口开发完成后进行。&lt;/p&gt;
&lt;p&gt;·       C、测试在持续交付过程中的介入时间提前到开发的编码阶段，代码级测试在模块的函数或类方法开发完成后进行。&lt;/p&gt;
&lt;p&gt;·       D、代码级测试在模块的函数或类方法开发过程中同步进行和完成；接口/服务级测试在模块的接口开发过程中同步进行和完成。&lt;/p&gt;
&lt;p&gt;·       E、在需求阶段进行用户/业务级测定期验证测试设计，在需求特性并发、交付，整个过程中同步进行并完成测试。&lt;/p&gt;
&lt;p&gt;4、质量规约&lt;/p&gt;
&lt;p&gt;·       A、代码质量检查无任何规约。&lt;/p&gt;
&lt;p&gt;·       B、代码质量检查具备基本规约，但还缺乏完整性和有效性。&lt;/p&gt;
&lt;p&gt;·       C、代码质量检查具备完整、有效和强制执行的规约。&lt;/p&gt;
&lt;p&gt;·       D、代码质量检查规约根据需要可进行扩展和定制。&lt;/p&gt;
&lt;p&gt;·       E、定期验证代码质量规约的完整性和有效性，持续优化。&lt;/p&gt;
&lt;p&gt;5、检查策略&lt;/p&gt;
&lt;p&gt;·       A、代码质量检查无针对检查范围、质量门限等相关的策略。&lt;/p&gt;
&lt;p&gt;·       B、代码质量检查有针对检查范围、质量门限的策略，对代码规范、错误和圈复杂度、重复度等质量指标进。行检查分析&lt;/p&gt;
&lt;p&gt;·       C、代码质量检查将安全漏洞检查、合规检查纳入到检查范围。&lt;/p&gt;
&lt;p&gt;·       D、代码质量检查针对检查范围、质量门限的策略可根据需要灵活调整。&lt;/p&gt;
&lt;p&gt;·       E、定期验证代码质量策略的完整性和有效性，持续优化。&lt;/p&gt;
&lt;p&gt;6、检查方式&lt;/p&gt;
&lt;p&gt;·       A、代码质量检查采用人工方式进行评审。&lt;/p&gt;
&lt;p&gt;·       B、代码质量检查采用自动化结合手工方式进行。&lt;/p&gt;
&lt;p&gt;·       C、代码质量检查完全自动化，不需要手工干预。&lt;/p&gt;
&lt;p&gt;·       D、对代码质量检查发现的部分问题自动提出修改建议，支持可视化。&lt;/p&gt;
&lt;p&gt;·       E、具备企业级的代码质量管理平台，以服务的形式提供对代码质量的检查分析。&lt;/p&gt;
&lt;p&gt;7、反馈处理&lt;/p&gt;
&lt;p&gt;·       A、对代码质量检查结果处理不及时，遗留大量技术债。&lt;/p&gt;
&lt;p&gt;·       B、对代码质量检查结果给出反馈，根据反馈进行处理，对遗留的部分技术债乏跟踪和管理，导致遗漏。&lt;/p&gt;
&lt;p&gt;·       C、根据代码质量检查结果反馈及时处理，技术债仍有短期遗留，但进行有效的跟踪、管理和处理。&lt;/p&gt;
&lt;p&gt;·       D、将检查结果强制作为版本质量标准要求，根据代码质量检查提出的修改建议，对问题及时处理，在研发阶段主动解决技术债。&lt;/p&gt;
&lt;p&gt;·       E、对代码质量数据进行统一管理，可有效追溯并对代码质量进行有效度量。&lt;/p&gt;
&lt;p&gt;8、自动化设计&lt;/p&gt;
&lt;p&gt;·       A、未采用自动化方式测试，纯手工测试。&lt;/p&gt;
&lt;p&gt;·       B、尚未对测试用例中自动化部分进行规划和设计，覆盖不完整。&lt;/p&gt;
&lt;p&gt;·       C、根据需求、接口和代码对不同测试分层中自动化测试用例进行规划和设计，自动化覆盖比较完整。&lt;/p&gt;
&lt;p&gt;·       D、对性能、稳定性、可靠性、安全性等非功能性测试中自动化用例进行规划和设计，自动化覆盖完整。&lt;/p&gt;
&lt;p&gt;·       E、对故障和测试进行复盘，对遗漏的测试用例进行补充，不断优化和完善，持续提升覆盖率。&lt;/p&gt;
&lt;p&gt;9、自动化开发&lt;/p&gt;
&lt;p&gt;·       A、尚未对自动化测试脚本进行开发和管理，手工测试。&lt;/p&gt;
&lt;p&gt;·       B、对自动化测试脚本进行开发和本地管理。&lt;/p&gt;
&lt;p&gt;·       C、自动化测试脚本开发采用数据驱动、关键字驱动等方法；使用版本控制系统对自动化测试脚本进行有效管理。&lt;/p&gt;
&lt;p&gt;·       D、自动化测试用例脚本间具备独立性和大批量执行的健壮性。&lt;/p&gt;
&lt;p&gt;·       E、自动化脚本是测试用例设计的活文档，自动化脚本开发和测试用例设计完全统一。&lt;/p&gt;
&lt;p&gt;10、自动化执行&lt;/p&gt;
&lt;p&gt;·       A、手工测试执行效率低下，以周级为单位。&lt;/p&gt;
&lt;p&gt;·       B、对用户/业务级测试采用自动化测试，自动化测试的执行效率不高，以天级为单位。&lt;/p&gt;
&lt;p&gt;·       C、从代码级、接口级UI级测试实现了端到端的自动化测试打通；自动化测试执行效率较高，代码级测试分钟级，UI级测试小时级。&lt;/p&gt;
&lt;p&gt;·       D、有组织级的统一自动化测试平台，和上下游需求、故障系统打通；可以根据需求针对性自动关联选择自动化测试用例脚本执行；可以将由于版和故障关联。&lt;/p&gt;
&lt;p&gt;·       E、采用企业级统一的自动化测试平台，以云化的方式提供测试服务，进行分布式测试调度执行，提高测试执行效率和资源利用率；定期验证自动化执行策略,持续优化。&lt;/p&gt;
&lt;p&gt;11、自动化分析&lt;/p&gt;
&lt;p&gt;·       A、手工对测试结果进行分析判断，错误高，可信度低。&lt;/p&gt;
&lt;p&gt;·       B、对自动化测试结果具备一定的自动判断能力，存在一定的误报，可信度不足。&lt;/p&gt;
&lt;p&gt;·       C、对自动化测试结果具备较强的自动判断能力，误报少，可信度高。&lt;/p&gt;
&lt;p&gt;·       D、自动化测试数据模型标准化，和上下游需求、故障等研发数据关联，可以对自动化测试效果进行度量分析。例如：需求测试覆盖率、测试通过率和测试效率等。&lt;/p&gt;
&lt;p&gt;·       E、对自动化测试结果可以智能分析，自动分析失败用例的失败类型及原因，可以自动向故障管理系统提交故障，可信度高。&lt;/p&gt;
&lt;h2 id="_5"&gt;（五）部署与发布管理&lt;a class="headerlink" href="#_5" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;1、部署方式&lt;/p&gt;
&lt;p&gt;·       A、运维人员手工完成所有环境的部署。&lt;/p&gt;
&lt;p&gt;·       B、运维人员通过自动化脚本实现部署过程部分自动化。&lt;/p&gt;
&lt;p&gt;·       C、部署和发布实现全自动化，同时支持数据库自动化部署。&lt;/p&gt;
&lt;p&gt;·       D、部署发布服务化，实现交付团队自助一键式多环境自动化。&lt;/p&gt;
&lt;p&gt;·       E、持续优化的部署发布模式和工具系统平台。&lt;/p&gt;
&lt;p&gt;2、部署活动&lt;/p&gt;
&lt;p&gt;·       A、部署过程复杂不可控，伴随大量问题和较长的停机时间。&lt;/p&gt;
&lt;p&gt;·       B、部署过程通过流程文档定义实现标准化整体可控。&lt;/p&gt;
&lt;p&gt;·       C、使用相同的过程和工具完成所有环境部署，一次部署过程中使用相同的构建产物。&lt;/p&gt;
&lt;p&gt;·       D、部署过程可灵活响应业务需求变化通过合理组合高效编排。&lt;/p&gt;
&lt;p&gt;·       E、持续部署，每次变更都触发一次自动化生产环境部署过程。&lt;/p&gt;
&lt;p&gt;3、部署策略&lt;/p&gt;
&lt;p&gt;·       A、采用定期大批量部署策略。&lt;/p&gt;
&lt;p&gt;·       B、应用作为部署的最小单位，应用和数据库部署实现分离，实现测试环境的自动化部署。&lt;/p&gt;
&lt;p&gt;·       C、可运行的环境作为部署的最小单位，应用和配置进行分离。&lt;/p&gt;
&lt;p&gt;·       D、通过多种部署发布策略保证流程风险可控，如：蓝绿部署，金丝雀发布。&lt;/p&gt;
&lt;p&gt;·       E、软件交付团队自主进行安全可靠的部署和发布活动。&lt;/p&gt;
&lt;p&gt;4、部署质量&lt;/p&gt;
&lt;p&gt;·       A、部署整体失败率较高，并且无法实现回滚，生产问题只能在线上修复，修复时间不可控。&lt;/p&gt;
&lt;p&gt;·       B、实现应用部署的回滚操作，部署失败率中等，问题可及时修复。&lt;/p&gt;
&lt;p&gt;·       C、部署活动集成自动化测试功能，并以测试结果为部署前置条件每次部署活动提供变更对象范围报告和测试报告。&lt;/p&gt;
&lt;p&gt;·       D、建立监控体系跟踪和分析部署过程，出现问题自动化降级回滚，失败率较低。&lt;/p&gt;
&lt;p&gt;·       E、持续优化的部署监控体系和测试体系，部署失败率维持在极低水平。&lt;/p&gt;
&lt;p&gt;5、协作模式&lt;/p&gt;
&lt;p&gt;·       A、整个软件交付过程严格遵循预先计划，存在复杂的部门间协作和等待，只有在开发完成后才进行测试和部署。&lt;/p&gt;
&lt;p&gt;·       B、通过定义完整的软件交付过程和清晰的交付规范，保证团队之间交付的有序。&lt;/p&gt;
&lt;p&gt;·       C、团队间交付按照约定由系统间调用完成，仅在必要环节进行手工确认。&lt;/p&gt;
&lt;p&gt;·       D、团队间依赖解耦，可实现独立安全的自主部署交付。&lt;/p&gt;
&lt;p&gt;·       E、持续优化的交付业务组织灵活响应业务变化改善发布效率。&lt;/p&gt;
&lt;p&gt;6、流水线过程&lt;/p&gt;
&lt;p&gt;·       A、软件交付过程中的大部分工作通过手工方式完成。&lt;/p&gt;
&lt;p&gt;·       B、软件交付过程中的各个环节建立自动化能力以提升处理效率。&lt;/p&gt;
&lt;p&gt;·       C、打通软件交付过程中的各个环节，建立全流程的自动化能力，并根据自动化测试结果控制软件交付质量。&lt;/p&gt;
&lt;p&gt;·       D、建立可视化部署流水线，覆盖整个软件交付过程，每次变更都会触发完整的自动化部署流水线。&lt;/p&gt;
&lt;p&gt;·       E、持续部署流水线驱动持续改进。&lt;/p&gt;
&lt;p&gt;7、过程可视化&lt;/p&gt;
&lt;p&gt;·       A、交付过程中的信息是封闭的，交付状态不可追溯。&lt;/p&gt;
&lt;p&gt;·       B、交付过程在团队内部可见，信息在团队间共享，交付状态可追溯。&lt;/p&gt;
&lt;p&gt;·       C、交付过程组织内部可见，团队共享度量指标。&lt;/p&gt;
&lt;p&gt;·       D、部署流水线全员可见，对过程信息进行有效聚合分析展示趋势。&lt;/p&gt;
&lt;p&gt;·       E、部署流水线过程信息进行数据价值挖掘，推动业务改进。&lt;/p&gt;
&lt;h2 id="_6"&gt;（六）环境管理&lt;a class="headerlink" href="#_6" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;1、环境类型&lt;/p&gt;
&lt;p&gt;·       A、环境类型只有生产环境和非生产环境的划分。&lt;/p&gt;
&lt;p&gt;·       B、IT交付过程意识到部分测试环境的重要性，开始提供功能测试环境。&lt;/p&gt;
&lt;p&gt;·       C、持续交付过程意识到研发环境的重要性，开始提供面向各类开发者独立的研发 工作区。&lt;/p&gt;
&lt;p&gt;·       D、全面的测试与灰度环境对于质量交付过程来说非常重要，有各类的环境类型划分，区分了开发者，技术测试及业务测试环境以及灰度发布环境等等。&lt;/p&gt;
&lt;p&gt;·       E、根据业务与应用的需要，弹性分配各类环境。&lt;/p&gt;
&lt;p&gt;2、环境架构&lt;/p&gt;
&lt;p&gt;·       A、环境的构建通过人工创建完成。&lt;/p&gt;
&lt;p&gt;·       B、环境构建通过一键化的脚本或者虚拟机来完成的，构建过程完全黑盒 化完成。&lt;/p&gt;
&lt;p&gt;·       C、环境的构建通过资源交付平台来完成，并且底层是由云来交付。&lt;/p&gt;
&lt;p&gt;·       D、环境的构建可以通过 Docker 容器化快速交付，低成本构建一个新的环境。&lt;/p&gt;
&lt;p&gt;·       E、环境的构建结合底层IT资源状况，采用了各类混合IT技术，根据业务及应用架构弹性构建。&lt;/p&gt;
&lt;p&gt;3、环境依赖与配置管理&lt;/p&gt;
&lt;p&gt;·       A、无依赖管理，环境的管理就是一个OS的交付。&lt;/p&gt;
&lt;p&gt;·       B、以应用为中心有OS级别的依赖和配置管理能力，比如说操作系统版本、组件版本、程序包版本等等。&lt;/p&gt;
&lt;p&gt;·       C、以应用为中心，有服务级依赖的配置管理能力，比如说依赖的关联服务，Mysql 服务、cache 服务、关联应用服务等等。&lt;/p&gt;
&lt;p&gt;·       D、环境和依赖配置管理可以资源化描述，类似dockerfile，大大提升其配置管理能力。&lt;/p&gt;
&lt;p&gt;·       E、环境依赖和配置可以做到实例级的动态配置管理能力，根据业务和应用架构的变化而变化。&lt;/p&gt;
&lt;h2 id="_7"&gt;（七）数据管理&lt;a class="headerlink" href="#_7" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;1、数据来源&lt;/p&gt;
&lt;p&gt;·       A、每次测试时手工创建数据，测试数据都是临时性的。&lt;/p&gt;
&lt;p&gt;·       B、从生产环境导出一个子集并进行清洗后，形成基准的测试数据集，满足部分测试用例执行要求。&lt;/p&gt;
&lt;p&gt;·       C、从生产环境导出一个子集并进行清洗后，形成基准的测试数据集，满足部分测试用例执行要求。&lt;/p&gt;
&lt;p&gt;·       D、每个测试用例专属的测试数据都可以通过模拟或调用应用程序 API 的方式自动生成。&lt;/p&gt;
&lt;p&gt;·       E、所有的功能、非功能测试的测试数据，都可以通过模拟、数据库转储或调用应用程序 API 的方式自动生成。&lt;/p&gt;
&lt;p&gt;2、数据覆盖&lt;/p&gt;
&lt;p&gt;·       A、测试数据覆盖率低，仅支持部分测试场景，无法有效支持测试工作。&lt;/p&gt;
&lt;p&gt;·       B、测试数据覆盖主要场景，包括正常类型，错误类型以及边界类型，并进行初步的分类分级，满足不同测。试类型需要。&lt;/p&gt;
&lt;p&gt;·       C、建立体系化测试数据，进行数据依赖管理，覆盖更加复杂的业务场景。&lt;/p&gt;
&lt;p&gt;·       D、测试数据覆盖安全漏洞和开源合规等需求场景并建立定期更新机制。&lt;/p&gt;
&lt;p&gt;·       E、持续优化的持续数据管理方式和策略。&lt;/p&gt;
&lt;p&gt;3、数据独立性&lt;/p&gt;
&lt;p&gt;·       A、测试数据没有版本控制和备份恢复机制。&lt;/p&gt;
&lt;p&gt;·       B、测试数据有明确备份恢复机制，实现测试数据复用和保证测试一致性。&lt;/p&gt;
&lt;p&gt;·       C、每个测试用例拥有专属的测试数据，有明确的测试初始状态测试用例的执行不依赖其他测试用例执行所。产生的数据。&lt;/p&gt;
&lt;p&gt;·       D、通过测试数据分级，实现专属测试数据和通用测试数据的有效管理和灵活组合，保证测试数据的独立性。&lt;/p&gt;
&lt;p&gt;·       E、通过测试数据分级，实现专属测试数据和通用测试数据的有效管理和灵活组合，保证测试数据的独立性。&lt;/p&gt;
&lt;p&gt;4、数据安全&lt;/p&gt;
&lt;p&gt;·       A、测试数据来源复杂，混入核心生产数据，带来信息安全风险&lt;/p&gt;
&lt;p&gt;·       B、测试数据经过清洗，不包含敏感信息，有效避免信息安全风险。&lt;/p&gt;
&lt;p&gt;·       C、测试数据经过清洗，不包含敏感信息，有效避免信息安全风险。&lt;/p&gt;
&lt;p&gt;·       D、测试数据经过清洗，不包含敏感信息，有效避免信息安全风险。&lt;/p&gt;
&lt;p&gt;·       E、测试数据经过清洗，不包含敏感信息，有效避免信息安全风险。&lt;/p&gt;
&lt;p&gt;5、变更过程&lt;/p&gt;
&lt;p&gt;·       A、数据变更由专业人员在后台手工完成 数据变更作为软件发布的一个独立环节，单独实施和交付&lt;/p&gt;
&lt;p&gt;·       B、数据变更通过文档实现标准化，使用自动化脚本完成变更。&lt;/p&gt;
&lt;p&gt;·       C、数据变更作为持续部署流水线的一个环节，随应用的部署自动化完成，无需专业人员单独执行。&lt;/p&gt;
&lt;p&gt;·       D、应用程序部署和数据库迁移解耦，可单独执行。&lt;/p&gt;
&lt;p&gt;·       E、持续优化的数据管理方法，持续改进数据管理效率。&lt;/p&gt;
&lt;p&gt;6、兼容回滚&lt;/p&gt;
&lt;p&gt;·       A、没有识别数据库和应用版本，存在不兼容风险。&lt;/p&gt;
&lt;p&gt;·       B、建立数据库和应用的版本对应关系，并跟踪变更有效性。&lt;/p&gt;
&lt;p&gt;·       C、每次数据变更同时提供明确的恢复回滚机制，并进行变更测试，如：提供升级和回滚两个自动化脚本。&lt;/p&gt;
&lt;p&gt;·       D、数据变更具备向下兼容性，支持保留数据的回滚操作和零停机部署。&lt;/p&gt;
&lt;p&gt;7、版本控制&lt;/p&gt;
&lt;p&gt;·       A、数据变更没有纳入版本控制，变更过程不可重复。&lt;/p&gt;
&lt;p&gt;·       B、数据变更脚本纳入版本控制，并与数据库版本进行关联。&lt;/p&gt;
&lt;p&gt;8、数据监控&lt;/p&gt;
&lt;p&gt;·       A、没有建立变更监控体系，变更结果不可见。&lt;/p&gt;
&lt;p&gt;·       B、对变更日志进行收集分析，帮助问题快速定位。&lt;/p&gt;
&lt;p&gt;·       C、对数据变更进行流程分级定义，应对不同环境下的高危操作。&lt;/p&gt;
&lt;p&gt;·       D、对数据变更进行监控，自动发现异常变更状态。&lt;/p&gt;
&lt;p&gt;·       E、监控数据库性能并持续优化。&lt;/p&gt;
&lt;h2 id="_8"&gt;（八）度量与反馈&lt;a class="headerlink" href="#_8" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;1、度量指标定义&lt;/p&gt;
&lt;p&gt;·       A、度量指标没有明确定义，对度量价值的理解是模糊的。&lt;/p&gt;
&lt;p&gt;·       B、在持续交付各个阶段定义度量指标，度量指标局限于职能部门内部。&lt;/p&gt;
&lt;p&gt;·       C、建立跨组织度量指标，进行跨领域综合维度的度量。&lt;/p&gt;
&lt;p&gt;·       D、整个研发团队共享业务价值导向的度量指标，实现指标的抽象分级，关注核心业务指标。&lt;/p&gt;
&lt;p&gt;·       E、持续优化的度量指标，团队自我驱动持续改进。&lt;/p&gt;
&lt;p&gt;2、度量指标类型&lt;/p&gt;
&lt;p&gt;·       A、度量指标以结果指标为主，如变更频率，需求交付前置时间，变更失败率和平均修复时间。&lt;/p&gt;
&lt;p&gt;·       B、度量指标覆盖过程指标，客观反映组织研发现状。&lt;/p&gt;
&lt;p&gt;·       C、度量指标覆盖探索性指标，关注展示趋势和识别潜在改进。&lt;/p&gt;
&lt;p&gt;·       D、支持改进目标和试验结果的有效反馈，用于经验积累和指导下一阶段的改进工作。&lt;/p&gt;
&lt;p&gt;3、度量数据管理&lt;/p&gt;
&lt;p&gt;·       A、度量数据是临时性的，没有收集管理。&lt;/p&gt;
&lt;p&gt;·       B、度量数据的收集是离散的不连续的，历史度量数据没有进行有效理。&lt;/p&gt;
&lt;p&gt;·       C、度量数据的收集是连续的，历史度量数据有明确的管理规则。&lt;/p&gt;
&lt;p&gt;·       D、度量数据的收集是连续且优化的，对历史数据数据进行有效的挖掘分析。&lt;/p&gt;
&lt;p&gt;·       E、度量数据的收集是连续且优化的，对历史数据数据进行有效的挖掘分析。&lt;/p&gt;
&lt;p&gt;4、度量指标更新&lt;/p&gt;
&lt;p&gt;·       A、度量指标的设立和更新是固化的，度量指标没有明确的优先级。&lt;/p&gt;
&lt;p&gt;·       B、度量指标的设立和更新是动态的，可以按照组织需求定期变更，度量指标的优先级在团队内部可以达。&lt;/p&gt;
&lt;p&gt;·       C、建立完整的度量体系和成熟的度量框架，度量指标的设立和更新可按需实现快速定义并纳入度量体系，推动流程的持续改进。&lt;/p&gt;
&lt;p&gt;·       D、度量指标可基于大数据分析和人工智能自动识别推荐，并且动态调整指标优先级。&lt;/p&gt;
&lt;p&gt;5、报告生成方式&lt;/p&gt;
&lt;p&gt;·       A、度量报告通过手工方式生成，没有标准化的格式定义，内容缺乏细节。&lt;/p&gt;
&lt;p&gt;·       B、度量报告以自动化方式生成，通过预定义格式和内容标准化度量报告。&lt;/p&gt;
&lt;p&gt;·       C、度量报告进行分类分级，建立多种度量反馈渠道，内容按需生成。&lt;/p&gt;
&lt;p&gt;·       D、建立跨组织级统一的数据度量平台，数据看板内容可定制。&lt;/p&gt;
&lt;p&gt;·       E、持续优化的度量方法，平台和展现形式。&lt;/p&gt;
&lt;p&gt;6、报告有效性&lt;/p&gt;
&lt;p&gt;·       A、数据时效性无法保证节。&lt;/p&gt;
&lt;p&gt;·       B、数据体现报告生成时间点的最新状态。&lt;/p&gt;
&lt;p&gt;·       C、通过可视化看板实时展示数据。&lt;/p&gt;
&lt;p&gt;·       D、通过可视化看板聚合报告内容，自动生成趋势图，进行趋势分析。&lt;/p&gt;
&lt;p&gt;·       E、通过可视化看板聚合报告内容，自动生成趋势图，进行趋势分析。&lt;/p&gt;
&lt;p&gt;7、报告覆盖范围&lt;/p&gt;
&lt;p&gt;·       A、受众局限于报告生成人员及相关的小范围内部。&lt;/p&gt;
&lt;p&gt;·       B、由预先定义的事件触发自动化报告发送，受众覆盖团队内部成员。&lt;/p&gt;
&lt;p&gt;·       C、实现报告精准范围推送，支持主动订阅，受众覆盖跨部门团队。&lt;/p&gt;
&lt;p&gt;·       D、多维度产品状态实时信息展示。&lt;/p&gt;
&lt;p&gt;·       E、多维度产品状态实时信息展示。&lt;/p&gt;
&lt;p&gt;8、反馈改进&lt;/p&gt;
&lt;p&gt;·       A、报告发现的问题没有进行有效跟踪落实，问题长期无法改进。&lt;/p&gt;
&lt;p&gt;·       B、测试报告中反馈的问题录入问题追踪系统，进行持续跟踪。&lt;/p&gt;
&lt;p&gt;·       C、度量反馈问题纳入研发迭代的待办事项，作为持续改进的一部分。&lt;/p&gt;
&lt;p&gt;·       D、度量反馈的持续改进纳入研发日常工作，预留时间处理非功能性需求和技术债务，并且识别有效改进并扩展到整个组织，作为企业级知识体系积累保留。&lt;/p&gt;
&lt;p&gt;·       E、通过数据挖掘实现跨组织跨流程数据度量分析，分析结果作为业务决策的重要依据，帮助组织持续改进价值交付流程。&lt;/p&gt;
&lt;h2 id="_9"&gt;（九）分布式应用架构&lt;a class="headerlink" href="#_9" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;1、分布式应用数量&lt;/p&gt;
&lt;p&gt;·       A、20个以上&lt;/p&gt;
&lt;p&gt;·       B、10~20个&lt;/p&gt;
&lt;p&gt;·       C、5~10个&lt;/p&gt;
&lt;p&gt;·       D、5个以下&lt;/p&gt;
&lt;p&gt;2、实施计划&lt;/p&gt;
&lt;p&gt;·       A、大规模迁移&lt;/p&gt;
&lt;p&gt;·       B、保持现状&lt;/p&gt;
&lt;p&gt;·       C、可能回退&lt;/p&gt;
&lt;p&gt;3、技术成熟度&lt;/p&gt;
&lt;p&gt;·       A、稳定运行&lt;/p&gt;
&lt;p&gt;·       B、基本成熟&lt;/p&gt;
&lt;p&gt;·       C、前期探索&lt;/p&gt;
&lt;p&gt;·       D、研究阶段&lt;/p&gt;
&lt;p&gt;4、云技术&lt;/p&gt;
&lt;p&gt;·       A、虚拟化&lt;/p&gt;
&lt;p&gt;·       B、容器(K8S、MESOS等)&lt;/p&gt;
&lt;p&gt;·       C、物理机&lt;/p&gt;
&lt;p&gt;·       D、外部部署&lt;/p&gt;
&lt;p&gt;5、管理工具&lt;/p&gt;
&lt;p&gt;·       A、openstack系列&lt;/p&gt;
&lt;p&gt;·       B、openshift系列&lt;/p&gt;
&lt;p&gt;·       C、其他&lt;/p&gt;
&lt;p&gt;5、数据库&lt;/p&gt;
&lt;p&gt;·       A、UNIX数据库&lt;/p&gt;
&lt;p&gt;·       B、Linux商业数据库&lt;/p&gt;
&lt;p&gt;·       C、开源分布式数据库&lt;/p&gt;
&lt;p&gt;·       D、开源单数据库&lt;/p&gt;
&lt;p&gt;6、微服务框架&lt;/p&gt;
&lt;p&gt;·       A、dobbo/dobbox&lt;/p&gt;
&lt;p&gt;·       B、spring cloud&lt;/p&gt;
&lt;p&gt;·       C、都用&lt;/p&gt;
&lt;p&gt;·       D、其他&lt;/p&gt;
&lt;p&gt;7、开发&lt;/p&gt;
&lt;p&gt;·       A、完全敏捷&lt;/p&gt;
&lt;p&gt;·       B、部分敏捷&lt;/p&gt;
&lt;p&gt;·       C、传统方法&lt;/p&gt;
&lt;p&gt;8、自动化测试&lt;/p&gt;
&lt;p&gt;·       A、完整单元测试&lt;/p&gt;
&lt;p&gt;·       B、部分单元测试&lt;/p&gt;
&lt;p&gt;·       C、无单元测试&lt;/p&gt;
&lt;p&gt;9、部署策略&lt;/p&gt;
&lt;p&gt;·       A、灰度部署&lt;/p&gt;
&lt;p&gt;·       B、蓝绿部署&lt;/p&gt;
&lt;p&gt;·       C、AB部署&lt;/p&gt;
&lt;p&gt;·       D、直接替换&lt;/p&gt;
&lt;p&gt;10、部署工具&lt;/p&gt;
&lt;p&gt;·       A、SSH&lt;/p&gt;
&lt;p&gt;·       B、SALT&lt;/p&gt;
&lt;p&gt;·       C、容器编排工具&lt;/p&gt;
&lt;p&gt;·       D、其他&lt;/p&gt;
&lt;p&gt;11、回滚策略&lt;/p&gt;
&lt;p&gt;·       A、自动回滚&lt;/p&gt;
&lt;p&gt;·       B、手工回滚&lt;/p&gt;
&lt;p&gt;·       C、无回滚策略&lt;/p&gt;
&lt;p&gt;12、弹性部署&lt;/p&gt;
&lt;p&gt;·       A、自动扩容&lt;/p&gt;
&lt;p&gt;·       B、手工扩容&lt;/p&gt;
&lt;p&gt;·       C、无法扩容&lt;/p&gt;
&lt;p&gt;13、部署对象&lt;/p&gt;
&lt;p&gt;·       A、docker&lt;/p&gt;
&lt;p&gt;·       B、war&lt;/p&gt;
&lt;p&gt;·       C、其他&lt;/p&gt;
&lt;p&gt;14、部署方式&lt;/p&gt;
&lt;p&gt;·       A、虚拟化+docker&lt;/p&gt;
&lt;p&gt;·       B、虚拟化+war&lt;/p&gt;
&lt;p&gt;·       C、容器+docker&lt;/p&gt;
&lt;p&gt;15、部署数量&lt;/p&gt;
&lt;p&gt;·       A、1000+&lt;/p&gt;
&lt;p&gt;·       B、500~1000&lt;/p&gt;
&lt;p&gt;·       C、100~500&lt;/p&gt;
&lt;p&gt;·       D、100以下&lt;/p&gt;
&lt;p&gt;16、更新频率&lt;/p&gt;
&lt;p&gt;·       A、月更新&lt;/p&gt;
&lt;p&gt;·       B、周更新&lt;/p&gt;
&lt;p&gt;·       C、日更新&lt;/p&gt;
&lt;p&gt;·       D、每日多次&lt;/p&gt;
&lt;p&gt;17、更新方式&lt;/p&gt;
&lt;p&gt;·       A、全量更新&lt;/p&gt;
&lt;p&gt;·       B、局部更新&lt;/p&gt;
&lt;p&gt;18、部署工作量&lt;/p&gt;
&lt;p&gt;·       A、比以前复杂&lt;/p&gt;
&lt;p&gt;·       B、较以前简单&lt;/p&gt;
&lt;p&gt;·       C、非常简单&lt;/p&gt;
&lt;p&gt;·       D、几乎自动化&lt;/p&gt;
&lt;p&gt;19、最大障碍&lt;/p&gt;
&lt;p&gt;·       A、分析复杂&lt;/p&gt;
&lt;p&gt;·       B、技术复杂&lt;/p&gt;
&lt;p&gt;·       C、运维复杂&lt;/p&gt;
&lt;p&gt;·       D、成本提高&lt;/p&gt;
&lt;p&gt;·       E、其他&lt;/p&gt;
&lt;p&gt;20、综合效果&lt;/p&gt;
&lt;p&gt;·       A、不明显&lt;/p&gt;
&lt;p&gt;·       B、明显提高&lt;/p&gt;
&lt;p&gt;·       C、效果变差&lt;/p&gt;
&lt;p&gt;·       D、部分提高&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Sat, 30 Mar 2019 19:43:07 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-03-30:/devops-questionnaire.html</guid><category>DevOps</category></item><item><title>使用 Ansible 批量管理 Windows</title><link>https://www.EWhisper.cn/use-ansible-manage-multi-windows.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;安装指南&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_3"&gt;服务器端的要求&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#ansible"&gt;服务器端安装Ansible&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#windows"&gt;Windows 指南&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#windows_1"&gt;设置Windows主机&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#ansiblewindows"&gt;Ansible服务器端配置并管理Windows&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#ping-windows"&gt;ping 远程windows主机&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;创建目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_5"&gt;下发文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_6"&gt;删除文件&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_7"&gt;删除目录&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#cmd"&gt;执行cmd命令&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#windows_2"&gt;重启windows&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_8"&gt;创建用户&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#windows_3"&gt;windows服务管理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;概述&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Ansible是自动化运维工具，基于Python开发，实现了批量系统配置、批量程序部署、批量运行命令等功能。Ansible是基于模块(module)和剧本(playbook)工作。&lt;/p&gt;
&lt;h2 id="_2"&gt;安装指南&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;本次在Ubuntu上安装Ansible 2.7 . 更详细安装方式参见: &lt;a href="https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html"&gt;Ansible 安装指南&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_3"&gt;服务器端的要求&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;目前Ansible可以从安装了Python 2（2.7版）或Python 3（3.5及更高版本）的任何机器上运行。控制计算机&lt;strong&gt;不支持Windows&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这包括Red Hat，Debian，CentOS，macOS，任何BSD等等。&lt;/p&gt;
&lt;h3 id="ansible"&gt;服务器端安装Ansible&lt;a class="headerlink" href="#ansible" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;通过Apt (Ubuntu)安装最新版本&lt;/h4&gt;
&lt;p&gt;这里有&lt;a href="https://launchpad.net/~ansible/+archive/ubuntu/ansible"&gt;一个PPA&lt;/a&gt;版本的Ubuntu源。&lt;/p&gt;
&lt;p&gt;要在您的计算机上配置PPA并安装ansible，请运行以下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get update
sudo apt-get install software-properties-common
sudo apt-add-repository --yes --update ppa:ansible/ansible
sudo apt-get install ansible
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;注意:&lt;/p&gt;
&lt;p&gt;在较旧的Ubuntu发行版中，“software-properties-common”被称为“python-software-properties”。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="windows"&gt;Windows 指南&lt;a class="headerlink" href="#windows" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="windows_1"&gt;设置Windows主机&lt;a class="headerlink" href="#windows_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;主机要求&lt;/h4&gt;
&lt;p&gt;要使Ansible与Windows主机通信并使用Windows模块，Windows主机必须满足以下要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ansible支持的Windows版本通常与Microsoft当前和扩展支持下的版本相匹配。支持的桌面操作系统包括&lt;strong&gt;Windows 7,8.1和10&lt;/strong&gt;，受支持的服务器操作系统包括&lt;strong&gt;Windows Server 2008,2008 R2,2012,2012 R2和2016&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;Ansible需要&lt;strong&gt;PowerShell 3.0&lt;/strong&gt;或更高版本，并且至少要在Windows主机上安装&lt;strong&gt;.NET 4.0&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;应创建并激活&lt;strong&gt;WinRM listener &lt;/strong&gt;。更多细节可以在下面找到。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;注意:&lt;/p&gt;
&lt;p&gt;虽然这些是Ansible连接的基本要求，但是一些Ansible模块还有其他要求，例如较新的OS或PowerShell版本。请参阅模块的文档页面以确定主机是否满足这些要求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;升级PowerShell和.NET框架&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;升级powershell需要&lt;strong&gt;重启服务器&lt;/strong&gt;才能生效。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Ansible需要PowerShell 3.0版和.NET Framework 4.0或更高版本才能在较旧的操作系统（如Server 2008和Windows 7）上运行。基本OS镜像不符合此要求。您可以使用&lt;a href="https://github.com/jborean93/ansible-windows/blob/master/scripts/Upgrade-PowerShell.ps1"&gt;Upgrade-PowerShell.ps1&lt;/a&gt;脚本来更新这些脚本。&lt;/p&gt;
&lt;p&gt;这是如何从PowerShell运行此脚本的示例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$url&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;https://raw.githubusercontent.com/jborean93/ansible-windows/master/scripts/Upgrade-PowerShell.ps1&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;$file&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;$env:temp\Upgrade-PowerShell.ps1&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;$username&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Administrator&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;$password&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Password&amp;quot;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;New-Object&lt;/span&gt; &lt;span class="n"&gt;-TypeName&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Net&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WebClient&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;DownloadFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$url&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$file&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;Set-ExecutionPolicy&lt;/span&gt; &lt;span class="n"&gt;-ExecutionPolicy&lt;/span&gt; &lt;span class="n"&gt;Unrestricted&lt;/span&gt; &lt;span class="n"&gt;-Force&lt;/span&gt;

&lt;span class="c"&gt;# version can be 3.0, 4.0 or 5.1&lt;/span&gt;
&lt;span class="p"&gt;&amp;amp;&lt;/span&gt;&lt;span class="nv"&gt;$file&lt;/span&gt; &lt;span class="n"&gt;-Version&lt;/span&gt; &lt;span class="n"&gt;5&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;1&lt;/span&gt; &lt;span class="n"&gt;-Username&lt;/span&gt; &lt;span class="nv"&gt;$username&lt;/span&gt; &lt;span class="n"&gt;-Password&lt;/span&gt; &lt;span class="nv"&gt;$password&lt;/span&gt; &lt;span class="n"&gt;-Verbose&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;完成后，您将需要删除自动登录并将执行策略设置回默认值&lt;code&gt;Restricted&lt;/code&gt;。您可以使用以下PowerShell命令执行此操作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c"&gt;# this isn&amp;#39;t needed but is a good security practice to complete&lt;/span&gt;
&lt;span class="nb"&gt;Set-ExecutionPolicy&lt;/span&gt; &lt;span class="n"&gt;-ExecutionPolicy&lt;/span&gt; &lt;span class="n"&gt;Restricted&lt;/span&gt; &lt;span class="n"&gt;-Force&lt;/span&gt;

&lt;span class="nv"&gt;$reg_winlogon_path&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;HKLM:\Software\Microsoft\Windows NT\CurrentVersion\Winlogon&amp;quot;&lt;/span&gt;
&lt;span class="nb"&gt;Set-ItemProperty&lt;/span&gt; &lt;span class="n"&gt;-Path&lt;/span&gt; &lt;span class="nv"&gt;$reg_winlogon_path&lt;/span&gt; &lt;span class="n"&gt;-Name&lt;/span&gt; &lt;span class="n"&gt;AutoAdminLogon&lt;/span&gt; &lt;span class="n"&gt;-Value&lt;/span&gt; &lt;span class="n"&gt;0&lt;/span&gt;
&lt;span class="nb"&gt;Remove-ItemProperty&lt;/span&gt; &lt;span class="n"&gt;-Path&lt;/span&gt; &lt;span class="nv"&gt;$reg_winlogon_path&lt;/span&gt; &lt;span class="n"&gt;-Name&lt;/span&gt; &lt;span class="n"&gt;DefaultUserName&lt;/span&gt; &lt;span class="n"&gt;-ErrorAction&lt;/span&gt; &lt;span class="n"&gt;SilentlyContinue&lt;/span&gt;
&lt;span class="nb"&gt;Remove-ItemProperty&lt;/span&gt; &lt;span class="n"&gt;-Path&lt;/span&gt; &lt;span class="nv"&gt;$reg_winlogon_path&lt;/span&gt; &lt;span class="n"&gt;-Name&lt;/span&gt; &lt;span class="n"&gt;DefaultPassword&lt;/span&gt; &lt;span class="n"&gt;-ErrorAction&lt;/span&gt; &lt;span class="n"&gt;SilentlyContinue&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该脚本的工作原理是检查需要安装哪些程序（例如.NET Framework 4.5.2）以及需要什么样的PowerShell版本。如果&lt;strong&gt;需要重新启动&lt;/strong&gt;并且设置了&lt;code&gt;username&lt;/code&gt;和&lt;code&gt;password&lt;/code&gt;参数，则脚本将在重新启动时自动重新启动并登录。该脚本将继续，直到不再需要执行任何操作且PowerShell版本与目标版本匹配为止。如果未设置&lt;code&gt;username&lt;/code&gt;和 &lt;code&gt;password&lt;/code&gt;参数，脚本将提示用户手动重新引导并在需要时登录。当用户下次登录时，脚本将从停止的位置继续，并且该过程将继续，直到不再需要其他操作为止。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;注意:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果在Server 2008上运行，则必须安装SP2。如果在Server 2008 R2或Windows 7上运行，则必须安装SP1。&lt;/li&gt;
&lt;li&gt;Windows Server 2008只能安装PowerShell 3.0; 指定较新的版本将导致脚本失败。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;username&lt;/code&gt;和&lt;code&gt;password&lt;/code&gt;参数都是存储在注册表中的纯文本。确保在脚本完成后运行清理命令，以确保主机上仍未存储凭据。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h4&gt;WinRM内存补丁&lt;/h4&gt;
&lt;p&gt;在PowerShell v3.0上运行时，WinRM服务存在一个错误，它限制了WinRM可用的内存量。如果未安装此补丁，Ansible将无法在Windows主机上执行某些命令。这些补丁应作为系统引导或映像过程的一部分安装。&lt;a href="https://github.com/jborean93/ansible-windows/blob/master/scripts/Install-WMF3Hotfix.ps1"&gt;Install-WMF3Hotfix.ps1&lt;/a&gt;脚本可用于在受影响的主机上安装此修补程序。&lt;/p&gt;
&lt;p&gt;以下PowerShell命令将安装此修补程序：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$url&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;https://raw.githubusercontent.com/jborean93/ansible-windows/master/scripts/Install-WMF3Hotfix.ps1&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;$file&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;$env:temp\Install-WMF3Hotfix.ps1&amp;quot;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;New-Object&lt;/span&gt; &lt;span class="n"&gt;-TypeName&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Net&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WebClient&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;DownloadFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$url&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$file&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;powershell&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exe&lt;/span&gt; &lt;span class="n"&gt;-ExecutionPolicy&lt;/span&gt; &lt;span class="n"&gt;ByPass&lt;/span&gt; &lt;span class="o"&gt;-File&lt;/span&gt; &lt;span class="nv"&gt;$file&lt;/span&gt; &lt;span class="n"&gt;-Verbose&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;WinRM设置&lt;/h4&gt;
&lt;p&gt;一旦Powershell升级到至少3.0版本，最后一步是配置WinRM服务，以便Ansible可以连接到它。WinRM服务有两个主要组件，用于管理Ansible如何与Windows主机连接：&lt;code&gt;listener&lt;/code&gt;和&lt;code&gt;service&lt;/code&gt;配置设置。&lt;/p&gt;
&lt;p&gt;可以在下面阅读有关每个组件的详细信息，也可以使用脚本&lt;a href="https://github.com/ansible/ansible/blob/devel/examples/scripts/ConfigureRemotingForAnsible.ps1"&gt;ConfigureRemotingForAnsible.ps1&lt;/a&gt;来进行基本设置。此脚本使用自签名证书设置HTTP和HTTPS侦听器，并在服务上启用&lt;code&gt;Basic&lt;/code&gt; 身份验证选项。&lt;/p&gt;
&lt;p&gt;要使用此脚本，请在PowerShell中运行以下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;$url&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;https://raw.githubusercontent.com/ansible/ansible/devel/examples/scripts/ConfigureRemotingForAnsible.ps1&amp;quot;&lt;/span&gt;
&lt;span class="nv"&gt;$file&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;$env:temp\ConfigureRemotingForAnsible.ps1&amp;quot;&lt;/span&gt;

&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;New-Object&lt;/span&gt; &lt;span class="n"&gt;-TypeName&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;Net&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;WebClient&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;DownloadFile&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$url&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nv"&gt;$file&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;powershell&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;exe&lt;/span&gt; &lt;span class="n"&gt;-ExecutionPolicy&lt;/span&gt; &lt;span class="n"&gt;ByPass&lt;/span&gt; &lt;span class="o"&gt;-File&lt;/span&gt; &lt;span class="nv"&gt;$file&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;注意:&lt;/p&gt;
&lt;p&gt;ConfigureRemotingForAnsible.ps1脚本仅用于培训和开发目的，不应在生产环境中使用，因为它启用了&lt;code&gt;Basic&lt;/code&gt; 这本质上不安全（如身份验证）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;WinRM Listener&lt;/h4&gt;
&lt;p&gt;WinRM服务侦听一个或多个端口上的请求。每个端口都必须创建并配置一个侦听器。&lt;/p&gt;
&lt;p&gt;要查看在WinRM服务上运行的当前侦听器，请运行以下命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;winrm&lt;/span&gt; &lt;span class="n"&gt;quickconfig&lt;/span&gt;
&lt;span class="n"&gt;winrm&lt;/span&gt; &lt;span class="n"&gt;enumerate&lt;/span&gt; &lt;span class="n"&gt;winrm&lt;/span&gt;&lt;span class="p"&gt;/&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;/&lt;/span&gt;&lt;span class="n"&gt;Listener&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行后输出如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Listener&lt;/span&gt;
    &lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;*&lt;/span&gt;
    &lt;span class="n"&gt;Transport&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HTTP&lt;/span&gt;
    &lt;span class="n"&gt;Port&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;5985&lt;/span&gt;
    &lt;span class="n"&gt;Hostname&lt;/span&gt;
    &lt;span class="n"&gt;Enabled&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;true&lt;/span&gt;
    &lt;span class="n"&gt;URLPrefix&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wsman&lt;/span&gt;
    &lt;span class="n"&gt;CertificateThumbprint&lt;/span&gt;
    &lt;span class="n"&gt;ListeningOn&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;10&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;127&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;192&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;168&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;56&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;155&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fe80&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;5efe&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;10&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;15&lt;/span&gt;&lt;span class="k"&gt;%&lt;/span&gt;&lt;span class="n"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fe80&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;5efe&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;192&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;168&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;56&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;155&lt;/span&gt;&lt;span class="k"&gt;%&lt;/span&gt;&lt;span class="n"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fe80&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;
&lt;span class="n"&gt;ffff&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;ffff&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;fffe&lt;/span&gt;&lt;span class="k"&gt;%&lt;/span&gt;&lt;span class="n"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fe80&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;203d&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;7d97&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;c2ed&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;ec78&lt;/span&gt;&lt;span class="k"&gt;%&lt;/span&gt;&lt;span class="n"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fe80&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;e8ea&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;d765&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;2c69&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;7756&lt;/span&gt;&lt;span class="k"&gt;%&lt;/span&gt;&lt;span class="n"&gt;7&lt;/span&gt;

&lt;span class="n"&gt;Listener&lt;/span&gt;
    &lt;span class="n"&gt;Address&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="p"&gt;*&lt;/span&gt;
    &lt;span class="n"&gt;Transport&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;HTTPS&lt;/span&gt;
    &lt;span class="n"&gt;Port&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;5986&lt;/span&gt;
    &lt;span class="n"&gt;Hostname&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;SERVER2016&lt;/span&gt;
    &lt;span class="n"&gt;Enabled&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;true&lt;/span&gt;
    &lt;span class="n"&gt;URLPrefix&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;wsman&lt;/span&gt;
    &lt;span class="n"&gt;CertificateThumbprint&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;E6CDAA82EEAF2ECE8546E05DB7F3E01AA47D76CE&lt;/span&gt;
    &lt;span class="n"&gt;ListeningOn&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;10&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;15&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;127&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;192&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;168&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;56&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;155&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fe80&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;5efe&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;10&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;0&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;15&lt;/span&gt;&lt;span class="k"&gt;%&lt;/span&gt;&lt;span class="n"&gt;6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fe80&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;5efe&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;192&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;168&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;56&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;155&lt;/span&gt;&lt;span class="k"&gt;%&lt;/span&gt;&lt;span class="n"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fe80&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;
&lt;span class="n"&gt;ffff&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;ffff&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;fffe&lt;/span&gt;&lt;span class="k"&gt;%&lt;/span&gt;&lt;span class="n"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fe80&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;203d&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;7d97&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;c2ed&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;ec78&lt;/span&gt;&lt;span class="k"&gt;%&lt;/span&gt;&lt;span class="n"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fe80&lt;/span&gt;&lt;span class="p"&gt;::&lt;/span&gt;&lt;span class="n"&gt;e8ea&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;d765&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;2c69&lt;/span&gt;&lt;span class="err"&gt;:&lt;/span&gt;&lt;span class="n"&gt;7756&lt;/span&gt;&lt;span class="k"&gt;%&lt;/span&gt;&lt;span class="n"&gt;7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;修改winrm配置，启用远程连接认证&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;winrm&lt;/span&gt; &lt;span class="nb"&gt;set &lt;/span&gt;&lt;span class="n"&gt;winrm&lt;/span&gt;&lt;span class="p"&gt;/&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;/&lt;/span&gt;&lt;span class="n"&gt;service&lt;/span&gt;&lt;span class="p"&gt;/&lt;/span&gt;&lt;span class="n"&gt;auth&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;@{Basic=&amp;quot;true&amp;quot;}&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;winrm&lt;/span&gt; &lt;span class="nb"&gt;set &lt;/span&gt;&lt;span class="n"&gt;winrm&lt;/span&gt;&lt;span class="p"&gt;/&lt;/span&gt;&lt;span class="n"&gt;config&lt;/span&gt;&lt;span class="p"&gt;/&lt;/span&gt;&lt;span class="n"&gt;service&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;@{AllowUnencrypted=&amp;quot;true&amp;quot;}&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;windows 防火墙配置&lt;/h4&gt;
&lt;p&gt;配置防火墙:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;添加防火墙信任规则，允许5985-5986端口通过&lt;/li&gt;
&lt;li&gt;打开防火墙高级配置，选择&lt;strong&gt;入站规则&lt;/strong&gt;，在点击新建规则&lt;/li&gt;
&lt;li&gt;填写一下信息&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;TCP&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;信任端口&lt;strong&gt;5985-5986&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;填写新建规则名称&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="ansiblewindows"&gt;Ansible服务器端配置并管理Windows&lt;a class="headerlink" href="#ansiblewindows" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;添加windows客户端连接信息: 编辑&lt;code&gt;/etc/ansible/hosts&lt;/code&gt;, 添加客户端主机信息(ansible服务端的配置)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;[windows]&lt;/span&gt;

&lt;span class="na"&gt;192.168.2.2 ansible_user&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Administrator&amp;quot; ansible_password=&amp;quot;Password&amp;quot; ansible_port=5986 ansible_connection=&amp;quot;winrm&amp;quot; ansible_winrm_server_cert_validation=ignore ansible_winrm_transport=basic&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="ping-windows"&gt;ping 远程windows主机&lt;a class="headerlink" href="#ping-windows" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ansible &lt;span class="m"&gt;192&lt;/span&gt;.168.2.2 -m win_ping
&lt;span class="m"&gt;192&lt;/span&gt;.168.2.2 &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;SUCCESS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;changed&amp;quot;&lt;/span&gt;: false,
    &lt;span class="s2"&gt;&amp;quot;ping&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;pong&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_4"&gt;创建目录&lt;a class="headerlink" href="#_4" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ansible &lt;span class="m"&gt;192&lt;/span&gt;.168.2.2 -m win_file -a &lt;span class="s1"&gt;&amp;#39;path=D:\\test state=directory&amp;#39;&lt;/span&gt;
&lt;span class="m"&gt;192&lt;/span&gt;.168.2.2 &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;CHANGED&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;changed&amp;quot;&lt;/span&gt;: &lt;span class="nb"&gt;true&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_5"&gt;下发文件&lt;a class="headerlink" href="#_5" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ ansible &lt;span class="m"&gt;192&lt;/span&gt;.168.2.2 -m win_copy -a &lt;span class="s1"&gt;&amp;#39;src=/etc/hosts dest=D:\\hosts.txt&amp;#39;&lt;/span&gt;
&lt;span class="m"&gt;192&lt;/span&gt;.168.2.2 &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="nv"&gt;CHANGED&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;&amp;gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="s2"&gt;&amp;quot;changed&amp;quot;&lt;/span&gt;: true,
    &lt;span class="s2"&gt;&amp;quot;checksum&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;f6d471689e1233342a8e43a130ff40a6ea0b9f51&amp;quot;&lt;/span&gt;,
    &lt;span class="s2"&gt;&amp;quot;dest&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;D:\\hosts.txt&amp;quot;&lt;/span&gt;,
    &lt;span class="s2"&gt;&amp;quot;operation&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;file_copy&amp;quot;&lt;/span&gt;,
    &lt;span class="s2"&gt;&amp;quot;original_basename&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;hosts&amp;quot;&lt;/span&gt;,
    &lt;span class="s2"&gt;&amp;quot;size&amp;quot;&lt;/span&gt;: &lt;span class="m"&gt;635&lt;/span&gt;,
    &lt;span class="s2"&gt;&amp;quot;src&amp;quot;&lt;/span&gt;: &lt;span class="s2"&gt;&amp;quot;/etc/hosts&amp;quot;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_6"&gt;删除文件&lt;a class="headerlink" href="#_6" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# ansible 192.168.2.2 -m win_file -a &amp;#39;dest=d:\\config_dir\\hosts.txt state=absent&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_7"&gt;删除目录&lt;a class="headerlink" href="#_7" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# ansible 192.168.2.2 -m win_file -a &amp;#39;dest=d:\\config_dir2 state=absent&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="cmd"&gt;执行cmd命令&lt;a class="headerlink" href="#cmd" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# ansible 192.168.2.2 -m win_shell -a &amp;#39;ipconfig&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="windows_2"&gt;重启windows&lt;a class="headerlink" href="#windows_2" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# ansible 192.168.2.2 -m win_reboot&lt;/span&gt;
&lt;span class="c1"&gt;# ansible 192.168.2.2 -m win_shell -a &amp;#39;shutdown -r -t 0&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="_8"&gt;创建用户&lt;a class="headerlink" href="#_8" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;远程在windows客户端上创建用户&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# ansible 192.168.2.2 -m win_user -a &amp;quot;name=testuser1 passwd=123456&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="windows_3"&gt;windows服务管理&lt;a class="headerlink" href="#windows_3" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# ansible 192.168.2.2 -m win_shell -a “net stop|start zabbix_agent”&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;img align="absmiddle" alt="📓" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f4d3.png" title=":notebook:" width="20px"&gt;说明:&lt;/p&gt;
&lt;p&gt;完整的windows module见: &lt;a href="https://docs.ansible.com/ansible/latest/modules/list_of_windows_modules.html"&gt;Windows modules&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Sat, 30 Mar 2019 19:37:41 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-03-30:/use-ansible-manage-multi-windows.html</guid><category>ansible</category><category>windows</category><category>devops</category></item></channel></rss>