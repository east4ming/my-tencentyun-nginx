<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>东风微鸣 Blog - 译文</title><link>https://www.EWhisper.cn/</link><description>Focus on Python/Java/DevOps/Observability</description><lastBuildDate>Wed, 19 Jun 2019 20:39:00 +0800</lastBuildDate><item><title>NGINX 实战手册-运维-实用运维Tips和总结</title><link>https://www.EWhisper.cn/nginx-handbook-3-11-operation-best-practices.html</link><description>&lt;h2 id="311-tips"&gt;3.11 实用运维Tips和总结&lt;a class="headerlink" href="#311-tips" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="3110"&gt;3.11.0 介绍&lt;a class="headerlink" href="#3110" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;最后章节会包括使用运维tips和本书的总结. 通过这三个大部分, 我们讨论了与运维工程师有关的很多想法和概念. 然而, 我认为再多讲一点会有助于理解的更加全面. 在本章, 我会确保你的配置文件干净和简洁, 以及如何调试配置文件.&lt;/p&gt;
&lt;h3 id="3111-includes"&gt;3.11.1 使用 Includes 来缩减配置&lt;a class="headerlink" href="#3111-includes" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要清理大量的配置文件来保证你的配置文件以模块化的配置集分组.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;include&lt;/code&gt;指令来引用配置文件, 目录或通配符:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;include&lt;/span&gt; &lt;span class="s"&gt;config.d/compression.conf&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;include&lt;/span&gt; &lt;span class="s"&gt;sites-enabled/*.conf&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="3112"&gt;3.11.2 调试配置&lt;a class="headerlink" href="#3112" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;从NGINX server , 你得到的非预期的结果.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;调试配置, 记住以下建议:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;NGINX进程请求查找最匹配的规则.&lt;/li&gt;
&lt;li&gt;你可以打开调试日志. 对于调试日志, 你需要确保你的NGINX包配置了&lt;code&gt;--with-debug&lt;/code&gt; flag. 大部分常见包都有; 但是如果你构建你自己的包, 或在运行一个最小化的包, 你可能至少需要再次仔细检查. 一旦你确定了你有debug, 你可以设置&lt;code&gt;error_log&lt;/code&gt;指令的日志级别为&lt;code&gt;debug&lt;/code&gt;: &lt;code&gt;error_log /var/log/nginx/error.log debug;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;你可以为特定的连接启用调试. &lt;code&gt;debug_connection&lt;/code&gt;指令在&lt;code&gt;events&lt;/code&gt;上下文是合法的, 使用IP或CIDR range作为参数. 该指令可以声明多次来添加多个要调试的IP地址或CIDR ranges. 这在生产环境, 但是调试所有连接会导致性能下降的情况下, 调试一个问题会很有用&lt;/li&gt;
&lt;li&gt;你可以调试特定的virtual servers. 因为&lt;code&gt;error_log&lt;/code&gt;在&lt;code&gt;main&lt;/code&gt; &lt;code&gt;http&lt;/code&gt; &lt;code&gt;mail&lt;/code&gt; &lt;code&gt;stream&lt;/code&gt; &lt;code&gt;server&lt;/code&gt; 和&lt;code&gt;location&lt;/code&gt;上下文都有效. 你可以在你需要调试的上下文设置&lt;code&gt;debug&lt;/code&gt;日志级别.&lt;/li&gt;
&lt;li&gt;你可以启用core dumps, 来从中获取backtraces. Core dumps可以通过操作系统启用, 或通过NGINX配置文件.&lt;/li&gt;
&lt;li&gt;你可以使用&lt;code&gt;rewrite_log&lt;/code&gt;记录rewrite 声明的日志: &lt;code&gt;rewrite_log on;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;NGINX能做很多神奇的配置, 但是也有性能下降的风险. 调试时, 确保你知道如何通过你的配置来追踪你的请求; 如果有问题, 增加调试日志级别来帮助分析. debug日志时相当详细, 找出NGINX对你的请求做了什么以及你的配置在哪儿出错了很有帮助.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2crNKVM"&gt;NGINX如何处理请求&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2iQYNsZ"&gt;管理员调试向导&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2j96jAH"&gt;Rewrite log&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="3113"&gt;3.11.3 总结&lt;a class="headerlink" href="#3113" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这本书的三个部分集中于高性能负载均衡, 安全, 以及部署和维护NGINX和NGINX Plus servers. 这本书展示了NGINX应用交付平台的一些最强大的功能. NGINX会继续开发神奇的功能, 保持赛道领先.&lt;/p&gt;
&lt;p&gt;这本书展示了很多"简短食谱", 允许你对指令和模块(这些让NGINX成为当今网络之心)有更好的理解. NGINX server不仅仅是web server, 不仅仅时反向代理, 而是一个完整的应用交付平台, 完全有能力通过认证, 并在未来环境中使用.  请知悉.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:39:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-11-operation-best-practices.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-运维-使用`split_clients`进行A-B测试</title><link>https://www.EWhisper.cn/nginx-handbook-3-7-ab-test.html</link><description>&lt;h2 id="37-split_clientsa-b"&gt;3.7 使用&lt;code&gt;split_clients&lt;/code&gt;进行A-B测试&lt;a class="headerlink" href="#37-split_clientsa-b" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="370"&gt;3.7.0 介绍&lt;a class="headerlink" href="#370" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;NGINX有一个叫做&lt;code&gt;split_clients&lt;/code&gt;的模块, 允许你来系统地给予某一个变量key来拆分用户. NGINX通过使用轻量的哈希算法来哈希一个给定的字符串来拆分用户. 然后数学地通过百分比拆分, 映射预定义的值到一个变量, 这个值可以用来改变服务器的响应。&lt;/p&gt;
&lt;h3 id="371-ab"&gt;3.7.1 A/B 测试&lt;a class="headerlink" href="#371-ab" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要拆分两个或更多版本的文件或程序的用户来测试接受度.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;split_clients&lt;/code&gt;模块来直接为你的客户端设置不同的upstream pool:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;split_clients&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;${remote_addr}AAA&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;$variant&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;20.0%&lt;/span&gt;    &lt;span class="s"&gt;&amp;quot;backendv2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;*&lt;/span&gt;        &lt;span class="s"&gt;&amp;quot;backendv1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;split_clients&lt;/code&gt;指令哈希由你提供的字符串作为第一个参数, 并且将散列的百分比提供映射一个变量的值作为第二个参数提供。第三个参数是一个包含key-value对的对象, key是百分比权重, 值是要被分配的值. key可以是一个百分比或一个星号. 星号就是剩下的百分比. 变量&lt;code&gt;$variant&lt;/code&gt;的值将是20%的客户端IP是&lt;code&gt;backendv2&lt;/code&gt;, 剩下的80%是&lt;code&gt;backendv1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;在本例中, &lt;code&gt;backendv1&lt;/code&gt;和&lt;code&gt;backendv2&lt;/code&gt;代表upstream server池, 可以被用于&lt;code&gt;proxy_pass&lt;/code&gt;指令, 如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;proxy_pass&lt;/span&gt; &lt;span class="s"&gt;http://&lt;/span&gt;&lt;span class="nv"&gt;$variant&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用变量&lt;code&gt;$variant&lt;/code&gt;, 我们的流量会被分为2个不同的应用server池.&lt;/p&gt;
&lt;p&gt;另一个案例:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="kn"&gt;split_clients&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;${remote_addr}AAA&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;$variant&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="kn"&gt;0.5%&lt;/span&gt;               &lt;span class="s"&gt;.one&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="kn"&gt;2.0%&lt;/span&gt;               &lt;span class="s"&gt;.two&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                   &lt;span class="kn"&gt;*&lt;/span&gt;                  &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="kn"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
         &lt;span class="kn"&gt;index&lt;/span&gt; &lt;span class="s"&gt;index&lt;/span&gt;&lt;span class="nv"&gt;${variant}.html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;A/B测试的类型很有用, 如测试不同类型的市场和前端功能的电商网站转化率. 对于应用, 使用金丝雀发布很常见. 这种部署中, 流量被缓慢地切换到新的版本. 拆分不同应用版本的客户端是很有用的, 当回滚新版本的代码, 限制因为一个错误导致的爆炸半径. 不论是因为什么原因要拆分两个不同应用集的客户端, NGINX通过使用&lt;code&gt;split_client&lt;/code&gt;模块都能很容易实现.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jsdkw4"&gt;split_client documentation&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:39:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-7-ab-test.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-运维-使用GeoIP模块通过IP地址定位用户</title><link>https://www.EWhisper.cn/nginx-handbook-3-8-use-geoip-to-get-users-location.html</link><description>&lt;h2 id="38-geoipip"&gt;3.8 使用GeoIP模块通过IP地址定位用户&lt;a class="headerlink" href="#38-geoipip" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="380"&gt;3.8.0 介绍&lt;a class="headerlink" href="#380" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;跟踪, 分析, 和利用你的应用或度量的客户端的位置信息可以帮助你加深对客户的理解. 有很多方法获取你的客户的位置信息, NGINX通过使用GeoIP模块和几个指令很容易地定位他们. 该模块让基于客户位置信息记录位置, 控制访问, 或者基于客户位置做决定变得很容易.  它也允许客户的位置信息被内部查找只要请求被传输到upstream应用, 而不需要再进行查找. 该NGINX模块默认不安装, 可以从源码静态编译, 动态导入, 或通过在Ubuntu安装&lt;code&gt;nginx-full&lt;/code&gt;或&lt;code&gt;nginx-extras&lt;/code&gt;来安装. 在RHEL发行版, 如CentOS, 你可以安装&lt;code&gt;nginx-mod-http-geoip&lt;/code&gt;包并通过&lt;code&gt;load_module&lt;/code&gt;动态导入. 本章会覆盖&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;导入GeoIP动态模块,&lt;/li&gt;
&lt;li&gt;安装GeoIP数据库,&lt;/li&gt;
&lt;li&gt;该模块可用的内建变量,&lt;/li&gt;
&lt;li&gt;控制访问,&lt;/li&gt;
&lt;li&gt;和代理一起使用.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="381-geoip"&gt;3.8.1 使用GeoIP模块和数据库&lt;a class="headerlink" href="#381-geoip" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要安装GeoIP数据库, 并启用在NGINX的内建命令, 来记录和告诉你的应用你的客户端的地理位置.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;下载GeoIP国家和城市数据库, 并unzip它们:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# mkdir /etc/nginx/geoip&lt;/span&gt;
&lt;span class="c1"&gt;# cd /etc/nginx/geoip&lt;/span&gt;
&lt;span class="c1"&gt;# wget &amp;quot;http://geolite.maxmind.com/\&lt;/span&gt;
download/geoip/database/GeoLiteCountry/GeoIP.dat.gz&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;# gunzip GeoIP.dat.gz&lt;/span&gt;
&lt;span class="s2"&gt;# wget &amp;quot;&lt;/span&gt;http://geolite.maxmind.com/&lt;span class="se"&gt;\&lt;/span&gt;
download/geoip/database/GeoLiteCity.dat.gz&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;# gunzip GeoLiteCity.dat.gz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这些命令在&lt;em&gt;/etc/nginx&lt;/em&gt;下创建一个&lt;em&gt;geoip&lt;/em&gt;目录, 跳转到新目录, 并下载和解压包.&lt;/p&gt;
&lt;p&gt;通过在本地磁盘上的 国家和城市的GeoIP数据库, 我们可以构建NGINX GeoIP模块并使用它们来暴露出给予客户端IP地址的内建指令:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;load_module&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/usr/lib64/nginx/modules/ngx_http_geoip_module.so&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;geoip_country&lt;/span&gt; &lt;span class="s"&gt;/etc/nginx/geoip/GeoIP.dat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;geoip_city&lt;/span&gt; &lt;span class="s"&gt;/etc/nginx/geoip/GeoLiteCity.dat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;geoip_country&lt;/code&gt;指令指定到&lt;em&gt;GeoIP.dat&lt;/em&gt;文件的路径, &lt;em&gt;GeoIP.dat&lt;/em&gt;包含IP地址到国家代码的映射, 只能在HTTP上下文中使用.&lt;/p&gt;
&lt;h3 id="_1"&gt;讨论&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;模块的&lt;code&gt;geoip_country&lt;/code&gt;和&lt;code&gt;geoip_city&lt;/code&gt;暴露一系列可用变量. &lt;code&gt;geoip_country&lt;/code&gt;指令允许你去本你的客户的国家. 这些变量包括&lt;code&gt;$geoip_country_code&lt;/code&gt;, &lt;code&gt;geoip_country_code3&lt;/code&gt;和&lt;code&gt;geoip_country_name&lt;/code&gt;. 国家代码变量返回一个2位国家字母. &lt;code&gt;geoip_country_code3&lt;/code&gt;返回3位国家字母. 国家名变量返回国家的全名.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;geoip_city&lt;/code&gt;指令也会启用几个变量. 和&lt;code&gt;geoip_country&lt;/code&gt;类似. 有&lt;code&gt;$geoip_city_country_code&lt;/code&gt; &lt;code&gt;geoip_city_country_code3&lt;/code&gt; &lt;code&gt;geoip_city_contry_name&lt;/code&gt;. 其他变量有&lt;code&gt;$geoip_city&lt;/code&gt; &lt;code&gt;$geoip_city_continent_code&lt;/code&gt; &lt;code&gt;$geoip_latitude&lt;/code&gt; &lt;code&gt;$geoip_longitude&lt;/code&gt;和&lt;code&gt;$geoip_postal_code&lt;/code&gt;. &lt;code&gt;$geoip_region&lt;/code&gt; &lt;code&gt;$geoip_region_name&lt;/code&gt;描述区域, 领域, 州, 省, 联邦政府地等. 区域是一个两字符代码, 区域名是全名. &lt;code&gt;geoip_area_code&lt;/code&gt;, 只在美国有效, 返回3位数字电话区域码.&lt;/p&gt;
&lt;p&gt;通过这些变量, 你能够记录你的客户端的信息. 你可以选择传递信息到你的应用作为一个header或变量, 或使用NGINX来以特定方式route流量.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://github.com/maxmind/geoipupdate"&gt;GeoIP 升级&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="382"&gt;3.8.2 基于国家限制访问&lt;a class="headerlink" href="#382" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;根据合约或应用需求, 你需要限制来自特定国家的访问.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;映射你想要屏蔽或允许的国家代码到一个变量&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;load_module&lt;/span&gt;
  &lt;span class="s"&gt;&amp;quot;/usr/lib64/nginx/modules/ngx_http_geoip_module.so&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;map&lt;/span&gt; &lt;span class="nv"&gt;$geoip_country_code&lt;/span&gt; &lt;span class="nv"&gt;$country_access&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;&amp;quot;US&amp;quot;&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;&amp;quot;RU&amp;quot;&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;default&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kn"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个映射会设置新的变量&lt;code&gt;$country_access&lt;/code&gt;为1或0. 如果客户端IP地址来自美国或俄罗斯, 变量会被设置为0, 其他国家会设置为1.&lt;/p&gt;
&lt;p&gt;然后, 在&lt;code&gt;server&lt;/code&gt;快, 使用&lt;code&gt;if&lt;/code&gt;声明来拒绝不是来自美国和俄罗斯的用户访问:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;if&lt;/span&gt; &lt;span class="s"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$country_access&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;1&amp;#39;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;403&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kn"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当条件判断为True时, 会返回403 未认证. 否则正常访问.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;这是一个简短的例子, 来说明如何允许特定国家访问. 这个例子可以被扩展, 以符合你的需要.&lt;/p&gt;
&lt;h3 id="383"&gt;3.8.3 找到源客户端&lt;a class="headerlink" href="#383" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要找到客户源IP, 因为在NGINX server前边有代理.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;geoip_proxy&lt;/code&gt;指令来定义你的代理IP地址范围, &lt;code&gt;geoip_proxy_recursive&lt;/code&gt;指令来查找源IP:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;load_module&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/usr/lib64/nginx/modules/ngx_http_geoip_module.so&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;geoip_country&lt;/span&gt; &lt;span class="s"&gt;/etc/nginx/geoip/GeoIP.dat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;geoip_city&lt;/span&gt; &lt;span class="s"&gt;/etc/nginx/geoip/GeoLiteCity.dat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;geoip_proxy&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="s"&gt;.0.16.0/26&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;geoip_proxy_recursive&lt;/span&gt; &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;geoip_proxy&lt;/code&gt;指令定义我们的代理服务器的CIDR范围, 指示NGINX利用&lt;code&gt;X-Forwarded-For&lt;/code&gt;头来查找客户端IP地址. &lt;code&gt;geoip_proxy_recursive&lt;/code&gt;指令指示NGINX来递归地查找上个知道的客户端IP的&lt;code&gt;X-Forwarded-For&lt;/code&gt; header.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;你可能会发现你在NGINX前边使用了代理, NGINX会选择代理的IP地址而不是客户端的. 对于这种情况你可以使用&lt;code&gt;geoip_proxy&lt;/code&gt;指令来指示在给定的范围内, NGINX使用&lt;code&gt;X-Forwarded-For&lt;/code&gt; header. &lt;code&gt;geoip_proxy&lt;/code&gt;指令配置一个地址或CIDR范围. 当NGINX前边有多个代理, 可以使用&lt;code&gt;geoip_proxy_recursive&lt;/code&gt;指令来递归地查找&lt;code&gt;X-Forwarded-For&lt;/code&gt;指令, 来找到源客户端. 你可能会在如在NGINX前边使用AWS ELB, 谷歌的负载均衡, 或Azure的负载均衡时用到这些.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:39:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-8-use-geoip-to-get-users-location.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-运维-自动化</title><link>https://www.EWhisper.cn/nginx-handbook-3-6-automatation.html</link><description>&lt;h2 id="36"&gt;3.6 自动化&lt;a class="headerlink" href="#36" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="360"&gt;3.6.0 介绍&lt;a class="headerlink" href="#360" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有很多方式来自动化NGINX和NGINX Plus的配置文件, 如: 使用配置管理工具或定时任务来从模板配置文件配置. 随着动态环境的增加, 自动化配置的需求变得更急需. 在上一章, 我们确信NGINX配置文件被配置后需要reload.在本章, 我们会讨论更进一步的使用NGINX Plus API和&lt;strong&gt;Consul Template&lt;/strong&gt;的实时(on-the-fly)NGINX配置文件重配置.&lt;/p&gt;
&lt;h3 id="361-nginx-plus"&gt;3.6.1 使用NGINX Plus自动化&lt;a class="headerlink" href="#361-nginx-plus" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要为动态环境重实时配置NGINX Plus的load balance.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用NGINX Plus API来重配置NGINX Plus upstream 池:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ curl &lt;span class="s1"&gt;&amp;#39;http://nginx.local/upstream_conf?\&lt;/span&gt;
&lt;span class="s1"&gt;  add=&amp;amp;upstream=backend&amp;amp;server=10.0.0.42:8080&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;curl&lt;/code&gt;调用到NGINX Plus的请求, 请求一个把一个新的server加到&lt;code&gt;backend&lt;/code&gt; upstream配置.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;更多第一次安装的细节见 3.8 章节, NGINX Plus提供一个API来重新实时配置NGINX Plus. NGINX Plus API允许从upstream 池中添加和移除server, 同时draining 连接. 你可以使用该API来自动化NGINX Plus的应用服务器的创建和释放的配置.&lt;/p&gt;
&lt;h3 id="362-consul-templating"&gt;3.6.2 使用Consul Templating 自动化配置&lt;a class="headerlink" href="#362-consul-templating" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要自动化NGINX配置来通过使用Consul在环境中做出变更.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;consul-template&lt;/code&gt; daemon和一个模板文件来模板化NGINX配置文件:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;upstream backend { &lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt;&lt;span class="nv"&gt;range&lt;/span&gt; &lt;span class="nv"&gt;service&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;app.backend&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;    server &lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt;&lt;span class="nv"&gt;.Address&lt;/span&gt;&lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt;&lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个例子是Consul模板文件的一个upstream配置块模板. 这个模板会遍历在Consul上标记为&lt;code&gt;app.backend&lt;/code&gt;的节点. 对于Consul上的每个节点, 这个模板会使用那个节点的IP地址产生一条server指令.&lt;/p&gt;
&lt;p&gt;这个&lt;code&gt;consul-template&lt;/code&gt; daemon通过命令行运行, 可以被用于在每次配置文件被模板化变更后reload NGINX:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# consul-template -consul consul.example.internal -template \&lt;/span&gt;
template:/etc/nginx/conf.d/upstream.conf:&lt;span class="s2"&gt;&amp;quot;nginx -s reload&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该指令指示&lt;code&gt;consul-template&lt;/code&gt; daemon 来连接到一个位于&lt;code&gt;consul.example.internal&lt;/code&gt;的Consul 集群, 并使用在当前工作目录的名为&lt;code&gt;template&lt;/code&gt;的文件来模板化该文件, 并输出生成的内容到&lt;code&gt;/etc/nginx/conf.d/upstream.conf&lt;/code&gt;中, 然后在每次模板化文件变更时reload NGINX. &lt;code&gt;-template&lt;/code&gt; 标志接受一个字符串,包括: 模板文件,输出位置,和运行模板过程后执行的命令; 这3个变量以冒号分隔. 如果运行的命令由空格, 确保使用双引号包裹. &lt;code&gt;-consul&lt;/code&gt;标志指示要连接的Consul集群.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;Consul是一个强大的服务发现工具和配置仓库. Consul以key-value 对以类似目录的结构存储节点信息, 允许restful API交互.Consul也在每个客户端上提供一个DNS界面, 允许进行连接到集群的节点的域名查找. 一个单独的, 利用Consul集群的项目是&lt;code&gt;consul-template&lt;/code&gt; daemon; 这个工具模板化在Consul 节点, 服务或 key-value对的文件变化. 这让Consul成为一个自动化NGINX的非常强大的选择. 使用&lt;code&gt;consul-template&lt;/code&gt;你也可以指示该daemon在模板替换变更后来运行一个命令. 通过这样, 可以reload NGINX配置, 并允许NGINX配置在环境中生效. 通过Consul, 你可以在每个客户端上设置健康检查来检查关注的服务的监控状况. 通过失败检测, 你能够通过模板化你的NGINX配置来只给健康的主机发送流量.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://www.consul.io/"&gt;Consul home page&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2iosmkV"&gt;Introduction to Consul Template&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/hashicorp/consul-template"&gt;Consul template GitHub&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:33:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-6-automatation.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-运维-前言和介绍</title><link>https://www.EWhisper.cn/nginx-handbook-3-0-foreword.html</link><description>&lt;h2 id="30"&gt;3.0 前言和介绍&lt;a class="headerlink" href="#30" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在NGINX CookBook的第一部分, 主题是负载均衡和缓存. 第二部分是NGINX的安全功能, 如认证和加密. 第三部分集中于NGINX的运维问你, 包括部署, 性能调优和解决问题.&lt;/p&gt;
&lt;p&gt;在这部分, 你会看到基于三个大型公有云的NGINX部署实践: Amazon Web Services(AWS), Google Cloud Platform(GCP), 和微软Azure, 包括如何自动化在AWS上部署. 如果你计划使用Docker, 也有相关内容.&lt;/p&gt;
&lt;p&gt;安装也会深入讨论使用Puppet, Chef, Ansible和SaltStack的自动化配置管理. 也介绍了使用NGINX Plus API来实施重配置, 使用Consul进行服务发现和模版配置.&lt;/p&gt;
&lt;p&gt;默认情况下, 大部分系统配置是基于兼容性而不是性能. 然后你要根据你的特定需求进行性能调优. 在本书中, 你会找到在保持兼容性的前提下, 详细的最大化NGINX性能的方法.&lt;/p&gt;
&lt;p&gt;当我碰到部署问题, 我首先会看日志文件, 是很多调试信息的来源. NGINX有维护详细的, 高度配置化的日志来帮助你定位问题. 本书中包含NGINX日志的详细内容.&lt;/p&gt;
&lt;p&gt;它会帮助你安装, 监控, 维护NGINX应用交付平台.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:28:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-0-foreword.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-运维-在Docker 上部署</title><link>https://www.EWhisper.cn/nginx-handbook-3-4-nginx-docker.html</link><description>&lt;h2 id="34-docker"&gt;3.4 在Docker上部署&lt;a class="headerlink" href="#34-docker" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="340"&gt;3.4.0 介绍&lt;a class="headerlink" href="#340" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Docker是个开源项目, 会自动把Linux应用部署到软件容器中. Docker提供一个额外的抽象层, 在linux上自动化操作系统级别的虚拟化. 容器化环境已经对生产世界造成了巨大的变革. Docker和其他容器平台允许快速, 可靠, 跨平台的应用部署. 本章中, 我们会讨论NGINX官方NGINX Dockerjingxiang,创建你自己的Docker文件来运行NGINX, 在NGINX中使用环境变量, 通用Docker实践.&lt;/p&gt;
&lt;h3 id="341-nginx"&gt;3.4.1 使用NGINX镜像快速运行&lt;a class="headerlink" href="#341-nginx" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要使用Docker Hub中的NGINX镜像快速启动和运行.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker pull nginx:latest
$ docker run -it -p &lt;span class="m"&gt;80&lt;/span&gt;:80 -v &lt;span class="nv"&gt;$PWD&lt;/span&gt;/nginx-conf:/etc/nginx &lt;span class="se"&gt;\&lt;/span&gt;
                                   nginx:latest
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;NGINX已经在Docker Hub上制作了一个官方Docker镜像. 官方Docker镜像很容易在Docker中启动和快速运行. 在本节中我们通过2个命令就能启动和运行NGINX 容器. 官方镜像是基于Debian Jessie Docker镜像. 但是你也可以选择基于Alpine Linux构建的官方镜像. 这些官方镜像的Dockerfile和源码可以在GitHub中找到.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://hub.docker.com/_/nginx/"&gt;Official NGINX Docker image, NGINX&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/nginxinc/docker-nginx/"&gt;Docker repo on GitHub&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="342-nginx-dockerfile"&gt;3.4.2 创建一个NGINX Dockerfile&lt;a class="headerlink" href="#342-nginx-dockerfile" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要创建一个NGINX Dockerfile, 用Dockerfile创建Docker镜像.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;CMD&lt;/code&gt;来在镜像实例化为容器时启动NGINX. 你需要在前台运行NGINX. 要这么做, 需要启动NGINX使用&lt;code&gt;-g "daemon off;"&lt;/code&gt;或增加&lt;code&gt;daemon off;&lt;/code&gt;到配置. 本例中稍后使用&lt;code&gt;daemon off;&lt;/code&gt;加到main context. 你也想调节你的access日志输出到&lt;code&gt;/dev/stdout&lt;/code&gt;, 错误日志输出到&lt;code&gt;/dev/stderr&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="s"&gt; centos:7&lt;/span&gt;
&lt;span class="c"&gt;# Install epel repo to get nginx and install nginx&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; yum -y install epel-release &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    yum -y install nginx
&lt;span class="c"&gt;# add local configuration files into the image&lt;/span&gt;
&lt;span class="k"&gt;ADD&lt;/span&gt; /nginx-conf /etc/nginx
&lt;span class="k"&gt;EXPOSE&lt;/span&gt;&lt;span class="s"&gt; 80 443&lt;/span&gt;
&lt;span class="k"&gt;CMD&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;nginx&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;目录结构如下所示:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;.
├── Dockerfile
└── nginx-conf
    ├── conf.d
    │   └── default.conf
    ├── fastcgi.conf
    ├── fastcgi_params
    ├── koi-utf
    ├── koi-win
    ├── mime.types
    ├── nginx.conf
    ├── scgi_params
    ├── uwsgi_params
    └── win-utf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在本例中, 我选择直接吧nginx-conf目录下所有我的NGINX配置都添加到Dockerfile中.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;当你需要完全控制包的安装和升级, 你会发现创建自己的Dockerfile很有用. 常见操作是保存在你自己的镜像仓库中, 这样你会知道你的基础镜像在上生产之前是可靠的, 经过团队测试的.&lt;/p&gt;
&lt;h3 id="343-nginx-plus"&gt;3.4.3 构建NGINX Plus镜像&lt;a class="headerlink" href="#343-nginx-plus" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="344-nginx"&gt;3.4.4 在NGINX中使用环境变量&lt;a class="headerlink" href="#344-nginx" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;为了在不同的环境中使用相同的容器镜像, 你需要在NGINX配置文件中使用环境变量.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;ngx_http_perl_module&lt;/code&gt;来从你的环境的NGINX中设置变量.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;daemon&lt;/span&gt; &lt;span class="no"&gt;off&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;env&lt;/span&gt; &lt;span class="s"&gt;APP_DNS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;include&lt;/span&gt; &lt;span class="n"&gt;/usr/share/nginx/modules/*.conf&lt;/span&gt;;
&lt;span class="k"&gt;...&lt;/span&gt;
&lt;span class="s"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kn"&gt;perl_set&lt;/span&gt; &lt;span class="nv"&gt;$upstream_app&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;sub&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="nv"&gt;$ENV{&amp;quot;APP_DNS&amp;quot;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="kn"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kn"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;...&lt;/span&gt;
    &lt;span class="s"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="kn"&gt;proxy_pass&lt;/span&gt; &lt;span class="s"&gt;https://&lt;/span&gt;&lt;span class="nv"&gt;$upstream_app&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;要使用&lt;code&gt;perl_set&lt;/code&gt;, 你必须安装&lt;code&gt;ngx_http_perl_module&lt;/code&gt;; 你可以通过动态模块加载或从源码静态构建. NGINX默认从环境中擦除环境变量; 你需要在&lt;code&gt;env&lt;/code&gt;指令中声明任何你不想移除的变量. &lt;code&gt;perl_set&lt;/code&gt;指令有2个参数: 你想要设置的变量名和渲染结果的perl字符串.&lt;/p&gt;
&lt;p&gt;下面是一个Dockerfile, 会动态加载&lt;code&gt;ngx_http_perl_module&lt;/code&gt;, 从包管理工具安装该模块. 当从CentOS的包管理中安装模块, 他们被放在&lt;code&gt;/usr/lib64/nginx/modules/&lt;/code&gt;目录, 配置文件会动态加载在&lt;code&gt;/usr/share/nginx/modules/&lt;/code&gt;目录的模块. 这就是为什么上面的配置块中, 要包含完整的路径.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="s"&gt; centos:7&lt;/span&gt;
&lt;span class="c"&gt;# Install epel repo to get nginx and install nginx&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; yum -y install epel-release &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    yum -y install nginx nginx-mod-http-perl
&lt;span class="c"&gt;# add local configuration files into the image&lt;/span&gt;
&lt;span class="k"&gt;ADD&lt;/span&gt; /nginx-conf /etc/nginx
&lt;span class="k"&gt;EXPOSE&lt;/span&gt;&lt;span class="s"&gt; 80 443&lt;/span&gt;
&lt;span class="k"&gt;CMD&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;nginx&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;当使用Docker, 典型实践就是利用环境变量来修改容器操作的方式. 你可以在NGINX配置文件中使用环境变量, 这样NGINX可以用于多个, 不同的环境.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:28:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-4-nginx-docker.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category><category>docker</category></item><item><title>NGINX 实战手册-运维-使用Puppet/Chef/Ansible/SaltStack部署</title><link>https://www.EWhisper.cn/nginx-handbook-3-5-nginx-autoconf-tools.html</link><description>&lt;h2 id="35-puppetchefansiblesaltstack"&gt;3.5 使用Puppet/Chef/Ansible/SaltStack&lt;a class="headerlink" href="#35-puppetchefansiblesaltstack" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="350"&gt;3.5.0 介绍&lt;a class="headerlink" href="#350" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在云的时代, 配置管理工具是无价之宝. 大规模web应用的工程师无法通过代码手把手配置servers, 但是使用其中任何一个配置管理工具都可以做到. 配置管理工具允许工程师一次写入配置和代码到很多有相同配置的server, 通过使用一种可重复, 可测试, 模块化的方式. 本章讨论几个流行的配置管理工具, 以及如何使用他们安装NIGINX和从模版创建一个基本配置. 这些例子非常基础, 但是展示了如何通过每个平台来启动NGINX.&lt;/p&gt;
&lt;h3 id="351-puppet"&gt;3.5.1 使用Puppet安装&lt;a class="headerlink" href="#351-puppet" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要通过Puppet安装和配置NGINX, 以代码形式管理NGINX配置, 并确认你的其他Puppet配置.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;创建一个模块, 用于安装NGINX, 管理你需要的文件, 确保NGINX在运行:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;nginx&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;package&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;nginx&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;ensure&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;installed&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,}&lt;/span&gt;
    &lt;span class="n"&gt;service&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;nginx&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;ensure&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;true&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;hasrestart&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;true&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;restart&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/etc/init.d/nginx reload&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;nginx.conf&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;path&lt;/span&gt;    &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/etc/nginx/nginx.conf&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Package&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;nginx&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;notify&lt;/span&gt;  &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Service&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;nginx&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;nginx/templates/nginx.conf.erb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;root&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;root&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;0644&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该模块使用包管理工具来确保NGINX被安装. 也会确保NGINX在启动时在运行和可用. 该配置通知Puppet, 该服务有重启命令, 通过&lt;code&gt;hasrestart&lt;/code&gt;指令, 并且我们用NGINX reload命令覆盖&lt;code&gt;restart&lt;/code&gt;命令. 它通过内置Ruby(ERB)模版语言来管理和模板化&lt;code&gt;nginx.conf&lt;/code&gt;文件. 文件的模板化会发生在NGINX包被安装之后(通过&lt;code&gt;require&lt;/code&gt;指令). 但是, 它会通过&lt;code&gt;notify&lt;/code&gt;指令通知NGINX服务来reload. 该模版化配置文件没有包括. 另外, 它可以简单安装一个默认的NGINX配置文件, 或是使用内置Ruby(ERB)或内置Puppet(EPP)模版语言的循环和变量替换.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;Puppet是基于Ruby语言的配置管理工具. 模块被构建进一个特定域的语言, 并通过定义给定server配置的manifest文件调用. Puppet可以用主从或masterless模式运行. 使用Puppet, manifest运行在master上, 然后发到slave上. 这很重要, 因为它确保slave只是被交付对它有用的配置, 对其他server的其他配置是不会给这个slave的. Puppet有很多非常高级的公用模块. 通过这些模块, 会在配置上帮助你飞起. 在GitHub上来自voxpupuli的公共NGINX模块会为你模板化NGINX配置.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://docs.puppet.com/"&gt;Puppet documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jfgpm4"&gt;Puppet package documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jMq2cx"&gt;Puppet service documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jMz4q3"&gt;Puppet file documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2isqAlP"&gt;Puppet templating documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jMspMn"&gt;Voxpupuli NGINX module&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="352-chef"&gt;3.5.2 使用Chef安装&lt;a class="headerlink" href="#352-chef" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="353-ansible"&gt;3.5.3 使用Ansible安装&lt;a class="headerlink" href="#353-ansible" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要使用Ansible来安装和配置NGINX, 以代码形式管理NGINX配置, 并确认你的其他Ansible配置.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;创建一个安装NGINX和管理&lt;em&gt;nginx.conf&lt;/em&gt;文件playbook. 下列是一个示例的任务文件.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;NGINX | Installing NGINX&lt;/span&gt;
  &lt;span class="nt"&gt;package&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;name=nginx state=present&lt;/span&gt;

&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;NGINX | Starting NGINX&lt;/span&gt;
  &lt;span class="nt"&gt;service&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;nginx&lt;/span&gt;
    &lt;span class="nt"&gt;state&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;started&lt;/span&gt;
    &lt;span class="nt"&gt;enabled&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;yes&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;Copy nginx configuration in place.&lt;/span&gt;
  &lt;span class="nt"&gt;template&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nt"&gt;src&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;nginx.conf.j2&lt;/span&gt;
    &lt;span class="nt"&gt;dest&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/etc/nginx/nginx.conf&amp;quot;&lt;/span&gt;
    &lt;span class="nt"&gt;owner&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;root&lt;/span&gt;
    &lt;span class="nt"&gt;group&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;root&lt;/span&gt;
    &lt;span class="nt"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;0644&lt;/span&gt;
  &lt;span class="nt"&gt;notify&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;reload nginx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;package&lt;/code&gt;块安装NGINX. &lt;code&gt;service&lt;/code&gt;块确保NGINX在启动时被启动和可用. &lt;code&gt;template&lt;/code&gt;块模板化一个&lt;em&gt;Jinja2&lt;/em&gt;文件, 并把结果以root用户和组放到&lt;code&gt;/etc/nginx.conf&lt;/code&gt;中. 该模版块也设置&lt;em&gt;mode&lt;/em&gt;为644, 并通知nginx服务reload. 模板化配置文件没有包含在内. 但是, 可以通过默认的NGINX配置文件来简单, 或者通过Jinja2模版语言的循环和变量替换生成很复杂的模版.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;Ansible是用Python编写的广泛使用的强大配置管理工具. 任务配置使用YAML, 使用Jinja2模版语言生成文件模版. Ansible提供一个有master的叫做Ansible Tower的订阅版. 但是, 它经常用于本地机器或构建服务器直接到客户端或者使用masterless模式. Ansible打包SSH到它的server并运行配置. 和其他配置工具类似, 有很多社区提供的公共roles, Ansible把它叫做Ansible Galaxy. 你可以找到可以用于你的playbook的非常复杂的roles.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://docs.ansible.com/"&gt;Ansible documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jfiwGv"&gt;Ansible packages&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jMGF7E"&gt;Ansible service&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2j8j526"&gt;Ansible template&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://galaxy.ansible.com/"&gt;Ansible Galaxy&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="354-saltstack"&gt;3.5.4 使用SaltStack安装&lt;a class="headerlink" href="#354-saltstack" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要使用SaltStack来安装和配置NGINX, 以代码形式管理NGINX配置, 并确认你的其他SaltStack配置.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;nginx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;pkg&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;installed&lt;/span&gt;
  &lt;span class="nt"&gt;service&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;nginx&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;running&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;enable&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;True&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;reload&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;True&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;watch&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;file&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;/etc/nginx/nginx.conf&lt;/span&gt;

&lt;span class="nt"&gt;/etc/nginx/nginx.conf&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;file&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;managed&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;source&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;salt://path/to/nginx.conf&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;user&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;root&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;group&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;root&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;template&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;jinja&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;644&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;require&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;pkg&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;nginx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:28:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-5-nginx-autoconf-tools.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-安全-实用安全技巧</title><link>https://www.EWhisper.cn/nginx-handbook-2-10-security-tips.html</link><description>&lt;h2 id="210"&gt;2.10 实用安全技巧&lt;a class="headerlink" href="#210" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="2100"&gt;2.10.0 介绍&lt;a class="headerlink" href="#2100" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;安全是分层的, 就像一个洋葱, 你的安全模型确实要被多层加固. 在这部分, 我们介绍许多不同的方法来确保web应用程序NGINX和NGINX Plus. 很多的这些安全方法可以用来加固安全. 下面是一些实用的安全提示,以确保您的用户在使用HTTPS和告诉NGINX满足一个或多个安全方法。&lt;/p&gt;
&lt;h3 id="2101-https"&gt;2.10.1 HTTPS 重定向&lt;a class="headerlink" href="#2101-https" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要重定向未加密的请求到HTTPS.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;rewrite&lt;/code&gt;来发送所有HTTP流量到HTTPS:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt; &lt;span class="s"&gt;default_server&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="s"&gt;[::]:80&lt;/span&gt; &lt;span class="s"&gt;default_server&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;server_name&lt;/span&gt; &lt;span class="s"&gt;_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;301&lt;/span&gt; &lt;span class="s"&gt;https://&lt;/span&gt;&lt;span class="nv"&gt;$host$request_uri&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个配置监听所有hostname的IPv4和IPv6的80端口作为默认的server. &lt;code&gt;return&lt;/code&gt;声明返回301永久重定向到同样的host和请求URI的HTTPS上.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;总是把适当的请求重定向到HTTPS是非常重要的. 你可能会发现你不需要重定向所有的请求, 而是在客户端和server之间传输敏感信息的那些请求. 在本例中, 你可能想要把&lt;code&gt;return&lt;/code&gt;声明放到特定的location里, 如&lt;code&gt;/login&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="2102-ssltlsnginxhttps"&gt;2.10.2 重定向SSL/TLS在NGINX之前已经结束的到HTTPS&lt;a class="headerlink" href="#2102-ssltlsnginxhttps" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要重定向到HTTPS, 然而, 在NGINX之前, 你已经结束了SSL/TLS.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用标准的&lt;code&gt;HTTP_X_Forwarded_Proto&lt;/code&gt; 头来决定是否你需要进行重定向:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt; &lt;span class="s"&gt;default_server&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="s"&gt;[::]:80&lt;/span&gt; &lt;span class="s"&gt;default_server&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;server_name&lt;/span&gt; &lt;span class="s"&gt;_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;if&lt;/span&gt; &lt;span class="s"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$http_x_forwarded_proto&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http&amp;#39;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;301&lt;/span&gt; &lt;span class="s"&gt;https://&lt;/span&gt;&lt;span class="nv"&gt;$host$request_uri&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个配置和HTTPS重定向很像. 但是, 在这个配置中, 只有头&lt;code&gt;X_Forwarded_Proto&lt;/code&gt;等于HTTP才会重定向.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;这是一个在NGINX之前就结束了SSL/TLS的常见案例. 你可能要这么做的一个原因是节省计算开销. 但是, 你需要确保每个请求都是HTTPS, 但是结束了SSL/TLS的层没有重定向的能力. 但是, 可以设置代理头部. 这个配置可以在Amazon Web Services Elastic Load Balancer上工作, 因为这个如果没有额外的花钱的话就会卸载掉SSL/TLS. 这是一个方便的技巧以确保你的HTTP流量是安全的。&lt;/p&gt;
&lt;h3 id="2103"&gt;2.10.3 满足任意数量的安全方法&lt;a class="headerlink" href="#2103" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要提供多种方式来传输安全到一个不公开的站点.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;satisfy&lt;/code&gt;指令来说明你想要使用任意数量的安全方法:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;satisfy&lt;/span&gt; &lt;span class="s"&gt;any&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;allow&lt;/span&gt; &lt;span class="mi"&gt;192&lt;/span&gt;&lt;span class="s"&gt;.168.1.0/24&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;deny&lt;/span&gt;  &lt;span class="s"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;auth_basic&lt;/span&gt;           &lt;span class="s"&gt;&amp;quot;closed&lt;/span&gt; &lt;span class="s"&gt;site&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;auth_basic_user_file&lt;/span&gt; &lt;span class="s"&gt;conf/htpasswd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该配置告诉NGINX用户请求&lt;code&gt;location /&lt;/code&gt;需要满足其中的一个安全方法: 或者该请求需要来自&lt;em&gt;192.168.1.0/24&lt;/em&gt; CIDR block, 或者能够提供在可以在&lt;code&gt;conf/htpasswd&lt;/code&gt;中找到的用户名密码. &lt;code&gt;satisfy&lt;/code&gt;指令有2个选项: &lt;code&gt;any&lt;/code&gt;或&lt;code&gt;all&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;satifsy&lt;/code&gt;指令是一个提供多种认证的很好的方式. 通过指定&lt;code&gt;any&lt;/code&gt;给&lt;code&gt;satisfy&lt;/code&gt;指令, 用户必须满足其中一个安全. 指定&lt;code&gt;all&lt;/code&gt;给&lt;code&gt;satisfy&lt;/code&gt;指令, 用户必须满足所有的安全认证. 该指令可以和2.1的&lt;code&gt;http_access_module&lt;/code&gt;结合, 2.4的&lt;code&gt;http_auth_basic_module&lt;/code&gt;, 2.5的&lt;code&gt;http_auth_request_module&lt;/code&gt;, 2.7的&lt;code&gt;http_auth_jwt_module&lt;/code&gt;. 只有各个层都安全, 才是真正的安全. &lt;code&gt;satisfy&lt;/code&gt;指令会帮助你为这个location或server实现需要的深度安全规则.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:24:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-2-10-security-tips.html</guid><category>nginx</category><category>安全</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-安全-ModSecurity Web应用防火墙</title><link>https://www.EWhisper.cn/nginx-handbook-2-9-waf.html</link><description>&lt;h2 id="29-modsecurity-web"&gt;2.9 ModSecurity Web应用防火墙&lt;a class="headerlink" href="#29-modsecurity-web" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="290"&gt;2.9.0 介绍&lt;a class="headerlink" href="#290" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;ModSecurity 是一个开源的web应用防火墙(WAF), 首次被构建仅Apache web server. 在2012年, 它作为NGINX的一个模块可供使用, 2016加入NGINX Plus作为一个可选功能. 本章将详细介绍使用NGINX Plus的动态模块功能安装ModSecurity 3.0, 使用开源NGINX安装ModeSecurity 2.9. ModSecurity 3.0比ModSecurity 2.x的安全和性能更出众. 当从开源运行ModSecurity 2.9, 因为它仍然是在Apache上构造, 因此需要比3.0更多的开销, 而3.0是基于NGINX原生设计的.  ModSecurity 3.0 只能用于NGINX Plus订阅.&lt;/p&gt;
&lt;h3 id="291-nginx-plusmodesecurity"&gt;2.9.1 为NGINX Plus安装ModeSecurity&lt;a class="headerlink" href="#291-nginx-plusmodesecurity" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;略过&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="292-nginx-plusmodsecurity"&gt;2.9.2 在NGINX Plus中配置ModSecurity&lt;a class="headerlink" href="#292-nginx-plusmodsecurity" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要配置NGINX Plus使用ModSecurity模块.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;在NGINX Plus配置中启用动态模块, 使用&lt;code&gt;modsecurity_rules_file&lt;/code&gt;来指向一个ModSecurity规则文件:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;load_module modules/ngx_http_modsecurity.so;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;load_module&lt;/code&gt;指令适用于主context, 意味着该指令可以在打开HTTP或Stream块之前使用.&lt;/p&gt;
&lt;p&gt;开启ModeSecurity, 使用指定规则集:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;modsecurity&lt;/span&gt; &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_pass&lt;/span&gt; &lt;span class="s"&gt;http://backend&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;modsecurity_rules_file&lt;/span&gt; &lt;span class="s"&gt;rule-set-file&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;ModSecurity的规则可以阻止对常见的web servers和应用的漏洞利用. ModSecurity已知可以防御应用层的攻击, 如HTTP violations, SQL注入, 跨站脚本, 应用层, DDoS, 远程和本地文件攻击. 使用ModSecurity, 你可以订阅恶意用于的实时的黑名单, 来帮助在服务被攻击之前阻止问题. ModSecurity模块也可以启用日志帮助识别新的攻击模式和异常.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2fdZ7Dd"&gt;OWASP ModSecurity 核心规则集&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2eJYuAx"&gt;TrustWave ModSecurity 付费规则集&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="293-modsecurity"&gt;2.9.3 源码安装ModSecurity&lt;a class="headerlink" href="#293-modsecurity" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要在CentOS或RHEL系统上使用NGINX运行ModSecurity.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;从源码编译ModSecurity和NGINX来使用ModSecurity模块.&lt;/p&gt;
&lt;p&gt;首先升级security并安装依赖:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ yum --security update -y &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    yum -y install automake &lt;span class="se"&gt;\&lt;/span&gt;
    autoconf &lt;span class="se"&gt;\&lt;/span&gt;
    curl &lt;span class="se"&gt;\&lt;/span&gt;
    curl-devel &lt;span class="se"&gt;\&lt;/span&gt;
    gcc &lt;span class="se"&gt;\&lt;/span&gt;
    gcc-c++ &lt;span class="se"&gt;\&lt;/span&gt;
    httpd-devel &lt;span class="se"&gt;\&lt;/span&gt;
    libxml2 &lt;span class="se"&gt;\&lt;/span&gt;
    libxml2-devel &lt;span class="se"&gt;\&lt;/span&gt;
    make &lt;span class="se"&gt;\&lt;/span&gt;
    openssl &lt;span class="se"&gt;\&lt;/span&gt;
    openssl-devel &lt;span class="se"&gt;\&lt;/span&gt;
    perl &lt;span class="se"&gt;\&lt;/span&gt;
    wget
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来, 下载安装PCRE库:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; /opt &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    wget http://ftp.exim.org/pub/pcre/pcre-8.39.tar.gz &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    tar -zxf pcre-8.39.tar.gz &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="nb"&gt;cd&lt;/span&gt; pcre-8.39 &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    ./configure &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    make &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    make install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下载zlib源码并安装:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; /opt &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    wget http://zlib.net/zlib-1.2.8.tar.gz &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    tar -zxf zlib-1.2.8.tar.gz &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="nb"&gt;cd&lt;/span&gt; zlib-1.2.8 &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    ./configure &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    make &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    make install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下载ModSecurity源码并安装:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; /opt &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  wget &lt;span class="se"&gt;\&lt;/span&gt;
  https://www.modsecurity.org/tarball/2.9.1/modsecurity-2.9.1.&lt;span class="se"&gt;\&lt;/span&gt;
tar.gz&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  tar -zxf modsecurity-2.9.1.tar.gz &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="nb"&gt;cd&lt;/span&gt; modsecurity-2.9.1 &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  ./configure --enable-standalone-module &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  make
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从源码下载安装NGINX, 并在配置脚本里包含你需要的所有模块. 本次我们的关注点是ModSecurity:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; /opt &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    wget http://nginx.org/download/nginx-1.11.4.tar.gz &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    tar zxf nginx-1.11.4.tar.gz &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="nb"&gt;cd&lt;/span&gt; nginx-1.11.4 &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    ./configure &lt;span class="se"&gt;\&lt;/span&gt;
        --sbin-path&lt;span class="o"&gt;=&lt;/span&gt;/usr/local/nginx/nginx &lt;span class="se"&gt;\&lt;/span&gt;
        --conf-path&lt;span class="o"&gt;=&lt;/span&gt;/etc/nginx/nginx.conf &lt;span class="se"&gt;\&lt;/span&gt;
        --pid-path&lt;span class="o"&gt;=&lt;/span&gt;/usr/local/nginx/nginx.pid &lt;span class="se"&gt;\&lt;/span&gt;
        --with-pcre&lt;span class="o"&gt;=&lt;/span&gt;../pcre-8.39 &lt;span class="se"&gt;\&lt;/span&gt;
        --with-zlib&lt;span class="o"&gt;=&lt;/span&gt;../zlib-1.2.8 &lt;span class="se"&gt;\&lt;/span&gt;
        --with-http_ssl_module &lt;span class="se"&gt;\&lt;/span&gt;
        --with-stream &lt;span class="se"&gt;\&lt;/span&gt;
        --with-http_ssl_module &lt;span class="se"&gt;\&lt;/span&gt;
        --with-http_secure_link_module &lt;span class="se"&gt;\&lt;/span&gt;
        --add-module&lt;span class="o"&gt;=&lt;/span&gt;../modsecurity-2.9.1/nginx/modsecurity &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    make &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    make install &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    ln -s /usr/local/nginx/nginx /usr/bin/nginx
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这将会把ModSecurity 2.9.1 模块编译并和NGINX一起安装. 从现在开始, 我们可以使用&lt;code&gt;ModSecurityEnabled&lt;/code&gt;和&lt;code&gt;ModSecurityConfig&lt;/code&gt;指令:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt; &lt;span class="s"&gt;default_server&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="s"&gt;[::]:80&lt;/span&gt; &lt;span class="s"&gt;default_server&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;server_name&lt;/span&gt; &lt;span class="s"&gt;_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="kn"&gt;ModSecurityEnabled&lt;/span&gt; &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="kn"&gt;ModSecurityConfig&lt;/span&gt; &lt;span class="s"&gt;modsecurity.conf&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;NGINX server的配置会为&lt;code&gt;location /&lt;/code&gt;启用ModSecurity, 并使用位于NGINX配置目录下的ModSecurity配置文件.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;这一节从NGINX源码编译, 并把ModSecurity编译到NGINX中. 推荐从源码编译NGINX的时候, 总是检查你是否使用了最新的稳定版的包. 通过之前的案例, 你可以使用有ModSecurity的开源版本的NGINX来构建你的开源web应用防火墙.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://github.com/SpiderLabs/ModSecurity"&gt;ModSecurity源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2eJYuAx"&gt;Updated and maintained ModSecurity Rules from SpiderLabs&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:22:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-2-9-waf.html</guid><category>nginx</category><category>安全</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-安全-安全链接</title><link>https://www.EWhisper.cn/nginx-handbook-2-6-secure-link.html</link><description>&lt;h2 id="26"&gt;2.6 安全链接&lt;a class="headerlink" href="#26" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="260"&gt;2.6.0 介绍&lt;a class="headerlink" href="#260" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;安全链接(secure links)是一种使用&lt;em&gt;md5&lt;/em&gt;哈希算法保证静态资源安全的方式. 使用这个模块, 你也可以限制该链接接收请求的时长. 使用安全链接使NGINX应用程序服务器确保静态内容安全而无需应用服务器承担这种责任. 这个模块包含在免费开源的NGINX里. 但是, 它没有打进标准的NGINX包, 而是放到了&lt;code&gt;nginx-extras&lt;/code&gt;包里. 当从源码构建NGINX时, 可以选择使用配置参数&lt;code&gt;--with-http_secure_link_module&lt;/code&gt;来启用.&lt;/p&gt;
&lt;h3 id="261-location"&gt;2.6.1 加密Location&lt;a class="headerlink" href="#261-location" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要使用一个密钥来加密一个location块.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用安全链接模块, &lt;code&gt;secure_link_secret&lt;/code&gt;指令来限制对资源的访问的用户有一个安全的链接:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/resources&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;secure_link_secret&lt;/span&gt; &lt;span class="s"&gt;mySecret&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;if&lt;/span&gt; &lt;span class="s"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$secure_link&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;403&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="kn"&gt;rewrite&lt;/span&gt; &lt;span class="s"&gt;^&lt;/span&gt; &lt;span class="s"&gt;/secured/&lt;/span&gt;&lt;span class="nv"&gt;$secure_link&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/secured&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;internal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;root&lt;/span&gt; &lt;span class="s"&gt;/var/www&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该配置创建了一个内部和一个外部的location块. 外部的location块&lt;code&gt;/resources&lt;/code&gt;会返回403 Forbidden, 除非请求URI包含一个&lt;em&gt;md5&lt;/em&gt;哈希字符串, 这个字符串可以被&lt;code&gt;secure_link_secret&lt;/code&gt;指令提供的secret验证. &lt;code&gt;$secure_link&lt;/code&gt;变量是一个空字符串, 除非在URI的哈希被验证.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;使用secret加密资源是一个很好的确保你的文件受保护的方法. 该secret用于和URI串联 . 该字符串然后会被&lt;code&gt;md5&lt;/code&gt;哈希, &lt;code&gt;md5&lt;/code&gt;哈希后的16禁止数字被用在该URI中. 该哈希被放到链接中, 由NGINX计算. NGINX会知道URI想要访问的路径, 因为哈希后就在URI中 . NGINX也会直到你的secret, 因为指令&lt;code&gt;secure_link_secret&lt;/code&gt;会提供. NGINX能够迅速验证&lt;code&gt;md5&lt;/code&gt;哈希, 并存储在URI的&lt;code&gt;$secure_link&lt;/code&gt;变量中. 如果哈希无法验证, 该变量就是空字符串. 需要注意, 传给&lt;code&gt;secure_link_secret&lt;/code&gt;的参数必须是一个静态字符串, 不能是变量.&lt;/p&gt;
&lt;h3 id="262-secret"&gt;2.6.2 使用secret生成一个安全链接&lt;a class="headerlink" href="#262-secret" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要使用secret从你的应用生成一个安全链接.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;NGINX的安全链接模块接收一个md5哈希(URI路径和secret的联接)过的16进制字符串. 基于上一节, 我们会创建安全的连接, 可以工作在上个配置, 比如&lt;code&gt;/var/www/secured/index.html&lt;/code&gt;. 要生成md5哈希的16进制字符串, 我们可以使用Unix openssl命令:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; -n &lt;span class="s1"&gt;&amp;#39;index.htmlmySecret&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; openssl md5 -hex
&lt;span class="o"&gt;(&lt;/span&gt;stdin&lt;span class="o"&gt;)=&lt;/span&gt; a53bee08a4bf0bbea978ddf736363a12
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;保护的URI: &lt;em&gt;index.html&lt;/em&gt;; secret: &lt;em&gt;mySecret&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;下边是使用Python 2.7和&lt;em&gt;md5&lt;/em&gt;库生成的:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;md5&lt;/span&gt;
&lt;span class="n"&gt;md5&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;index.htmlmySecret&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hexdigest&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="s1"&gt;&amp;#39;a53bee08a4bf0bbea978ddf736363a12&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么我们访问的地址应该是如下所示, 要访问&lt;code&gt;/var/www/secured/index.html&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;www.example.com/resources/a53bee08a4bf0bbea978ddf736363a12/\
index.html
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;要生成这个数字可以由很多种方式, 很多语言都可以实现. 要记住的是: URI路径在secret之前, 字符串中没有回车, 并且使用&lt;em&gt;md5&lt;/em&gt;哈希的16进制数字.&lt;/p&gt;
&lt;h3 id="263-expire-datelocation"&gt;2.6.3 使用Expire Date加密Location&lt;a class="headerlink" href="#263-expire-datelocation" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要生成一个在一段时间后过期的链接.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;利用在安全链接模块的其他指令来在你的加密链接中设置过期日志和使用变量:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/resources&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;root&lt;/span&gt; &lt;span class="s"&gt;/var/www&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;secure_link&lt;/span&gt; &lt;span class="nv"&gt;$arg_md5,$arg_expires&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;secure_link_md5&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$secure_link_expires$uri$remote_addr&lt;/span&gt;
   &lt;span class="s"&gt;mySecret&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;if&lt;/span&gt; &lt;span class="s"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$secure_link&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;403&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kn"&gt;if&lt;/span&gt; &lt;span class="s"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$secure_link&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0&amp;quot;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;410&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;secure_link&lt;/code&gt;指令有2个用逗号隔开的字段. 第一个字段是&lt;em&gt;md5&lt;/em&gt;哈希的变量. 这个例子使用一个HTTP参数的md5。第二个字段是放置以Unix元年时间格式的链接过期时间的变量. &lt;code&gt;secure_link_md5&lt;/code&gt;指令占用一个单独的字段, 声明用于构造&lt;em&gt;md5&lt;/em&gt;哈希的的格式的字符串. 和其他配置一样, 如果hash没有通过验证, &lt;code&gt;$secure_link&lt;/code&gt;变量设置为空字符串. 或者, 如果哈希匹配但是时间过期, &lt;code&gt;$secure_link&lt;/code&gt;变量设置为0.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;这种用法比之前2.6.1中的更灵活, 看起来更干净. 使用这些指令, 你可以使用可以用在NGINX哈希字符串中的任意数量的变量. 在哈希字符串中使用用户相关的变量会加强安全性, 因为用户不能够得到加密的资源. 推荐使用像是&lt;code&gt;$remote_addr&lt;/code&gt;或&lt;code&gt;$http_x_forwarded_for&lt;/code&gt;或由应用生成的会话cookie作为变量. &lt;code&gt;secure_link&lt;/code&gt;的参数可以来自你喜欢的任何变量, 他们可以被命名为任意合适的名字. 在&lt;code&gt;$secure_link&lt;/code&gt;变量中的条件可以被设置返回已知的Forbidder和Gone的HTTP代码. HTTP 410, Gone, 对于过期链接非常适用, 因为这个条件被认为是永久的.&lt;/p&gt;
&lt;h3 id="264"&gt;2.6.4 生成一个有过期时间的链接&lt;a class="headerlink" href="#264" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要生成一个有过期时间的链接.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;用Unix时间戳格式生成一个过期时间戳. 在Unix系统上, 你可以这样操作:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ date -d &lt;span class="s2"&gt;&amp;quot;2020-12-31 00:00&amp;quot;&lt;/span&gt; +%s
&lt;span class="m"&gt;1609390800&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来你需要连接用在&lt;code&gt;secure_link_md5&lt;/code&gt;指令中的哈希字符串. 在本例中, 使用&lt;code&gt;1293771600/resources/index.html127.0.0.1  mySecret&lt;/code&gt;. md5哈希和刚刚的16进制数字有一些不同. 它是一个二进制格式的md5哈希, 采用base64加密, 用加号(+)转换为连接符(-), 斜杠(/)转换为下划线(_), 等号(=)被移除. 如下所示:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; -n &lt;span class="s1"&gt;&amp;#39;1609390800/resources/index.html127.0.0.1 mySecret&amp;#39;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="p"&gt;|&lt;/span&gt; openssl md5 -binary &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="p"&gt;|&lt;/span&gt; openssl base64 &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="p"&gt;|&lt;/span&gt; tr +/ -_ &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="p"&gt;|&lt;/span&gt; tr -d &lt;span class="o"&gt;=&lt;/span&gt;
81CYyxXFADhLHaQD36_BK
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就得到了哈希, 我们可以用它后边跟着过期日期作为参数.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/resources/index.html?md5=81CYyxXFADhLHaQD36_BK&amp;amp;expires=1609390800'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以下是使用Python 2.7的标准库的例子:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;datetime&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;datetime&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;base64&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;b64encode&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;md5&lt;/span&gt;
&lt;span class="n"&gt;resource&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/resources/index.html&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;remote_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;127.0.0.1&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;host&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;www.example.com&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;expire&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;datetime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2020&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strftime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;uncoded&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expire&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;resource&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;remote_addr&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39; mySecret&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;md5hashed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;md5&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uncoded&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;digest&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;b64&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b64encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;md5hashed&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b64&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;_&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;=&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;linkformat&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;{}{}?md5={}?expires{}&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;securelink&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;linkformat&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;resource&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;expire&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;使用这种方式, 我们能生成用于URL中的特殊格式的加密链接. 提供安全保障的secret绝不会发给客户端. 你可以用尽可能的你需要的其他变量来加密location. md5哈希和base64加密很常见, 轻量, 几乎在所有语言中都可用.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:15:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-2-6-secure-link.html</guid><category>nginx</category><category>安全</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-安全-使用JWT API的安全认证</title><link>https://www.EWhisper.cn/nginx-handbook-2-7-jwt-api-auth.html</link><description>&lt;h2 id="27-jwtapi"&gt;2.7 使用JWT的API认证&lt;a class="headerlink" href="#27-jwtapi" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="270"&gt;2.7.0 介绍&lt;a class="headerlink" href="#270" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;JSON Web Tokens (JWTs)迅速成为一种广为使用和受欢迎的认证方式. 这些认证tokens有能力存储一些用户和用户的认证信息到token里. 这些tokens也可以异步验证, 这意味着负载均衡和代理可以使用公钥来验证该token, 而不需要用于签发token的私钥, 以此提高安全和灵活性.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NGINX Plus的功能, 略过.&lt;/p&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:15:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-2-7-jwt-api-auth.html</guid><category>nginx</category><category>安全</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-安全-HTTP 子请求认证</title><link>https://www.EWhisper.cn/nginx-handbook-2-5-http-subrequest-auth.html</link><description>&lt;h3 id="251"&gt;2.5.1 介绍&lt;a class="headerlink" href="#251" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;伴随着很多不同的认证方法, NGINX通过启用自请求mid-flight 来使验证认证广泛的认证系统变得容易. HTTP认证请求模块可以启用如LDAP或自定义认证微服务的认证系统. 在请求被执行之前, 认证机制会代理该请求到认证服务. 在这个代理中, 通过NGINX的能力可以操纵需要身份验证服务的请求。因此,它非常灵活。&lt;/p&gt;
&lt;h3 id="252"&gt;2.5.2 认证子请求&lt;a class="headerlink" href="#252" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你有一个第三方的认证系统, 请求认证需要用到这个系统.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;http_auth_request_module&lt;/code&gt;在请求执行前, 让请求到对应的认证服务来进行验证:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;private&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="err"&gt;auth_request&lt;/span&gt; &lt;span class="err"&gt;/auth&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="err"&gt;auth_request_set&lt;/span&gt; &lt;span class="err"&gt;$auth_status&lt;/span&gt; &lt;span class="err"&gt;$upstream_status&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;auth&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="err"&gt;internal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="err"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;auth-server&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="err"&gt;proxy_pass_request_body&lt;/span&gt; &lt;span class="err"&gt;off&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="err"&gt;proxy_set_header&lt;/span&gt; &lt;span class="err"&gt;Content-length&lt;/span&gt; &lt;span class="err"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="err"&gt;proxy_set_header&lt;/span&gt; &lt;span class="err"&gt;X-Original-URI&lt;/span&gt; &lt;span class="err"&gt;$request_uri&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;auth_request&lt;/code&gt;指令使用必须是local internal location的URI参数. &lt;code&gt;auth_request_set&lt;/code&gt;指令允许你从认证自请求来设置变量.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;http_auth_request_module&lt;/code&gt;允许对每个NGINX处理的请求做认证. 在响应原服务之前, 会生成一个子请求, 来决定这个请求是否可以访问它请求的资源.  整个请求会被代理到自请求块 location. 通过自请求的状态码来确定是否可以访问资源. 如果自请求返回200 HTTP 状态码, 认证成功, 请求被响应. 如果返回HTTP 401或403, 会向原请求返回同样的代码.&lt;/p&gt;
&lt;p&gt;如果你的认证服务不需要请求body, 你可以抛弃掉请求body, 通过&lt;code&gt;proxy_pass_reqeust_body&lt;/code&gt;指令(如上例子所示). 这会减少请求size和时间. 因为请求体被忽略, &lt;code&gt;Content-Length&lt;/code&gt; header可以设为空字符串. 如果你的认证服务需要直到原请求的URI, 你可以把这个值放到一个自定义的header, 让你的认证服务来检查和验证. 如果从子请求到认证服务见你想要保留一些东西, 你可以使用  &lt;code&gt;auth_request_set&lt;/code&gt;指令来创建相应数据之外新的变量.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:13:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-2-5-http-subrequest-auth.html</guid><category>nginx</category><category>安全</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-安全-加密</title><link>https://www.EWhisper.cn/nginx-handbook-2-3-encrypt.html</link><description>&lt;h2 id="23"&gt;2.3 加密&lt;a class="headerlink" href="#23" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="230"&gt;2.3.0 介绍&lt;a class="headerlink" href="#230" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;网络是个很可怕的地方, 但不需太过担心. 加密传输信息变得越来越容易, 越来越唾手可得, 因为签名证书在&lt;em&gt;Let's Encrypt&lt;/em&gt;和&lt;em&gt;Amazon Web Services&lt;/em&gt;变得越来越便宜. 二者都提供有限用途的免费证书. 在本章, 我们将讨论如何确保NGINX和客户端之间, 以及NGINX和upstream之间的信息安全.&lt;/p&gt;
&lt;h3 id="231"&gt;2.3.1 客户端加密&lt;a class="headerlink" href="#231" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;需要加密NGINX和客户端之间的流量.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用SSL模块, 如&lt;code&gt;ngx_http_ssl_module&lt;/code&gt;或&lt;code&gt;ngx_stream_ssl_module&lt;/code&gt;来加密流量.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;All&lt;/span&gt; &lt;span class="err"&gt;directives&lt;/span&gt; &lt;span class="err"&gt;used&lt;/span&gt; &lt;span class="err"&gt;below&lt;/span&gt; &lt;span class="err"&gt;are&lt;/span&gt; &lt;span class="err"&gt;also&lt;/span&gt; &lt;span class="err"&gt;valid&lt;/span&gt; &lt;span class="err"&gt;in&lt;/span&gt; &lt;span class="err"&gt;stream&lt;/span&gt;
    &lt;span class="err"&gt;server&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="err"&gt;listen&lt;/span&gt; &lt;span class="err"&gt;8083&lt;/span&gt; &lt;span class="err"&gt;ssl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="err"&gt;ssl_protocols&lt;/span&gt;       &lt;span class="err"&gt;TLSv1.2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;协议&lt;/span&gt;
        &lt;span class="err"&gt;ssl_ciphers&lt;/span&gt;         &lt;span class="n"&gt;AES128-SHA&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;AES256-SHA&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;密码套件&lt;/span&gt;
        &lt;span class="err"&gt;ssl_certificate&lt;/span&gt;     &lt;span class="err"&gt;/usr/local/nginx/conf/cert.pem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;证书&lt;/span&gt;
        &lt;span class="err"&gt;ssl_certificate_key&lt;/span&gt; &lt;span class="err"&gt;/usr/local/nginx/conf/cert.key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;密钥&lt;/span&gt;
        &lt;span class="err"&gt;ssl_session_cache&lt;/span&gt;   &lt;span class="n"&gt;shared&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;SSL&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;ssl会话缓存&lt;/span&gt;
        &lt;span class="err"&gt;ssl_session_timeout&lt;/span&gt; &lt;span class="err"&gt;10m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;ssl会话超时&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;不要使用SSL(Secure Socket Layer)协议, 1 - 3版都被认为不安全&lt;/li&gt;
&lt;li&gt;TLS是默认的协议(Transport Layer Security), TLS还算安全.&lt;/li&gt;
&lt;li&gt;当使用签名证书, 你需要把证书和证书认证链连接到一块. 你的证书应该在证书链文件的上方.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSL会话缓存, 缓存后无需negotiate 版本和密码套件, 可以提升性能.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="232-upstream"&gt;2.3.2 Upstream 加密&lt;a class="headerlink" href="#232-upstream" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;为了合规, 或者你的upstream在你的安全网络之外, 你需要加密NGINX和upstream之间的流量.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用HTTP 代理模块的SSL指令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;upstream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;proxy_ssl_verify&lt;/span&gt; &lt;span class="err"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;proxy_ssl_verify_depth&lt;/span&gt; &lt;span class="err"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;proxy_ssl_protocols&lt;/span&gt; &lt;span class="err"&gt;TLSv1.2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;配置的指令确保NGINX在upsteam上验证证书和证书链2层认证深度是合法的. 默认NGINX&lt;strong&gt;不验证&lt;/strong&gt;upstream证书, 接收所有TLS版本.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;如果要加密upstream 流量, 你至少应该开启验证.&lt;/li&gt;
&lt;li&gt;其他可用指令, 如&lt;code&gt;proxy_ssl_certificate&lt;/code&gt;和&lt;code&gt;proxy_ssl_certificate_key&lt;/code&gt;, 允许你锁定upstream加密以增强安全性.&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:08:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-2-3-encrypt.html</guid><category>nginx</category><category>安全</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-安全-HTTP 基本认证</title><link>https://www.EWhisper.cn/nginx-handbook-2-4-http-basic-auth.html</link><description>&lt;h2 id="24-http"&gt;2.4 HTTP基本认证&lt;a class="headerlink" href="#24-http" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="240"&gt;2.4.0 介绍&lt;a class="headerlink" href="#240" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;基本认证是一个保护私有内容的简单方法. 这个认证方法可以很容易的用于隐藏&lt;strong&gt;开发网站&lt;/strong&gt;或者隐藏特权的内容. 推荐在需要基本认证的locations或servers上设置一个速率限制来组织暴力攻击. 也推荐如上章那样, 使用HTTPS, 因为每个认证请求, 用户名和密码是通过base64加密字符串, 作为一个header发送到server的. 如果使用HTTP, 意味着用户名和密码都可以被捕获.&lt;/p&gt;
&lt;h3 id="241-user-file"&gt;2.4.1 创建一个User File&lt;a class="headerlink" href="#241-user-file" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要一个HTTP基本认证用户文件来存储用户名和密码.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;生成一个下列格式的文件, 密码可以通过以下允许的格式来加密或哈希:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# comment
name1:password1
name2:password2:comment
name3:password3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;NGINX可以理解几种格式的密码, 其中一种加密是用C函数&lt;code&gt;crypt()&lt;/code&gt;. 该函数被暴露给&lt;code&gt;openssl passwd&lt;/code&gt;命令, 可以用如下方式生成加密字符串:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ openssl passwd MyPassword1234&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;会输出一个字符串, NGINX可以用在密码文件里.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;也可以用Apache的&lt;code&gt;htpasswd&lt;/code&gt;来生成密码. &lt;code&gt;htpasswd&lt;/code&gt;和&lt;code&gt;openssl&lt;/code&gt; 都会生成&lt;em&gt;apr1&lt;/em&gt; 算法的密码. 密码也可以用LDAP和Dovecot使用的加盐sha-1 格式. NGINX支持更多的格式和哈希算法, 但是, 大部分都被认为不安全, 因为可以被轻易破解.&lt;/p&gt;
&lt;h3 id="242"&gt;2.4.2 使用基本认证&lt;a class="headerlink" href="#242" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要用基本认证来保护NGINX location或server.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;location / {
    auth_basic          &amp;quot;Private site&amp;quot;;
    auth_basic_user_file conf.d/passwd;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;auth_basic&lt;/code&gt;指令可以用于HTTP, server, 或location块里. 当未认证用户访问, &lt;code&gt;auth_basic&lt;/code&gt;指令会把字符串显示到基本认证的弹出窗口.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;基本认证通过server返回一个带有&lt;code&gt;WWW-Authenticate&lt;/code&gt;的401未认证HTTP code. 该header会有一个值&lt;code&gt;Basic realm="your string."&lt;/code&gt;. 该响应会导致浏览器提示输入用户名和密码. 输入的用户名和密码会通过base64加密, 通过一个叫做&lt;code&gt;Authorization&lt;/code&gt;的请求头发送. Server会机密密码, 并根据&lt;code&gt;auth_basic_user_file&lt;/code&gt;提供的密码做验证. 因为用户名密码仅仅是通过base64加密. 所以推荐使用HTTPS传输.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:08:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-2-4-http-basic-auth.html</guid><category>nginx</category><category>安全</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-安全-限制使用</title><link>https://www.EWhisper.cn/nginx-handbook-2-2-limit-usage.html</link><description>&lt;h2 id="22"&gt;2.2 限制使用&lt;a class="headerlink" href="#22" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="220"&gt;2.2.0 介绍&lt;a class="headerlink" href="#220" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;该章节关注于: 限制使用和滥用, 连接数, 请求服务速率, 带宽使用量. 区分开连接和请求是很重要的: 连接(TCP连接)是网络层, 在这层上, 请求被执行, 因此两者并不一样.&lt;/p&gt;
&lt;p&gt;在HTTP/1和HTTP/1.1中, 一个连接请求只能使用一次; 而在HTTP/2中, 多个请求可以使用同一个TCP连接.&lt;/p&gt;
&lt;h3 id="221"&gt;2.2.1 限制连接&lt;a class="headerlink" href="#221" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要基于预定义的key来限制连接数, 比如key是客户端IP地址.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;创建一个共享内存区域来存放连接metrics, 并使用&lt;code&gt;limit_conn&lt;/code&gt; 指令来限制打开的连接数:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kn"&gt;limit_conn_zone&lt;/span&gt; &lt;span class="nv"&gt;$binary_remote_addr&lt;/span&gt; &lt;span class="s"&gt;zone=limitbyaddr:10m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kn"&gt;limit_conn_status&lt;/span&gt; &lt;span class="mi"&gt;429&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kn"&gt;...&lt;/span&gt;
  &lt;span class="s"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;...&lt;/span&gt;
      &lt;span class="s"&gt;limit_conn&lt;/span&gt; &lt;span class="s"&gt;limitbyaddr&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;...&lt;/span&gt;
  &lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;img align="absmiddle" alt="✔" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2714.png" title=":heavy_check_mark:" width="20px"&gt;  &lt;/p&gt;
&lt;p&gt;429: Too Many Requests&lt;/p&gt;
&lt;p&gt;预定义的key用的是:二进制格式的客户端IP地址.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;使用IP地址, 就像上个例子中那样, 如果很多用户都在同一个网络来自同一个IP可能很危险, 比如用的是一个NAT(网络地址转换). 整个组都会被限制. &lt;code&gt;limit_conn_zone&lt;/code&gt;指令只适用于HTTP块. 可以利用在HTTP块中的NGINX的任何变量来构建一个字符串来限制. 利用变量可以在应用级别识别具体的用户, 像是session cookie, 基于使用案例可能是一个更干净的解决方案. &lt;code&gt;limit_conn&lt;/code&gt;和&lt;code&gt;limit_conn_status&lt;/code&gt;指令在HTTP, server, 和location块中都能用. &lt;code&gt;limit_conn_status&lt;/code&gt;默认是503, 服务不可用. 429会更合适, 因为500界别的服务不可用意味着错误.&lt;/p&gt;
&lt;h3 id="222"&gt;2.2.2 限制速率&lt;a class="headerlink" href="#222" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要基于预定义的key来限制请求速率, 比如客户端IP地址.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;利用速率限制模块来限制:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kn"&gt;limit_req_zone&lt;/span&gt; &lt;span class="nv"&gt;$binary_remote_addr&lt;/span&gt; &lt;span class="s"&gt;zone=limitbyaddr:10m&lt;/span&gt; &lt;span class="s"&gt;rate=1r/s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kn"&gt;limit_req_status&lt;/span&gt; &lt;span class="mi"&gt;429&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kn"&gt;...&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kn"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;...&lt;/span&gt;
      &lt;span class="s"&gt;limit_req&lt;/span&gt; &lt;span class="s"&gt;zone=limitbyaddr&lt;/span&gt; &lt;span class="s"&gt;burst=10&lt;/span&gt; &lt;span class="s"&gt;nodelay&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;...&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个zone用关键字参数设置了速率. &lt;code&gt;limit_req&lt;/code&gt;指令有2个关键字参数: &lt;code&gt;zone&lt;/code&gt;和&lt;code&gt;burst&lt;/code&gt;. 当给定zone的请求速率超出了, 请求会延迟直到达到他们的最大burst size, 这个由&lt;code&gt;burst&lt;/code&gt;关键字参数提供. 默认&lt;code&gt;burst&lt;/code&gt;关键字参数为0. &lt;code&gt;limit_req&lt;/code&gt;也有第三个可选的参数, &lt;code&gt;nodelay&lt;/code&gt;. 这个参数允许客户端在被限制之前使用它的&lt;code&gt;burst&lt;/code&gt;而不用延迟. &lt;code&gt;limit_req_status&lt;/code&gt; 和&lt;code&gt;limit_req&lt;/code&gt; 可以用在HTTP, server, 和location. &lt;code&gt;limit_req_zone&lt;/code&gt;只适用于HTTP块.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;速率限制模块在组织恶意请求, 同时仍为每个人提供一定质量的服务时非常有用. 有很多限制请求速率的原因, 其中之一就是安全. 你可以通过在你的登陆页面设置非常严格的限制来防止恶意攻击. 你可以通过设置对所有请求的完善的限制来阻止恶意用户尝试对你的应用使用拒绝式服务攻击或浪费资源的计划. 速率限制模块的配置和2.2.1中的很类似. 速率可以被设置为每秒多少请求或每分钟多少请求. 当超过限制, 会记录事件日志. 例子中没有提到这个指令&lt;code&gt;limit_req_log_level&lt;/code&gt; , 默认是&lt;code&gt;error&lt;/code&gt;, 但是也可以设置为&lt;code&gt;info&lt;/code&gt; , &lt;code&gt;notice&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="223"&gt;2.2.3 限制带宽&lt;a class="headerlink" href="#223" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;待补充&lt;/p&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:05:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-2-2-limit-usage.html</guid><category>nginx</category><category>安全</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-安全-访问控制</title><link>https://www.EWhisper.cn/nginx-handbook-2-1-control-access.html</link><description>&lt;h2 id="211"&gt;2.1.1 介绍&lt;a class="headerlink" href="#211" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;控制你的web应用或你的web应用的子网的访问是很重要的业务. 在NGINX中, 访问控制有多种形式, 像是在网络层拒绝掉, 基于认证策略的允许, 或 HTTP指令浏览器如何响应. 本章我们将讨论基于网络属性, 认证和如何防止&lt;em&gt;跨域资源共享(Cross-Origin Resource Sharing(CORS))&lt;/em&gt;的访问控制.&lt;/p&gt;
&lt;h2 id="212-ip"&gt;2.1.2 基于IP地址的访问&lt;a class="headerlink" href="#212-ip" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="_1"&gt;问题&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;你需要基于客户端的IP地址的控制.&lt;/p&gt;
&lt;h3 id="_2"&gt;解决方案&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;使用HTTP访问模块来控制对受保护资源的访问:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="err"&gt;deny&lt;/span&gt; &lt;span class="err"&gt;10.0.0.1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="err"&gt;allow&lt;/span&gt; &lt;span class="err"&gt;10.0.0.0/20&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="err"&gt;allow&lt;/span&gt; &lt;span class="err"&gt;2001:0&lt;/span&gt;&lt;span class="n"&gt;db8&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:/&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="err"&gt;deny&lt;/span&gt; &lt;span class="err"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在HTTP, server, 和location上下文中, &lt;code&gt;allow&lt;/code&gt;和&lt;code&gt;deny&lt;/code&gt;指令提供对给出的client, IP, CIDR range, Unix socket, 或all 关键字的允许和禁止访问的能力. 规则被依次检查, 直到发现匹配的地址.&lt;/p&gt;
&lt;h3 id="_3"&gt;讨论&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;保护在互联网上的有价值的资源和服务必须在对应的层上做. NGINX提供对其中一些层的能力. &lt;code&gt;deny&lt;/code&gt; 指令组织访问给定的上下文, &lt;code&gt;allow&lt;/code&gt;指令可以用于限制访问. 你可以使用IP地址, IPv4或IPv6, CIDR block ranges, 关键字&lt;code&gt;all&lt;/code&gt;, 和Unix socket. 通常要保护某个资源, 应该允许特定区域的内网IP地址, 并拒绝所有.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-2-1-control-access.html</guid><category>nginx</category><category>安全</category><category>译文</category><category>最佳实践</category></item><item><title>Oracle WebLogic Server 11.1.1.9发布说明</title><link>https://www.EWhisper.cn/oracle-webLogic-server-11.1.1.9-release-notes.html</link><description>&lt;p&gt;&lt;a href="https://docs.oracle.com/middleware/11119/wls/WLSRN/issues.htm#WLSRN114"&gt;参照链接&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="oracle-weblogic-server"&gt;Oracle WebLogic Server问题&lt;a class="headerlink" href="#oracle-weblogic-server" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;本章节描述了Oracle WebLogic Server相关的问题。它包含以下主题。&lt;br&gt;
一般性问题和解决办法&lt;br&gt;
管理控制台问题和解决办法&lt;br&gt;
Apache Beehive支持问题和解决办法&lt;br&gt;
集群问题和解决办法&lt;br&gt;
配置问题和解决办法&lt;br&gt;
连接器（资源适配器）问题和解决办法&lt;br&gt;
控制台扩展问题和解决办法&lt;br&gt;
核心服务器和核心工作管理器问题和解决办法&lt;br&gt;
部署问题和解决办法&lt;br&gt;
EJB问题和解决办法&lt;br&gt;
示例问题和解决办法&lt;br&gt;
HTTP问题发布/订阅服务器问题和解决办法&lt;br&gt;
安装问题和解决办法&lt;br&gt;
JavaEE问题和解决办法&lt;br&gt;
JDBC问题和解决办法&lt;br&gt;
JMS问题和解决办法&lt;br&gt;
JBDI问题和解决办法&lt;br&gt;
JSP和Servlet问题和解决办法&lt;br&gt;
JTA问题和解决办法&lt;br&gt;
Java虚拟机（JVM）和解决办法&lt;br&gt;
监测问题和解决办法&lt;br&gt;
节点管理器问题和解决办法&lt;br&gt;
操作、管理和受管理问题及解决办法&lt;br&gt;
Oracle Kodo问题和解决办法&lt;br&gt;
插件问题和解决办法&lt;br&gt;
协议问题和解决办法&lt;br&gt;
RMI-IIOP问题和解决办法&lt;br&gt;
安全问题和解决办法&lt;br&gt;
SNMP问题和解决办法&lt;br&gt;
WebLogic Server上Spring框架的问题和解决办法&lt;br&gt;
系统组件体系解救（SCA）问题和解决办法&lt;br&gt;
升级问题和解决办法&lt;br&gt;
Web应用程序问题和解决办法&lt;br&gt;
WebLogic Server脚本工具（WLST）问题及解决办法&lt;br&gt;
!!!&lt;br&gt;
Web服务器插件问题和解决方法&lt;br&gt;
Web服务和XML问题及解决办法&lt;br&gt;
文件 Errata&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;注：&lt;br&gt;
获取WebLogic Server 11g（10.3.6）修复的Bug列表，请在直属库字段中输入以下文档ID 1302753.1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_1"&gt;一般性问题和解决办法&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;本章节介绍以下问题和解决办法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Safari时，多字节字符在文件名中显示错误&lt;/li&gt;
&lt;li&gt;Oracle WebLogic的版本号&lt;/li&gt;
&lt;li&gt;Oracle ojdbc14.jar文件更改为ojdbc6.jar&lt;/li&gt;
&lt;li&gt;强密码强制执行可能导致WLST离线脚本出现问题&lt;/li&gt;
&lt;li&gt;在土耳其地区，mds初始化失败&lt;/li&gt;
&lt;li&gt;管理服务器在EM控制台上报告“太多打开文件”消息&lt;/li&gt;
&lt;li&gt;适用于10.3.5.0 Oracle WLS通用安装的Sun JDK 6 U35-B52的可用性。&lt;/li&gt;
&lt;li&gt;IBM JDK SR16 FP3或 JDK 7.0 SR8 FP10修复程序的可用性&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;使用Safari时，多字节字符在文件名中显示错误&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;平台：&lt;/strong&gt; 全部&lt;br&gt;
当使用Safari浏览器下载内容时，如果文件名包含多字节字符，则这些字符在文件中显示为乱码&lt;br&gt;
&lt;strong&gt;解决方案&lt;/strong&gt;&lt;br&gt;
在受管服务器上设置&lt;code&gt;UserHeaderEncoding&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; .&lt;br&gt;
使用如下WLST命令实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;connect(&amp;quot;admin_name&amp;quot;, &amp;quot;admin_password&amp;quot;, &amp;quot;t3://localhost:port&amp;quot;)
edit()
startEdit()
cd(&amp;quot;Servers/server_name/WebServer/server_name&amp;quot;)
set(&amp;quot;UseHeaderEncoding&amp;quot;, &amp;quot;true&amp;quot;)
save()
activate()
exit()
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;Oracle WebLogic Server 版本号&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;平台：&lt;/strong&gt; 全部&lt;br&gt;
Oracle融合中间件11g包含Oracle WebLogic Server 11g. Oracle WebLogic Server版本为10.3.6.&lt;/p&gt;
&lt;h4&gt;Oracle ojdbc14.jar文件更改为ojdbc6.jar&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;平台：&lt;/strong&gt; 全部&lt;br&gt;
Oracle ojdbc14.jar 更改为为ojdbc6.jar，使用JDK 5或者JDK 6，因此，您对ojdbc14.jar的任何显示引用都必须更改为ojdbc6.jar&lt;/p&gt;
&lt;h4&gt;强密码强制执行可能导致WLST离线脚本出现问题&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;平台：&lt;/strong&gt; 全部&lt;br&gt;
在此版本的WebLogic Server中实施强密码实施（最少8个字符，带有一个数字或特殊字符），现有脚本可能遇到问题。&lt;br&gt;
&lt;strong&gt;解决方案&lt;/strong&gt;&lt;br&gt;
&lt;em&gt; 将&lt;code&gt;ACKWARD_COMPAT_PW_CHECK&lt;/code&gt;境变量设置为&lt;code&gt;ture&lt;/code&gt;.&lt;br&gt;
&lt;/em&gt; 使用WLST时，引用参数&lt;code&gt;-Dbackward.compat.pw.check=true&lt;/code&gt;&lt;br&gt;
&amp;lt;未完待续&amp;gt;&lt;br&gt;
Oracle建议您更改密码以复核新的密码要求，因为此变量和选项将在未来的WebLogic Server版本中删除。&lt;/p&gt;
&lt;h4&gt;在土耳其地区，mds初始化失败&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;平台：&lt;/strong&gt; 全部&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">HelloWorDomain</dc:creator><pubDate>Thu, 14 Mar 2019 22:06:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-03-14:/oracle-webLogic-server-11.1.1.9-release-notes.html</guid><category>WebLogic</category><category>译文</category><category>java</category></item></channel></rss>