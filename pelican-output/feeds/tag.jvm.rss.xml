<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>东风微鸣 Blog - jvm</title><link>https://www.EWhisper.cn/</link><description>Focus on Python/Java/DevOps/Observability</description><lastBuildDate>Tue, 12 Mar 2019 10:48:00 +0800</lastBuildDate><item><title>8种Java 内存溢出之一:Java Heap Space</title><link>https://www.EWhisper.cn/java-oom-1-java-heap-space.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#11-javalangoutofmemoryerror-java-heap-space"&gt;1.1  java.lang.OutOfMemoryError: Java heap space 概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#12"&gt;1.2 原因&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#13"&gt;1.3 示例&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#131-1"&gt;1.3.1 示例1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#132"&gt;1.3.2 内存泄漏示例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#14"&gt;1.4 解决方案&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="11-javalangoutofmemoryerror-java-heap-space"&gt;1.1  java.lang.OutOfMemoryError: Java heap space 概述&lt;a class="headerlink" href="#11-javalangoutofmemoryerror-java-heap-space" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Java 应用只允许使用有限的内存。这个限制是在应用启动的时候指定的。展开来说， Java内存分成2个不同的区域。这两个区域叫做Heap Space （堆内存）和 Permgen （Permanent Generation，即永久代）。&lt;/p&gt;
&lt;p&gt;&lt;img alt="java内存结构" src="https://www.EWhisper.cn/images/java_memory.png"&gt;&lt;/p&gt;
&lt;p&gt;这两个区的大小是在JVM启动的时候设置, 可以通过JVM参数&lt;code&gt;-Xmx&lt;/code&gt; 和 &lt;code&gt;-XX:MaxPermSize&lt;/code&gt;进行设置. 如果你没欧进行特别的设置, &lt;strong&gt;平台指定&lt;/strong&gt;的默认配置会被使用.
&lt;code&gt;java.lang.OutOfMemoryError: Java heap space&lt;/code&gt; 错误会在应用尝试添加更多的数据到heap space, 但是heap区没有足够的空间时触发.&lt;/p&gt;
&lt;p&gt;需要注意的是即使&lt;strong&gt;物理内存&lt;/strong&gt;可能有很多剩余, 但是只要JVM达到了heap size的限制, 就会抛出该错误.&lt;/p&gt;
&lt;h2 id="12"&gt;1.2 原因&lt;a class="headerlink" href="#12" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;对于 &lt;code&gt;java.lang.OutOfMemoryError: Java heap space&lt;/code&gt; , 最常见的原因很简单 -- 你把一个XXL号的应用放到了一个S号的Java heap space里了. 也就是说 -- 应用需要更多的Java heap space 来让它正常运行. 对于这个OutOfMemory, 其他的原因会更复杂, 通常是由于编程错误引起的:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;用户/数据量出现峰值&lt;/strong&gt; 该应用被设计来处理一定数量的用户和一定数量的数据. 当用户数或数据量突然冲高, 并且超过了期望的阈值, 在出现峰值停止之前的正常运行时的操作触发了 &lt;code&gt;java.lang.OutOfMemoryError: Java heap space&lt;/code&gt; 错误.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;内存泄漏&lt;/strong&gt; 一种特定类型的编程错误导致应用频繁消耗更多的内存. 每当应用的泄漏的功能被使用时, 它就会在Java heap space种生成一些对象. 随着时间推移, 泄漏的对象消耗了所有可用的Java heap space, 并且触发了常见的&lt;code&gt;java.lang.OutOfMemoryError: Java heap space&lt;/code&gt;  错误.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="13"&gt;1.3 示例&lt;a class="headerlink" href="#13" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="131-1"&gt;1.3.1 示例1&lt;a class="headerlink" href="#131-1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;第一个例子相当简单 -- 下列的Java 代码尝试分配200万个(2M) 整数数组. 当你编译该代码, 用一个12MB大小的Java heap space (&lt;code&gt;java -Xmx12m OOM&lt;/code&gt;)运行. 它会运行失败, 抛出 &lt;code&gt;java.lang.OutOfMemoryError: Java heap space&lt;/code&gt;  消息. 有13MB Java heap space, 这个程序就能正常运行...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;OOM&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="n"&gt;SIZE&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="132"&gt;1.3.2 内存泄漏示例&lt;a class="headerlink" href="#132" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;第二个, 更现实一点的例子是内存泄漏. 在Java里, 当开发创建和使用新对象, 如: &lt;code&gt;new Integer(5)&lt;/code&gt;, 他们不必自己分派内存 -- 这通过JVM来处理. 在应用生命周期种, JVM会周期性地检查内存中的哪个对象仍在使用, 哪个没有. 没有被使用的对象会被丢弃, 然后内存重新声明并重新使用. 这个过程叫做&lt;strong&gt;垃圾回收&lt;/strong&gt;. 对应的JVM里的模块叫做&lt;strong&gt;垃圾收集器&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;Java的自动内存管理机制以来与GC来周期性地查找没用的对象并移除他们. 简而言之, Java内存泄漏是这么一种场景, 一些对象应用已经不用了, 但是GC却没有检查出来. 结果就是这些没用的对象仍然无限期地存在在Java heap space 中. 如此往复, 最终触发&lt;code&gt;java.lang.OutOfMemoryError: Java heap space&lt;/code&gt;错误.&lt;/p&gt;
&lt;p&gt;构造一个满足内存泄漏定义的Java程序也相当容易:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;KeylessEntry&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Key&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Integer&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Integer&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;id&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="nf"&gt;hashCode&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;id&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hashCode&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Map&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;HashMap&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
      &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="mi"&gt;10000&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(!&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;containsKey&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;)))&lt;/span&gt;
          &lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;put&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Nmber:&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当执行上面的代码时，您可能期望它永远运行而没有任何问题，假设原始缓存解决方案只将Map扩展到10,000个元素，除此之外，HashMap中已经包含了所有键. 然而, 事实上元素会持续增加因为Key这个类没有在它的&lt;code&gt;hashCode()&lt;/code&gt;种包含一个适当的&lt;code&gt;equals()&lt;/code&gt;实现.&lt;/p&gt;
&lt;p&gt;结果, 随着时间推移, 因为泄漏代码的不断的使用, "缓存"的结果会消耗大量的Java heap space. 当泄漏的内存填满了heap区的所有的可用内存, 并且垃圾收集器无法清理, 会抛出&lt;code&gt;java.lang.OutOfMemoryError: Java heap space&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;解决办法也简单 -- 添加个&lt;code&gt;equals()&lt;/code&gt;方法的实现在下边, 就能很好的运行了. 但是在你最终找到这个bug之前, 你会西欧爱好相当多的脑细胞.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@Override&lt;/span&gt;
&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt; &lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt; &lt;span class="k"&gt;instanceof&lt;/span&gt; &lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;response&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;(((&lt;/span&gt;&lt;span class="n"&gt;Key&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="n"&gt;o&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;id&lt;/span&gt;&lt;span class="o"&gt;).&lt;/span&gt;&lt;span class="na"&gt;equals&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;id&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2 id="14"&gt;1.4 解决方案&lt;a class="headerlink" href="#14" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;显然第一个解决方案就是 -- 当你的JVM特定资源耗尽了, 你应该增加那个资源的量. 在这个案例种: 当你的应用没有足够的Java heap space内存来正常运行, 只需要在运行JVM的时候配置并添加(或修改现有的)如下参数:
&lt;code&gt;-Xmx1024m&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;上述配置会给应用1024M的Java heap space. 你可以使用&lt;code&gt;g&lt;/code&gt;或者&lt;code&gt;G&lt;/code&gt;(单位是GB), &lt;code&gt;m&lt;/code&gt;或&lt;code&gt;M&lt;/code&gt;(MB), &lt;code&gt;k&lt;/code&gt;或&lt;code&gt;K&lt;/code&gt;(KB). 例如下列都是设置最大Java heap space为1GB:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;java -Xmx1073741824 com.mycompany.MyClass
java -Xmx1048576k com.mycompany.MyClass
java -Xmx1024m com.mycompany.MyClass
java -Xmx1g com.mycompany.MyClass
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然而, 在很多案例种, 提供更多的Java heap space只是饮鸩止渴. 例如, 如果你的应用存在内存泄漏, 添加更多的heap只是延缓&lt;code&gt;java.lang.OutOfMemoryError: Java heap space&lt;/code&gt;错误的出现, 并不能解决问题. 另外, 增加Java heap space也会导致GC暂停时间的增加, 从而影响你的应用的&lt;a href="https://plumbr.eu/blog/gc-impact-on-throughput-and-latency"&gt;吞吐量和延迟&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;如果你希望解决潜在的问题, 而不是头痛医头, 联系我就是最好的方式(＠￣ー￣＠). 当然, 有几个工具适合你. &lt;strong&gt;Debuggers&lt;/strong&gt;, &lt;strong&gt;profiles&lt;/strong&gt;, &lt;strong&gt;heap dump analyzers&lt;/strong&gt; -- 供你选择.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;题外话:
Dynatrace 也是个分析OOM问题的好工具.感兴趣的可以参考这篇文章:
《案例: Dynatrace分析某财险承保系统内存泄漏问题》&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;喜欢我的博客吗? 打赏一杯&lt;img align="absmiddle" alt="☕" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2615.png" title=":coffee:" width="20px"&gt;吧。您的支持是对我的最大鼓励～ 另外记得给我留言或订阅哦 &lt;img align="absmiddle" alt="🎉" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f389.png" title=":tada:" width="20px"&gt;&lt;img align="absmiddle" alt="🎉" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f389.png" title=":tada:" width="20px"&gt;&lt;img align="absmiddle" alt="🎉" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f389.png" title=":tada:" width="20px"&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;a href="https://www.EWhisper.cn/pages/about.html"&gt;点击这里打赏&lt;img align="absmiddle" alt="👉" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f449.png" title=":point_right:" width="20px"&gt;&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Tue, 12 Mar 2019 10:48:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-03-12:/java-oom-1-java-heap-space.html</guid><category>jvm</category><category>java</category><category>oom</category></item></channel></rss>