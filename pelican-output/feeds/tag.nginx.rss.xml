<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"><channel><title>东风微鸣 Blog - nginx</title><link>https://www.EWhisper.cn/</link><description>Focus on Python/Java/DevOps/Observability</description><lastBuildDate>Sun, 23 Jun 2019 17:08:00 +0800</lastBuildDate><item><title>NGINX 学习笔记-Gzip压缩-`ngx_http_gunzip_module`</title><link>https://www.EWhisper.cn/nginx-notebook-3-3-gunzip-module.html</link><description>&lt;h2 id="3-ngx_http_gunzip_module"&gt;3 ngx_http_gunzip_module&lt;a class="headerlink" href="#3-ngx_http_gunzip_module" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;如果客户端本身不支持解压Gzip, 就需要Nginx服务器在向其发送数据前先将该数据解压. 这些压缩数据可能来自于后端服务器压缩产生或Nginx服务器预压缩产生.&lt;/p&gt;
&lt;p&gt;该模块不是默认构建的，应该使用 &lt;code&gt;--with-http_gunzip_module&lt;/code&gt; 配置参数启用。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Sun, 23 Jun 2019 17:08:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-23:/nginx-notebook-3-3-gunzip-module.html</guid><category>nginx</category><category>最佳实践</category></item><item><title>NGINX 学习笔记-Gzip压缩-Gzip压缩功能的使用</title><link>https://www.EWhisper.cn/nginx-notebook-3-4-gzip-howto.html</link><description>&lt;h2 id="4-gzip"&gt;4 Gzip压缩功能的使用&lt;a class="headerlink" href="#4-gzip" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="gzip"&gt;Gzip压缩功能综合配置示例&lt;a class="headerlink" href="#gzip" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;gzip&lt;/span&gt; &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;gzip_min_length&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;gzip_buffers&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="mi"&gt;4k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;gzip_comp_level&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;gzip_types&lt;/span&gt; &lt;span class="s"&gt;text/plain&lt;/span&gt; &lt;span class="s"&gt;application/x-javascript&lt;/span&gt; &lt;span class="s"&gt;text/css&lt;/span&gt; &lt;span class="s"&gt;application/xml&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;gzip_vary&lt;/span&gt; &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;gunzip_static&lt;/span&gt; &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="gzip-ie6"&gt;Gzip 压缩功能与IE6浏览器运行脚本的兼容问题&lt;a class="headerlink" href="#gzip-ie6" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;gzip_disable&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;MSIE&lt;/span&gt; &lt;span class="s"&gt;[1-6]\.&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="nginxgzip"&gt;Nginx与其他服务器交互时产生的Gzip压缩功能相关问题&lt;a class="headerlink" href="#nginxgzip" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;两类问题:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多层服务器同时开启Gzip压缩功能导致;&lt;/li&gt;
&lt;li&gt;多层服务器之间对Gzip压缩功能支持能力不同导致.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Nginx与后端服务器(如Tomcat)同时开启Gzip压缩功能对JavaScript脚本进行压缩, 在大多数浏览器中刷新页面会导致脚本运行发生异常, 唯一可以运行的浏览器是Chrome.&lt;/p&gt;
&lt;p&gt;解决办法:&lt;strong&gt;对于包含多层服务器的系统来说, Nginx服务器作为前端服务器如果开启了Gzip压缩功能, 后端服务器最好就不要再开启了.&lt;/strong&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Sun, 23 Jun 2019 17:08:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-23:/nginx-notebook-3-4-gzip-howto.html</guid><category>nginx</category><category>最佳实践</category></item><item><title>NGINX 学习笔记-Gzip压缩-`ngx_http_gzip_static_module`</title><link>https://www.EWhisper.cn/nginx-notebook-3-2-gzip-static-module.html</link><description>&lt;h2 id="2-ngx_http_gzip_static_module"&gt;2 ngx_http_gzip_static_module&lt;a class="headerlink" href="#2-ngx_http_gzip_static_module" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;该模块不是默认构建的，它应该使用 &lt;code&gt;--with-http_gzip_static_module&lt;/code&gt; 配置参数启用。&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Sun, 23 Jun 2019 17:05:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-23:/nginx-notebook-3-2-gzip-static-module.html</guid><category>nginx</category><category>最佳实践</category></item><item><title>NGINX 学习笔记-高级配置-事件驱动模型相关的配置指令</title><link>https://www.EWhisper.cn/nginx-notebook-2-4-events-directives.html</link><description>&lt;h2 id="4"&gt;4 事件驱动模型相关的配置指令&lt;a class="headerlink" href="#4" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;use&lt;/code&gt;(指定事件驱动模型)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;worker_connections&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用于设置Nginx服务器的&lt;strong&gt;每个工作进程&lt;/strong&gt;允许同时连接客户端的最大数量(包括前端用户连接也包括其他连接)&lt;/p&gt;
&lt;p&gt;Nginx服务器允许同时连接的客户端最大数量 &lt;code&gt;Client = worker_processes * worker_connections / 2&lt;/code&gt;&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;&lt;code&gt;worker_rlimit_sigpending&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;事件驱动模型rtsig可以保存的最大信号数.&lt;/p&gt;
&lt;ol start="4"&gt;
&lt;li&gt;&lt;code&gt;devpoll_changes&lt;/code&gt; &lt;code&gt;devpoll_events&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用于设置在&lt;code&gt;/dev/poll&lt;/code&gt;事件驱动模式下Nginx服务器与内核之间传递事件的数量.前者设置传递给内核的事件数量, 后者设置从内核获取的事件数量.&lt;/p&gt;
&lt;p&gt;默认值为32&lt;/p&gt;
&lt;ol start="5"&gt;
&lt;li&gt;&lt;code&gt;kqueue_changes&lt;/code&gt; 和 &lt;code&gt;kqueue_events&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;kqueue事件模型下. 默认值均为512&lt;/p&gt;
&lt;ol start="6"&gt;
&lt;li&gt;&lt;code&gt;epoll_events&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;epoll事件模型下, 从Nginx到内核, 从内核到Nginx相等. 默认值为512.&lt;/p&gt;
&lt;ol start="7"&gt;
&lt;li&gt;&lt;code&gt;rtsig_signo&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;rtsig模式. 默认第一个信号设置为SIGRTMIN+10&lt;/p&gt;
&lt;ol start="8"&gt;
&lt;li&gt;&lt;code&gt;rtsig_overflow_*&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img align="absmiddle" alt="📓" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f4d3.png" title=":notebook:" width="20px"&gt;备注:&lt;/p&gt;
&lt;p&gt;现在的Linux发行版一般推荐使用&lt;code&gt;epoll&lt;/code&gt;事件驱动模型&lt;/p&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Sun, 23 Jun 2019 16:33:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-23:/nginx-notebook-2-4-events-directives.html</guid><category>nginx</category><category>最佳实践</category></item><item><title>NGINX 学习笔记-Gzip压缩-`ngx_http_gzip_module`</title><link>https://www.EWhisper.cn/nginx-notebook-3-1-gzip-module.html</link><description>&lt;p&gt;本系列文章主要讨论与gzip 压缩相关的Nginx 指令.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;相关模块: &lt;code&gt;ngx_http_gzip_module ngx_http_gzip_static_module ngx_http_gunzip_module&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="1-ngx_http_gzip_module"&gt;1 ngx_http_gzip_module&lt;a class="headerlink" href="#1-ngx_http_gzip_module" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;gzip on | off&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gzip_buffers&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用于设置Gzip压缩文件使用缓存空间的大小.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gzip_buffers number size;    # number 缓存空间个数; size 每个空间大小&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;默认&lt;em&gt;number × size&lt;/em&gt; 为128. size的值推荐取系统内存页一页的大小, 为4KB 或者8KB. 即&lt;code&gt;gzip_buffers 32 4k | 16 8k&lt;/code&gt;&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;&lt;code&gt;gzip_comp_level&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;设定Gzip压缩程度, 包括1到9. 1压缩程度最低, 9最高. 默认为1.&lt;/p&gt;
&lt;ol start="4"&gt;
&lt;li&gt;&lt;code&gt;gzip_disable&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img align="absmiddle" alt="📓" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f4d3.png" title=":notebook:" width="20px"&gt;备注&lt;/p&gt;
&lt;p&gt;针对不同种类客户端发起的请求, 可以选择性地开启和关闭gzip功能.&lt;/p&gt;
&lt;p&gt;PC端：&lt;/p&gt;
&lt;p&gt;safari 5.1 – MAC&lt;/p&gt;
&lt;p&gt;User-Agent:Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10_6_8; en-us) AppleWebKit/534.50 &amp;gt; (KHTML, like Gecko) Version/5.1 Safari/534.50&lt;/p&gt;
&lt;p&gt;safari 5.1 – Windows&lt;/p&gt;
&lt;p&gt;User-Agent:Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, &amp;gt; like Gecko) Version/5.1 Safari/534.50&lt;/p&gt;
&lt;p&gt;IE 9.0&lt;/p&gt;
&lt;p&gt;User-Agent:Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0;&lt;/p&gt;
&lt;p&gt;IE 8.0&lt;/p&gt;
&lt;p&gt;User-Agent:Mozilla/4.0 (compatible; MSIE 8.0; Windows NT 6.0; Trident/4.0)&lt;/p&gt;
&lt;p&gt;IE 7.0&lt;/p&gt;
&lt;p&gt;User-Agent:Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)&lt;/p&gt;
&lt;p&gt;IE 6.0&lt;/p&gt;
&lt;p&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1)&lt;/p&gt;
&lt;p&gt;Firefox 4.0.1 – MAC&lt;/p&gt;
&lt;p&gt;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 &amp;gt; Firefox/4.0.1&lt;/p&gt;
&lt;p&gt;Firefox 4.0.1 – Windows&lt;/p&gt;
&lt;p&gt;User-Agent:Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1&lt;/p&gt;
&lt;p&gt;Opera 11.11 – MAC&lt;/p&gt;
&lt;p&gt;User-Agent:Opera/9.80 (Macintosh; Intel Mac OS X 10.6.8; U; en) Presto/2.8.131 Version/&amp;gt; 11.11&lt;/p&gt;
&lt;p&gt;Opera 11.11 – Windows&lt;/p&gt;
&lt;p&gt;User-Agent:Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11&lt;/p&gt;
&lt;p&gt;Chrome 17.0 – MAC&lt;/p&gt;
&lt;p&gt;User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, &amp;gt; like Gecko) Chrome/17.0.963.56 Safari/535.11&lt;/p&gt;
&lt;p&gt;傲游（Maxthon）&lt;/p&gt;
&lt;p&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0)&lt;/p&gt;
&lt;p&gt;腾讯TT&lt;/p&gt;
&lt;p&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; TencentTraveler 4.0)&lt;/p&gt;
&lt;p&gt;世界之窗（The World） 2.x&lt;/p&gt;
&lt;p&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)&lt;/p&gt;
&lt;p&gt;世界之窗（The World） 3.x&lt;/p&gt;
&lt;p&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; The World)&lt;/p&gt;
&lt;p&gt;搜狗浏览器 1.x&lt;/p&gt;
&lt;p&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SE 2.X &amp;gt; MetaSr 1.0; SE 2.X MetaSr 1.0; .NET CLR 2.0.50727; SE 2.X MetaSr 1.0)&lt;/p&gt;
&lt;p&gt;360浏览器&lt;/p&gt;
&lt;p&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)&lt;/p&gt;
&lt;p&gt;Avant&lt;/p&gt;
&lt;p&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Avant Browser)&lt;/p&gt;
&lt;p&gt;Green Browser&lt;/p&gt;
&lt;p&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1)&lt;/p&gt;
&lt;p&gt;移动设备端：&lt;/p&gt;
&lt;p&gt;safari iOS 4.33 – iPhone&lt;/p&gt;
&lt;p&gt;User-Agent:Mozilla/5.0 (iPhone; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) &amp;gt; AppleWebKit/533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5&lt;/p&gt;
&lt;p&gt;safari iOS 4.33 – iPod Touch&lt;/p&gt;
&lt;p&gt;User-Agent:Mozilla/5.0 (iPod; U; CPU iPhone OS 4_3_3 like Mac OS X; en-us) AppleWebKit/&amp;gt; 533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5&lt;/p&gt;
&lt;p&gt;safari iOS 4.33 – iPad&lt;/p&gt;
&lt;p&gt;User-Agent:Mozilla/5.0 (iPad; U; CPU OS 4_3_3 like Mac OS X; en-us) AppleWebKit/&amp;gt; 533.17.9 (KHTML, like Gecko) Version/5.0.2 Mobile/8J2 Safari/6533.18.5&lt;/p&gt;
&lt;p&gt;Android N1&lt;/p&gt;
&lt;p&gt;User-Agent: Mozilla/5.0 (Linux; U; Android 2.3.7; en-us; Nexus One Build/FRF91) &amp;gt; AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/533.1&lt;/p&gt;
&lt;p&gt;Android QQ浏览器 For android&lt;/p&gt;
&lt;p&gt;User-Agent: MQQBrowser/26 Mozilla/5.0 (Linux; U; Android 2.3.7; zh-cn; MB200 Build/&amp;gt; GRJ22; CyanogenMod-7) AppleWebKit/533.1 (KHTML, like Gecko) Version/4.0 Mobile Safari/&amp;gt; 533.1&lt;/p&gt;
&lt;p&gt;Android Opera Mobile&lt;/p&gt;
&lt;p&gt;User-Agent: Opera/9.80 (Android 2.3.4; Linux; Opera Mobi/build-1107180945; U; en-GB) &amp;gt; Presto/2.8.149 Version/11.10&lt;/p&gt;
&lt;p&gt;Android Pad Moto Xoom&lt;/p&gt;
&lt;p&gt;User-Agent: Mozilla/5.0 (Linux; U; Android 3.0; en-us; Xoom Build/HRI39) AppleWebKit/&amp;gt; 534.13 (KHTML, like Gecko) Version/4.0 Safari/534.13&lt;/p&gt;
&lt;p&gt;BlackBerry&lt;/p&gt;
&lt;p&gt;User-Agent: Mozilla/5.0 (BlackBerry; U; BlackBerry 9800; en) AppleWebKit/534.1+ (KHTML, &amp;gt; like Gecko) Version/6.0.0.337 Mobile Safari/534.1+&lt;/p&gt;
&lt;p&gt;WebOS HP Touchpad&lt;/p&gt;
&lt;p&gt;User-Agent: Mozilla/5.0 (hp-tablet; Linux; hpwOS/3.0.0; U; en-US) AppleWebKit/534.6 &amp;gt; (KHTML, like Gecko) wOSBrowser/233.70 Safari/534.6 TouchPad/1.0&lt;/p&gt;
&lt;p&gt;Nokia N97&lt;/p&gt;
&lt;p&gt;User-Agent: Mozilla/5.0 (SymbianOS/9.4; Series60/5.0 NokiaN97-1/20.0.019; Profile/&amp;gt; MIDP-2.1 Configuration/CLDC-1.1) AppleWebKit/525 (KHTML, like Gecko) BrowserNG/7.1.18124&lt;/p&gt;
&lt;p&gt;Windows Phone Mango&lt;/p&gt;
&lt;p&gt;User-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows Phone OS 7.5; Trident/5.0; &amp;gt; IEMobile/9.0; HTC; Titan)&lt;/p&gt;
&lt;p&gt;UC无&lt;/p&gt;
&lt;p&gt;User-Agent: UCWEB7.0.2.37/28/999&lt;/p&gt;
&lt;p&gt;UC标准&lt;/p&gt;
&lt;p&gt;User-Agent: NOKIA5700/ UCWEB7.0.2.37/28/999&lt;/p&gt;
&lt;p&gt;UCOpenwave&lt;/p&gt;
&lt;p&gt;User-Agent: Openwave/ UCWEB7.0.2.37/28/999&lt;/p&gt;
&lt;p&gt;UC Opera&lt;/p&gt;
&lt;p&gt;User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; ) Opera/UCWEB7.0.2.37/28/999&lt;br&gt;
&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gzip_disable MSIE [4-6]\.&lt;/code&gt;&lt;/p&gt;
&lt;ol start="5"&gt;
&lt;li&gt;&lt;code&gt;gzip_http_version&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;gzip_http_version 1.0 | 1.1&lt;/code&gt; 默认设置为1.1版本.即只有客户端使用1.1及以上版本的HTTP协议时, 才使用Gzip功能. 一般使用默认值.&lt;/p&gt;
&lt;ol start="6"&gt;
&lt;li&gt;&lt;code&gt;gzip_min_length&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果压缩很小的数据, 可能出现越压缩数据量越大的情况. 因此根据响应页面的大小, 选择性地开启或者关闭Gzip功能. 该指令设置页面的字节数. &lt;strong&gt;响应页面的大小通过HTTP响应头部中的Content-Length指令获取, 但是如果使用了Chunk 编码动态压缩, Content-Length或不存在或被忽略, 该指令不起作用&lt;/strong&gt;. 默认设置为20. 设置为0时统统压缩. 建议该值为&lt;strong&gt;1KB或以上&lt;/strong&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gzip_min_length 1024&lt;/code&gt;&lt;/p&gt;
&lt;ol start="7"&gt;
&lt;li&gt;&lt;code&gt;gzip_proxied&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;该指令在使用Nginx服务器的反向代理功能时有效, 前提是在后端服务器返回的响应页头部中, Requests 部分包含用于通知代理服务器的Via头域.  主要用于设置Nginx服务器是否对后端服务器返回的结果进行Gzip压缩.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Syntax&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;gzip_proxied&lt;/span&gt; &lt;span class="n"&gt;off&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;expired&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;no&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;cache&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;no&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;store&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt;&lt;span class="n"&gt;no_last_modified&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;no_etag&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;auth&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;any&lt;/span&gt; &lt;span class="o"&gt;...;&lt;/span&gt;
&lt;span class="n"&gt;Default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;gzip_proxied&lt;/span&gt; &lt;span class="n"&gt;off&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;location&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;off 关闭, 默认设置;&lt;/li&gt;
&lt;li&gt;expired 当后端服务器响应页头部包含用于支持响应数据过期事件的expired头域时, 启用Gzip.&lt;/li&gt;
&lt;li&gt;no-cache 当后端包含Cache-Control头域, 且其指令值为no-cache时, 启用.&lt;/li&gt;
&lt;li&gt;no-store 当后端包含Cache-Control头域, 且其指令值为no-store时, 启用.&lt;/li&gt;
&lt;li&gt;private 当后端包含Cache-Control头域, 且其指令值为private时, 启用.&lt;/li&gt;
&lt;li&gt;no_last_modified 当后端服务器响应头不包含用于指明需要获取数据最后修改时间的Last-Modified 域时, 启用.&lt;/li&gt;
&lt;li&gt;no_etag 不包含ETag时, 启用.&lt;/li&gt;
&lt;li&gt;auth 包含Authorization, 启用&lt;/li&gt;
&lt;li&gt;any 无条件启用压缩.&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start="8"&gt;
&lt;li&gt;&lt;code&gt;gzip_types&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;根据响应页的MIME类型选择性地开启Gzip压缩功能.  默认为text/html. 还可以取'*', 表示对所有MIME类型进行Gzip压缩. 推荐设置:(通常文本/图片/js都可以压缩)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;gzip_types       text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png;&lt;/code&gt;&lt;/p&gt;
&lt;ol start="9"&gt;
&lt;li&gt;&lt;code&gt;gzip_vary&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;默认为off. 推荐开启. 开启后的效果实在响应头部添加了Accept-Encoding: gzip, 这对于本身不支持Gzip压缩的客户端浏览器是有用的.&lt;/p&gt;
&lt;p&gt;也可以通过add_header达到相同的效果:&lt;code&gt;add_header Vary Accept-Encoding gzip;&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;:heavy_exclamation_mark: 该指令在使用过程中存在bug, 会导致IE4及以上的浏览器的数据缓存功能失效.&lt;/p&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Sun, 23 Jun 2019 16:33:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-23:/nginx-notebook-3-1-gzip-module.html</guid><category>nginx</category><category>最佳实践</category></item><item><title>NGINX 学习笔记-高级配置-与网络连接相关的指令</title><link>https://www.EWhisper.cn/nginx-notebook-2-3-network-directives.html</link><description>&lt;h2 id="3"&gt;3 与网络连接相关的配置指令&lt;a class="headerlink" href="#3" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;keepalive_timeout&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;keepalive_timeout 60 50;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Nginx服务器与客户端连接保持活动的时间为60s, 60s后服务器与客户端断开连接; 使用Keep-Alive 消息头保持与客户端某些浏览器(如火狐)的连接时间为50s, 50s后浏览器主动与服务器断开连接.&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;send_timeout&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;设置Nginx服务器响应客户端的超时时间, 这个超时时间仅针对两个客户端和服务器之间建立连接后, 某次活动之间的时间. 如果这个时间后客户端没有任何活动, Nginx服务器将会关闭连接. 此指令的设置需要考虑服务器访问数量和网络状况等方面.&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;client_header_buffer_size&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;设置Nginx服务器允许的客户端请求头部的缓冲区大小, 默认为1KB. 此指令的赋值可以根据系统分页大小来设置. 分页大小可以通过下列命令获得:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;getconf PAGESIZE&lt;/code&gt; (一般为4k)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Nginx 400类错误, 有很大一部分情况是客户端的请求头部过大造成的. 请求头部过大, 通常是客户端cookie中写入了较大的值引起的.&lt;/p&gt;
&lt;p&gt;适当增大此指令的赋值, 可以改善该问题.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;推荐配置:(与系统分页大小相同)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;client_header_buffer_size 4k;&lt;/code&gt;&lt;/p&gt;
&lt;ol start="4"&gt;
&lt;li&gt;multi_accept&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Nginx服务器是否尽可能多地接收客户端的网络连接请求. 默认为off.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Sun, 23 Jun 2019 16:27:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-23:/nginx-notebook-2-3-network-directives.html</guid><category>nginx</category><category>最佳实践</category></item><item><title>NGINX 学习笔记-高级配置-针对CPU的调优指令</title><link>https://www.EWhisper.cn/nginx-notebook-2-2-cpu-tuning.html</link><description>&lt;h2 id="2-cpu"&gt;2 针对CPU的优化指令&lt;a class="headerlink" href="#2-cpu" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;worker_processes&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最好是赋值为机器CPU的倍数.&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;worker_cpu_affinity&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;默认的&lt;code&gt;auto&lt;/code&gt;就行.&lt;br&gt;
&lt;code&gt;worker_cpu_affinity 0001 0010 0100 1000;&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Sun, 23 Jun 2019 16:22:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-23:/nginx-notebook-2-2-cpu-tuning.html</guid><category>nginx</category><category>最佳实践</category></item><item><title>NGINX 学习笔记-高级配置-IPv4 的内核7个参数的配置优化</title><link>https://www.EWhisper.cn/nginx-notebook-2-1-kernel-tuning.html</link><description>&lt;h2 id="1-ipv4-7"&gt;1 IPv4 的内核7个参数的配置优化&lt;a class="headerlink" href="#1-ipv4-7" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux 内核参数. 可以将这些内核参数值追加到Linux的/etc/sysctl.conf文件中.并使用下列命令生效:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;# /sbin/sysctl -p&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;net.core.netdev_max_backlog&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;表示当每个网络接口接收数据包的速率比内核处理这些包的速率快时, 允许发送到队列的数据包的最大数目. 一般默认为128. Nginx定义的NGX_LISTEN_BACKLOG 默认为511. 将该参数调整为:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;net.core.netdev_max_backlog = 262144&lt;/code&gt;&lt;/p&gt;
&lt;ol start="2"&gt;
&lt;li&gt;net.core.somaxconn&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用于调节系统同时发起的TCP连接数, 一般默认为128. 在存在高并发的情况下, 该默认值较小, 可能导致链接超时或重传问题, 可以根据实际需要结合并发请求数来调节此值. 如:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;net.core.somaxconn = 262144&lt;/code&gt;&lt;/p&gt;
&lt;ol start="3"&gt;
&lt;li&gt;net.ipv4.tcp_max_orphans&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用于设定系统中最多允许存在多少TCP套接字不被关联到任何一个用户文件句柄上. 如果超过这个数字, 没有与用户文件句柄关联的TCP套接字将立即被复位, 同时给出警告信息. 这个限制只是为了防止简单的DoS攻击. 一般在系统内存充足的情况下, 可以增大该值:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;net.ipv4.tcp_max_orphans = 262144&lt;/code&gt;&lt;/p&gt;
&lt;ol start="4"&gt;
&lt;li&gt;net.ipv4.tcp_max_syn_backlog&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用于记录尚未收到客户端确认信息的连接请求的最大值. 对于128MB内存的系统, 默认值为1024. 在系统内存充足的情况下, 可以增大该值.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;net.ipv4.tcp_max_syn_backlog = 262144&lt;/code&gt;&lt;/p&gt;
&lt;ol start="5"&gt;
&lt;li&gt;net.ipv4.tcp_timestamps&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用于设置时间戳, 可以避免序列号的卷绕. 在一个1Gb/s的链路上, 遇到以前用过的序列号的概率很大. 当此值为0时, 禁用对于TCP时间戳的支持. 在默认情况下, TCP会接受这种"异常"的数据包. 建议将其关闭.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;net.ipv4.tcp_timestamps = 0&lt;/code&gt;&lt;/p&gt;
&lt;ol start="6"&gt;
&lt;li&gt;net.ipv4.tcp_synack_retries&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用于设置内核放弃TCP连接之前向客户端发送SYN+ACK包的数量.一般赋值为1, 即内核放弃连接之前发送一次SYN+ACK包.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;net.ipv4.tcp_synack_retries = 1&lt;/code&gt;&lt;/p&gt;
&lt;ol start="7"&gt;
&lt;li&gt;net.ipv4.tcp_syn_retries&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;code&gt;net.ipv4.tcp_syn_retries = 1&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Sun, 23 Jun 2019 16:15:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-23:/nginx-notebook-2-1-kernel-tuning.html</guid><category>nginx</category><category>最佳实践</category></item><item><title>NGINX 学习笔记-安装部署-服务器基础配置示例</title><link>https://www.EWhisper.cn/nginx-notebook-1-4-nginx-conf-example.html</link><description>&lt;h2 id="4-nginx"&gt;4 Nginx服务器基础配置示例&lt;a class="headerlink" href="#4-nginx" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;#### 全局块 开始 #####&lt;/span&gt;
&lt;span class="k"&gt;user&lt;/span&gt; &lt;span class="s"&gt;nobody&lt;/span&gt; &lt;span class="s"&gt;nobody&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;# 配置允许运行Nginx服务器的用户和用户组&lt;/span&gt;

&lt;span class="k"&gt;worker_processes&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;# 配置允许Nginx进程生成的worker process数&lt;/span&gt;

&lt;span class="k"&gt;error_log&lt;/span&gt; &lt;span class="s"&gt;logs/error.log&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;# Nginx错误日志输出目录&lt;/span&gt;

&lt;span class="k"&gt;pid&lt;/span&gt; &lt;span class="s"&gt;nginx.pid&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;# 配置Nginx服务器运行时的pid文件存放路径和名称&lt;/span&gt;
&lt;span class="c1"&gt;#### 全局块 结束 #####&lt;/span&gt;

&lt;span class="c1"&gt;#### events块 开始 ####&lt;/span&gt;
&lt;span class="k"&gt;events&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;user&lt;/span&gt; &lt;span class="s"&gt;epoll&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;# 配置事件驱动模型&lt;/span&gt;
    &lt;span class="kn"&gt;worker_connections&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;# 配置最大连接数&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;#### events块 结束 ####&lt;/span&gt;

&lt;span class="c1"&gt;#### http块 开始 ####&lt;/span&gt;
&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;include&lt;/span&gt; &lt;span class="s"&gt;mime.types&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="c1"&gt;# 定义MIME-Type&lt;/span&gt;

    &lt;span class="kn"&gt;default_type&lt;/span&gt; &lt;span class="s"&gt;application/octet-stream&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kn"&gt;sendfile&lt;/span&gt; &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;# 配置允许使用sendfile方式传输&lt;/span&gt;

    &lt;span class="kn"&gt;keepalive_timeout&lt;/span&gt; &lt;span class="mi"&gt;65&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;# 配置连接超时时间&lt;/span&gt;

    &lt;span class="kn"&gt;log_format&lt;/span&gt; &lt;span class="s"&gt;access.log&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="nv"&gt;$remote_addr-[$time_local]-&amp;quot;$request&amp;quot;-&amp;quot;$http_user_agent&amp;quot;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;# 配置请求处理日志的格式&lt;/span&gt;

    &lt;span class="c1"&gt;#### server块 开始 ####&lt;/span&gt;
    &lt;span class="c1"&gt;## 配置虚拟主机myServer1&lt;/span&gt;
    &lt;span class="kn"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="mi"&gt;8081&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;# 配置监听端口和主机名称&lt;/span&gt;
        &lt;span class="kn"&gt;server_name&lt;/span&gt; &lt;span class="s"&gt;myServer1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;access_log&lt;/span&gt; &lt;span class="s"&gt;/myweb/server1/log/access.log&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;# 配置请求处理日志存放路径&lt;/span&gt;
        &lt;span class="kn"&gt;error_page&lt;/span&gt; &lt;span class="mi"&gt;404&lt;/span&gt; &lt;span class="s"&gt;/404.html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;# 配置错误页面&lt;/span&gt;
        &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/server1/location1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    &lt;span class="c1"&gt;# 配置处理/server1/location1请求的location&lt;/span&gt;
            &lt;span class="kn"&gt;root&lt;/span&gt; &lt;span class="s"&gt;/myweb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="kn"&gt;index&lt;/span&gt; &lt;span class="s"&gt;index.svr1-loc1.htm&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/server1/location2&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    &lt;span class="c1"&gt;# 配置处理/server1/location1请求的location&lt;/span&gt;
            &lt;span class="kn"&gt;root&lt;/span&gt; &lt;span class="s"&gt;/myweb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="kn"&gt;index&lt;/span&gt; &lt;span class="s"&gt;index.svr1-loc2.htm&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kn"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    &lt;span class="c1"&gt;## 配置虚拟主机 myServer2&lt;/span&gt;
        &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="mi"&gt;8082&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;server_name&lt;/span&gt; &lt;span class="mi"&gt;192&lt;/span&gt;&lt;span class="s"&gt;.168.1.3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;access_log&lt;/span&gt; &lt;span class="s"&gt;/myweb/server2/log/access.log&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;error_page&lt;/span&gt; &lt;span class="mi"&gt;404&lt;/span&gt; &lt;span class="s"&gt;/404.html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/server2/location1&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="kn"&gt;root&lt;/span&gt; &lt;span class="s"&gt;/myweb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="kn"&gt;index&lt;/span&gt; &lt;span class="s"&gt;index.svr2-loc1.htm&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/svr2/loc2&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
          &lt;span class="kn"&gt;alias&lt;/span&gt; &lt;span class="s"&gt;/myweb/server2/location2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;    &lt;span class="c1"&gt;# 对location的URI进行更改&lt;/span&gt;
          &lt;span class="kn"&gt;index&lt;/span&gt; &lt;span class="s"&gt;index.svr2-loc2.htm&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/404.html&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;    &lt;span class="c1"&gt;# 配置错误页面转向&lt;/span&gt;
            &lt;span class="kn"&gt;root&lt;/span&gt; &lt;span class="s"&gt;/myweb/&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="kn"&gt;index&lt;/span&gt; &lt;span class="mi"&gt;404&lt;/span&gt;&lt;span class="s"&gt;.html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="c1"&gt;#### server 块 结束 ####&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;#### http块 结束 ####&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;配置后的目录结构&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;myweb
    404.html
    server1
        location1
            index.svr1-loc1.htm
        location2
            index.svr1-loc2.htm
        log
            access.log
    server2
        location1
            index.svr2-loc1.htm
        location2
            index.svr2-loc2.htm
        log
            access.log
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Sun, 23 Jun 2019 16:07:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-23:/nginx-notebook-1-4-nginx-conf-example.html</guid><category>nginx</category><category>最佳实践</category></item><item><title>NGINX 学习笔记-安装部署-基础配置</title><link>https://www.EWhisper.cn/nginx-notebook-1-3-basic-config.html</link><description>&lt;h2 id="3-nginx"&gt;3 Nginx 基础配置&lt;a class="headerlink" href="#3-nginx" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;#user  nobody;&lt;/span&gt;
&lt;span class="k"&gt;worker_processes&lt;/span&gt;  &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                        &lt;span class="c1"&gt;# 全局块&lt;/span&gt;

&lt;span class="c1"&gt;#error_log  logs/error.log;&lt;/span&gt;
&lt;span class="c1"&gt;#error_log  logs/error.log  notice;&lt;/span&gt;
&lt;span class="c1"&gt;#error_log  logs/error.log  info;&lt;/span&gt;

&lt;span class="c1"&gt;#pid        logs/nginx.pid;&lt;/span&gt;

&lt;span class="k"&gt;events&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                                    &lt;span class="c1"&gt;# events块&lt;/span&gt;
    &lt;span class="kn"&gt;worker_connections&lt;/span&gt;  &lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;                                        &lt;span class="c1"&gt;# http块&lt;/span&gt;
    &lt;span class="kn"&gt;include&lt;/span&gt;       &lt;span class="s"&gt;mime.types&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;                &lt;span class="c1"&gt;# 引用mime.types这个文件&lt;/span&gt;

    &lt;span class="kn"&gt;default_type&lt;/span&gt;  &lt;span class="s"&gt;application/octet-stream&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;#log_format  main  &amp;#39;$remote_addr - $remote_user [$time_local] &amp;quot;$request&amp;quot; &amp;#39;&lt;/span&gt;
    &lt;span class="c1"&gt;#                  &amp;#39;$status $body_bytes_sent &amp;quot;$http_referer&amp;quot; &amp;#39;&lt;/span&gt;
    &lt;span class="c1"&gt;#                  &amp;#39;&amp;quot;$http_user_agent&amp;quot; &amp;quot;$http_x_forwarded_for&amp;quot;&amp;#39;;&lt;/span&gt;
    &lt;span class="c1"&gt;#access_log  logs/access.log  main;&lt;/span&gt;

    &lt;span class="kn"&gt;sendfile&lt;/span&gt;        &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;#tcp_nopush     on;&lt;/span&gt;
    &lt;span class="c1"&gt;#keepalive_timeout  0;&lt;/span&gt;
    &lt;span class="kn"&gt;keepalive_timeout&lt;/span&gt;  &lt;span class="mi"&gt;65&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;# nginx允许的客户端请求头部的缓冲区大小&lt;/span&gt;
    &lt;span class="kn"&gt;client_header_buffer_size&lt;/span&gt; &lt;span class="mi"&gt;4k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;#gzip  on;&lt;/span&gt;
    &lt;span class="c1"&gt;# proxy buffer&lt;/span&gt;
    &lt;span class="kn"&gt;proxy_buffers&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt; &lt;span class="mi"&gt;4k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;proxy_buffer_size&lt;/span&gt; &lt;span class="mi"&gt;4k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;proxy_temp_file_write_size&lt;/span&gt; &lt;span class="mi"&gt;4k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;proxy_temp_path&lt;/span&gt; &lt;span class="s"&gt;proxy_temp&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;# proxy cache&lt;/span&gt;
    &lt;span class="kn"&gt;proxy_cache_path&lt;/span&gt; &lt;span class="s"&gt;NGINX_cache/&lt;/span&gt; &lt;span class="s"&gt;keys_zone=cache_all:10m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;# 128.236.160.5 CONF&lt;/span&gt;
    &lt;span class="kn"&gt;include&lt;/span&gt; &lt;span class="s"&gt;conf.d/128_236_160_5.conf&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;#server {                                # server块&lt;/span&gt;
    &lt;span class="c1"&gt;#   listen       80;&lt;/span&gt;
    &lt;span class="c1"&gt;#   server_name  localhost;&lt;/span&gt;
    &lt;span class="c1"&gt;#   charset koi8-r;&lt;/span&gt;
    &lt;span class="c1"&gt;#   access_log  logs/host.access.log  main;&lt;/span&gt;

    &lt;span class="c1"&gt;#   location / {                        # location块&lt;/span&gt;
    &lt;span class="c1"&gt;#        root   html;&lt;/span&gt;
    &lt;span class="c1"&gt;#        index  index.html index.htm;&lt;/span&gt;
    &lt;span class="c1"&gt;#   }&lt;/span&gt;

        &lt;span class="c1"&gt;#error_page  404              /404.html;&lt;/span&gt;
        &lt;span class="c1"&gt;# redirect server error pages to the static page /50x.html&lt;/span&gt;
    &lt;span class="c1"&gt;#    error_page   500 502 503 504  /50x.html;&lt;/span&gt;
    &lt;span class="c1"&gt;#    location = /50x.html {&lt;/span&gt;
    &lt;span class="c1"&gt;#        root   html;&lt;/span&gt;
    &lt;span class="c1"&gt;#    }&lt;/span&gt;

        &lt;span class="c1"&gt;# proxy the PHP scripts to Apache listening on 127.0.0.1:80&lt;/span&gt;
        &lt;span class="c1"&gt;#location ~ \.php$ {&lt;/span&gt;
        &lt;span class="c1"&gt;#    proxy_pass   http://127.0.0.1;&lt;/span&gt;
        &lt;span class="c1"&gt;#}&lt;/span&gt;

        &lt;span class="c1"&gt;# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000&lt;/span&gt;
        &lt;span class="c1"&gt;#location ~ \.php$ {&lt;/span&gt;
        &lt;span class="c1"&gt;#    root           html;&lt;/span&gt;
        &lt;span class="c1"&gt;#    fastcgi_pass   127.0.0.1:9000;&lt;/span&gt;
        &lt;span class="c1"&gt;#    fastcgi_index  index.php;&lt;/span&gt;
        &lt;span class="c1"&gt;#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;&lt;/span&gt;
        &lt;span class="c1"&gt;#    include        fastcgi_params;&lt;/span&gt;
        &lt;span class="c1"&gt;#}&lt;/span&gt;

        &lt;span class="c1"&gt;# deny access to .htaccess files, if Apache&amp;#39;s document root&lt;/span&gt;
        &lt;span class="c1"&gt;# concurs with nginx&amp;#39;s one&lt;/span&gt;
        &lt;span class="c1"&gt;#location ~ /\.ht {&lt;/span&gt;
        &lt;span class="c1"&gt;#    deny  all;&lt;/span&gt;
        &lt;span class="c1"&gt;#}&lt;/span&gt;
    &lt;span class="c1"&gt;#}&lt;/span&gt;

    &lt;span class="c1"&gt;# another virtual host using mix of IP-, name-, and port-based configuration&lt;/span&gt;
    &lt;span class="c1"&gt;#server {&lt;/span&gt;
    &lt;span class="c1"&gt;#    listen       8000;&lt;/span&gt;
    &lt;span class="c1"&gt;#    listen       somename:8080;&lt;/span&gt;
    &lt;span class="c1"&gt;#    server_name  somename  alias  another.alias;&lt;/span&gt;

    &lt;span class="c1"&gt;#    location / {&lt;/span&gt;
    &lt;span class="c1"&gt;#        root   html;&lt;/span&gt;
    &lt;span class="c1"&gt;#        index  index.html index.htm;&lt;/span&gt;
    &lt;span class="c1"&gt;#    }&lt;/span&gt;
    &lt;span class="c1"&gt;#}&lt;/span&gt;

    &lt;span class="c1"&gt;# HTTPS server&lt;/span&gt;
    &lt;span class="c1"&gt;#server {&lt;/span&gt;
    &lt;span class="c1"&gt;#    listen       443 ssl;&lt;/span&gt;
    &lt;span class="c1"&gt;#    server_name  localhost;&lt;/span&gt;
    &lt;span class="c1"&gt;#    ssl_certificate      cert.pem;&lt;/span&gt;
    &lt;span class="c1"&gt;#    ssl_certificate_key  cert.key;&lt;/span&gt;
    &lt;span class="c1"&gt;#    ssl_session_cache    shared:SSL:1m;&lt;/span&gt;
    &lt;span class="c1"&gt;#    ssl_session_timeout  5m;&lt;/span&gt;
    &lt;span class="c1"&gt;#    ssl_ciphers  HIGH:!aNULL:!MD5;&lt;/span&gt;
    &lt;span class="c1"&gt;#    ssl_prefer_server_ciphers  on;&lt;/span&gt;

    &lt;span class="c1"&gt;#    location / {&lt;/span&gt;
    &lt;span class="c1"&gt;#        root   html;&lt;/span&gt;
    &lt;span class="c1"&gt;#        index  index.html index.htm;&lt;/span&gt;
    &lt;span class="c1"&gt;#    }&lt;/span&gt;
    &lt;span class="c1"&gt;#}&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;如果某个指令在两个不同层级的块中同时出现,则采用&lt;strong&gt;就近原则&lt;/strong&gt;,即以较低层级块中的配置为准.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_1"&gt;错误日志&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;日志级别由低到高分为debug(需要在编译时使用--with-debug开启debug)、info、notice、warn、error、critical、alert、emerg。&lt;/p&gt;
&lt;h3 id="_2"&gt;引入配置文件&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;include file&lt;/code&gt;&lt;/p&gt;
&lt;h3 id="_3"&gt;事件驱动模型&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;use method&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;method内容有:select, poll, kqueue, epoll, rtsig, &lt;code&gt;/dev/poll&lt;/code&gt;, eventport&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_4"&gt;自定义服务日志&lt;a class="headerlink" href="#_4" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;log_format&lt;/span&gt; &lt;span class="s"&gt;exampleLog&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="nv"&gt;$remote_addr&lt;/span&gt; &lt;span class="s"&gt;-&lt;/span&gt; &lt;span class="s"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;$time_local]&lt;/span&gt; &lt;span class="nv"&gt;$request&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;
                &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="nv"&gt;$status&lt;/span&gt; &lt;span class="nv"&gt;$body_bytes_sent&lt;/span&gt; &lt;span class="nv"&gt;$http_referer&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;
                &lt;span class="s"&gt;&amp;#39;&lt;/span&gt;&lt;span class="nv"&gt;$http_user_agent&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;a href="http://nginx.org/en/docs/varindex.html"&gt;Nginx内置变量&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_5"&gt;基于名称的虚拟主机配置&lt;a class="headerlink" href="#_5" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;server_name myserver.com www.myserver.com;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;server_name *.myserver.com www.myserver.*;&lt;/code&gt;  (通配符'*'只能用于三段字符串的首段或尾段)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;server_name ~^www\d+\.myserver\.com$;&lt;/code&gt;  ("~"为使用正则的标记)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;匹配优先度&lt;/strong&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;对于匹配方式不同的,按照以下优先级:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;准确匹配 server_name&lt;/li&gt;
&lt;li&gt;通配符在开始时匹配 server_name成功&lt;/li&gt;
&lt;li&gt;通配符在结尾时匹配 server_name成功&lt;/li&gt;
&lt;li&gt;正则表达式匹配server_name成功&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果server_name处于同一优先级的匹配方式多次匹配成功,则首次匹配成功的虚拟主机处理请求&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="location"&gt;配置location&lt;a class="headerlink" href="#location" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Syntax&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;location&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;~&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;~*&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="o"&gt;^~&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="n"&gt;uri&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;

        &lt;span class="n"&gt;location&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="o"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;Default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="err"&gt;—&lt;/span&gt;

&lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;location&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;标识含义:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;=&lt;/code&gt; 用于&lt;strong&gt;标准uri&lt;/strong&gt;前,要求请求字符串与uri&lt;strong&gt;严格匹配&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~&lt;/code&gt; 用于表示uri包含&lt;strong&gt;正则表达式&lt;/strong&gt;, 并且&lt;strong&gt;区分大小写&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;~*&lt;/code&gt; 用于表示uri包含&lt;strong&gt;正则表达式&lt;/strong&gt;, 并且&lt;strong&gt;不区分大小写&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;^~&lt;/code&gt; 用于&lt;strong&gt;标准uri&lt;/strong&gt;前, 要求Nginx服务器找到标识uri和请求字符串匹配度最高的location后, 立即使用此location处理请求, 而不再使用location块中的正则uri和请求字符串做匹配.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="_6"&gt;配置请求的根目录&lt;a class="headerlink" href="#_6" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/data/&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;root&lt;/span&gt; &lt;span class="s"&gt;/locationtest1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当location块接收到&lt;code&gt;/data/index.htm&lt;/code&gt; 的请求时, 将在&lt;code&gt;/locationtest1/data/&lt;/code&gt; 目录下找到index.htm 响应请求.&lt;/p&gt;
&lt;h3 id="alias"&gt;alias指令&lt;a class="headerlink" href="#alias" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="p"&gt;~&lt;/span&gt; &lt;span class="sr"&gt;^/data/(.+\.(htm|html))$&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;alias&lt;/span&gt; &lt;span class="s"&gt;/locationtest1/other/&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当收到&lt;code&gt;/data/index.htm&lt;/code&gt;时, 匹配成功, 之后根据alias指令的配置, 将到 &lt;code&gt;/locationtest1/other&lt;/code&gt; 目录下找到对应请求. 可以看到, 通过alias指令的配置, 跟路径已经从&lt;code&gt;/data&lt;/code&gt; 更改为 &lt;code&gt;/locationtest1/other&lt;/code&gt; 了.&lt;/p&gt;
&lt;h3 id="_7"&gt;设置网站默认首页&lt;a class="headerlink" href="#_7" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="p"&gt;~&lt;/span&gt; &lt;span class="sr"&gt;^/data/(.+)/web/$&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;index&lt;/span&gt; &lt;span class="s"&gt;index.&lt;/span&gt;&lt;span class="nv"&gt;$1.html&lt;/span&gt; &lt;span class="s"&gt;index.my1.html&lt;/span&gt; &lt;span class="s"&gt;index.html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当location块接收到&lt;code&gt;/data/locationtest/web/&lt;/code&gt; 时, 匹配成功, 它首先将预置变量$1置为&lt;em&gt;locationtest&lt;/em&gt;, 然后在&lt;code&gt;/data/locationtest/web/&lt;/code&gt; 路径下按照index的配置次序依次寻找 index.locationtest.html index.my1.html 和 index.html , 首先找到哪个页面, 就使用哪个页面响应请求.&lt;/p&gt;
&lt;h3 id="_8"&gt;错误页面&lt;a class="headerlink" href="#_8" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;一般来说,HTTP &lt;strong&gt;2XX 代表请求正常完成&lt;/strong&gt;, &lt;strong&gt;3XX 代表网站重定向&lt;/strong&gt;, &lt;strong&gt;4XX代表客户端出现错误&lt;/strong&gt;, &lt;strong&gt;5XX代表服务器端出现错误&lt;/strong&gt;.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;HTTP消息&lt;/th&gt;
&lt;th&gt;代码&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;已移动&lt;/td&gt;
&lt;td&gt;301&lt;/td&gt;
&lt;td&gt;请求的数据具有新的位置, 并且更改是&lt;strong&gt;永久&lt;/strong&gt;的&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;已找到&lt;/td&gt;
&lt;td&gt;302&lt;/td&gt;
&lt;td&gt;请求的数据&lt;strong&gt;临时&lt;/strong&gt;具有不同的URI&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;请参阅其他&lt;/td&gt;
&lt;td&gt;303&lt;/td&gt;
&lt;td&gt;可在另一URI下找到对请求的响应, 并且应使用GET方法检索此响应&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;未修改&lt;/td&gt;
&lt;td&gt;304&lt;/td&gt;
&lt;td&gt;未按预期修改文档&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;使用代理&lt;/td&gt;
&lt;td&gt;305&lt;/td&gt;
&lt;td&gt;必须通过位置字段中提供的代理来访问请求的资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;未使用&lt;/td&gt;
&lt;td&gt;306&lt;/td&gt;
&lt;td&gt;不再使用, 但保留此代码以便将来使用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;无法找到网页&lt;/td&gt;
&lt;td&gt;400&lt;/td&gt;
&lt;td&gt;可以连接到Web服务器, 但是由于Web地址(URL) 的问题, 无法找到网页&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网站拒绝显示此网页&lt;/td&gt;
&lt;td&gt;403&lt;/td&gt;
&lt;td&gt;可以连接到网站, 但没有显示网页的权限&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;无法找到网页&lt;/td&gt;
&lt;td&gt;404&lt;/td&gt;
&lt;td&gt;可以连接到网站, 但找不到网页. 导致此错误的原因有时可能是该网页暂时不可用或网页已被删除.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网站无法显示该页面&lt;/td&gt;
&lt;td&gt;405&lt;/td&gt;
&lt;td&gt;可以连接到网站, 但网页内容无法下载到用户的计算机. 这通常是由网页编写方式问题引起的.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;无法读取此网页格式&lt;/td&gt;
&lt;td&gt;406&lt;/td&gt;
&lt;td&gt;能够从网站接收信息, 但不能识别其格式, 因而无法正确地显示消息.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;该网站太忙, 无法显示此网页&lt;/td&gt;
&lt;td&gt;408 409&lt;/td&gt;
&lt;td&gt;服务器显示该网页的时间太长, 或对同一网页的请求太多&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网页不复存在&lt;/td&gt;
&lt;td&gt;410&lt;/td&gt;
&lt;td&gt;可以连接到网站, 但无法找到网页. 与404不同, 此错误是永久性的, 而且由网站管理员打开&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网站无法显示该页面&lt;/td&gt;
&lt;td&gt;500&lt;/td&gt;
&lt;td&gt;正在访问的网站出现了服务器问题. 该问题阻止了此网页的显示. 常见的原因是网站正在维护或使用脚本的交互式网站上的程序出错.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;未执行&lt;/td&gt;
&lt;td&gt;501&lt;/td&gt;
&lt;td&gt;没有将正在访问的网站设置为显示浏览器所请求的内容&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;不支持的版本&lt;/td&gt;
&lt;td&gt;505&lt;/td&gt;
&lt;td&gt;该网站不支持浏览器用于请求网页的HTTP协议(如HTTP/1.1)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Syntax&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;error_page&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="o"&gt;[=[&lt;/span&gt;&lt;span class="n"&gt;response&lt;/span&gt;&lt;span class="o"&gt;]]&lt;/span&gt; &lt;span class="n"&gt;uri&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="err"&gt;—&lt;/span&gt;
&lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;location&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;location&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;示例:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;error_page&lt;/span&gt; &lt;span class="mi"&gt;404&lt;/span&gt;             &lt;span class="s"&gt;/404.html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;error_page&lt;/span&gt; &lt;span class="mi"&gt;500&lt;/span&gt; &lt;span class="mi"&gt;502&lt;/span&gt; &lt;span class="mi"&gt;503&lt;/span&gt; &lt;span class="mi"&gt;504&lt;/span&gt; &lt;span class="s"&gt;/50x.html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;error_page&lt;/span&gt; &lt;span class="mi"&gt;404&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt; &lt;span class="s"&gt;/empty.gif&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;#If an error response is processed by a proxied server or a FastCGI/uwsgi/SCGI server, and the server may return different response codes (e.g., 200, 302, 401 or 404), it is possible to respond with the code it returns:&lt;/span&gt;
&lt;span class="k"&gt;error_page&lt;/span&gt; &lt;span class="mi"&gt;404&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/404.php&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="c1"&gt;#If there is no need to change URI and method during internal redirection it is possible to pass error processing into a named location:&lt;/span&gt;
&lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;error_page&lt;/span&gt; &lt;span class="mi"&gt;404&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;@fallback&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="s"&gt;@fallback&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;proxy_pass&lt;/span&gt; &lt;span class="s"&gt;http://backend&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;#It is also possible to use URL redirects for error processing:&lt;/span&gt;
&lt;span class="k"&gt;error_page&lt;/span&gt; &lt;span class="mi"&gt;403&lt;/span&gt;      &lt;span class="s"&gt;http://example.com/forbidden.html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;error_page&lt;/span&gt; &lt;span class="mi"&gt;404&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;301&lt;/span&gt; &lt;span class="s"&gt;http://example.com/notfound.html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="ipnginx"&gt;基于IP配置Nginx的访问权限&lt;a class="headerlink" href="#ipnginx" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;deny&lt;/span&gt;  &lt;span class="mi"&gt;192&lt;/span&gt;&lt;span class="s"&gt;.168.1.1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;allow&lt;/span&gt; &lt;span class="mi"&gt;192&lt;/span&gt;&lt;span class="s"&gt;.168.1.0/24&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;allow&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="s"&gt;.1.1.0/16&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;allow&lt;/span&gt; &lt;span class="n"&gt;2001&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="s"&gt;db8::/32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;deny&lt;/span&gt;  &lt;span class="s"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Syntax&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;allow&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;CIDR&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;unix&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;all&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="err"&gt;—&lt;/span&gt;
&lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;location&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;limit_except&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;address: 客户端IP, 不支持同时设置多个.如果有多个IP需要设置, 需要重复使用allow指令.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Nginx配置在解析的过程中, 遇到deny指令或者allow指令是按照顺序对当前客户端的连接进行访问权限检查的. 如果遇到匹配的设置时, 则停止继续向下搜索相关配置.&lt;/p&gt;
&lt;h3 id="nginx"&gt;基于密码的Nginx访问权限&lt;a class="headerlink" href="#nginx" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Syntax&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;auth_basic&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;off&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;auth_basic&lt;/span&gt; &lt;span class="n"&gt;off&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;location&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;limit_except&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Syntax&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;auth_basic_user_file&lt;/span&gt; &lt;span class="n"&gt;file&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;Default&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="err"&gt;—&lt;/span&gt;
&lt;span class="n"&gt;Context&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;    &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;server&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;location&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;limit_except&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;明文密码格式:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;## comment
name1:password1
name2:password2:comment
name3:password3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;加密密码可以使用&lt;code&gt;crypt()&lt;/code&gt; 函数进行密码加密的格式, 在Linux平台上可以使用 &lt;code&gt;htpasswd&lt;/code&gt; 命令生成. 在PHP和Perl等语言中, 也提供&lt;code&gt;crypt()&lt;/code&gt;函数. 使用htpasswd命令的一个示例为:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;htpasswd -c -d /nginx/conf/pass_file username&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;运行后输入密码即可.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Sun, 23 Jun 2019 15:30:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-23:/nginx-notebook-1-3-basic-config.html</guid><category>nginx</category><category>最佳实践</category></item><item><title>NGINX 学习笔记-安装部署-启停控制</title><link>https://www.EWhisper.cn/nginx-notebook-1-2-start-stop.html</link><description>&lt;h2 id="nginx"&gt;Nginx启停控制&lt;a class="headerlink" href="#nginx" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nginx -t&lt;/code&gt; 检查Nginx服务器配置文件是否有语法错误&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nginx&lt;/code&gt; 启动&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nginx -s stop&lt;/code&gt; 停止&lt;/li&gt;
&lt;li&gt;&lt;code&gt;nginx -s reload&lt;/code&gt;  或 &lt;code&gt;kill HUP `/Nginx/logs/nginx.pid`&lt;/code&gt;  平滑重启&lt;/li&gt;
&lt;li&gt;平滑升级: 先执行&lt;code&gt;kill USR2 `/Nginx/logs/nginx.pid`&lt;/code&gt;实现Nginx服务的平滑升级; 再使用&lt;code&gt;kill WINCH `/Nginx/logs/nginx.pid`&lt;/code&gt;平滑停止旧服务信号&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Sun, 23 Jun 2019 15:25:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-23:/nginx-notebook-1-2-start-stop.html</guid><category>nginx</category><category>最佳实践</category></item><item><title>NGINX 学习笔记-安装部署-基本配置</title><link>https://www.EWhisper.cn/nginx-notebook-1-1-basic-config.html</link><description>&lt;h1 id="_1"&gt;基本配置&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id="_2"&gt;依赖&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;GCC编译器&lt;/li&gt;
&lt;li&gt;Automake工具&lt;/li&gt;
&lt;li&gt;pcre库(支持rewrite模块)&lt;/li&gt;
&lt;li&gt;zlib库(支持gzip模块)&lt;/li&gt;
&lt;li&gt;openssl库(支持ssl模块)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;参考指令&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;yum -y install gcc gcc-c++ automake pcre pcre-devel zlib zlib-devel openssl openssl-devel&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="_3"&gt;目录结构&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="nginx"&gt;nginx解压后软件包&lt;a class="headerlink" href="#nginx" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;src&lt;/strong&gt;: 源代码&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;man&lt;/strong&gt;: 帮助文件(可以通过&lt;code&gt;man nginx&lt;/code&gt;查看)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;html&lt;/strong&gt;: html文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;conf&lt;/strong&gt;: 配置文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;auto&lt;/strong&gt;: 脚本文件,和configure&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;configure&lt;/strong&gt;: 自动脚本程序&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img align="absmiddle" alt="📓" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f4d3.png" title=":notebook:" width="20px"&gt;备注:&lt;/p&gt;
&lt;p&gt;configure 2项工作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;检查环境,根据环境检查结果生成C代码;&lt;/li&gt;
&lt;li&gt;生成编译代码需要的Makefile文件.&lt;br&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id="nginx_1"&gt;nginx服务器软件目录&lt;a class="headerlink" href="#nginx_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;conf&lt;/strong&gt;: Nginx的所有配置文件&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;html&lt;/strong&gt;: Nginx服务器在运行过程中调用的一些html网页文件.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;logs&lt;/strong&gt;: 日志&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;sbin&lt;/strong&gt;: nginx一个文件,即启动的主程序&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;可以在html目录下自定义一些网页文件,并在配置文件中配置发生什么情况时转到相应的文件&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="configure"&gt;configure 脚本支持的常用选项&lt;a class="headerlink" href="#configure" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;--prefix=&amp;lt;path&amp;gt;  指定安装路径,默认/usr/local/nginx

--user=&amp;lt;user&amp;gt;  未指定,默认nobody

--with-debug  启用Nginx的调试日志

--add-module=&amp;lt;path&amp;gt;  声明第三方模块的路径,用以编译刀Nginx服务器中

--with-poll_module  声明启用poll模块.poll模块是信号处理的一种方法.

--with-http_ssl_module  启用HTTP的ssl模块.

--with-http_stub_status_module  启用Server Status页.默认不启用

--http-proxy-temp-path=&amp;lt;path&amp;gt;  指定存放HTTP代理临时文件的路径

--without-http  声明禁用HTTP Server

--with-pcre=&amp;lt;dir&amp;gt;  指定pcre库源代码的路径.这样可以在**编译Nginx源代码的同时编译pcre库**,不需要提前安装pcre库

--with-zilb=&amp;lt;dir&amp;gt;  指定zlib库源代码的路径.同pcre

--with-openssl=&amp;lt;dir&amp;gt;  指定OpenSSL库源代码的路径.
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;清除上次编译的遗留文件 &lt;code&gt;make clean&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;./configure

    --sbin-path&lt;span class="o"&gt;=&lt;/span&gt;/usr/local/nginx/nginx

    --conf-path&lt;span class="o"&gt;=&lt;/span&gt;/usr/local/nginx/nginx.conf

    --pid-path&lt;span class="o"&gt;=&lt;/span&gt;/usr/local/nginx/nginx.pid

    --with-http_ssl_module

    --with-pcre&lt;span class="o"&gt;=&lt;/span&gt;../pcre-8.40

    --with-zlib&lt;span class="o"&gt;=&lt;/span&gt;../zlib-1.2.11
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Sun, 23 Jun 2019 15:10:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-23:/nginx-notebook-1-1-basic-config.html</guid><category>nginx</category><category>最佳实践</category></item><item><title>NGINX 实战手册-运维-实用运维Tips和总结</title><link>https://www.EWhisper.cn/nginx-handbook-3-11-operation-best-practices.html</link><description>&lt;h2 id="311-tips"&gt;3.11 实用运维Tips和总结&lt;a class="headerlink" href="#311-tips" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="3110"&gt;3.11.0 介绍&lt;a class="headerlink" href="#3110" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;最后章节会包括使用运维tips和本书的总结. 通过这三个大部分, 我们讨论了与运维工程师有关的很多想法和概念. 然而, 我认为再多讲一点会有助于理解的更加全面. 在本章, 我会确保你的配置文件干净和简洁, 以及如何调试配置文件.&lt;/p&gt;
&lt;h3 id="3111-includes"&gt;3.11.1 使用 Includes 来缩减配置&lt;a class="headerlink" href="#3111-includes" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要清理大量的配置文件来保证你的配置文件以模块化的配置集分组.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;include&lt;/code&gt;指令来引用配置文件, 目录或通配符:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;include&lt;/span&gt; &lt;span class="s"&gt;config.d/compression.conf&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;include&lt;/span&gt; &lt;span class="s"&gt;sites-enabled/*.conf&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="3112"&gt;3.11.2 调试配置&lt;a class="headerlink" href="#3112" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;从NGINX server , 你得到的非预期的结果.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;调试配置, 记住以下建议:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;NGINX进程请求查找最匹配的规则.&lt;/li&gt;
&lt;li&gt;你可以打开调试日志. 对于调试日志, 你需要确保你的NGINX包配置了&lt;code&gt;--with-debug&lt;/code&gt; flag. 大部分常见包都有; 但是如果你构建你自己的包, 或在运行一个最小化的包, 你可能至少需要再次仔细检查. 一旦你确定了你有debug, 你可以设置&lt;code&gt;error_log&lt;/code&gt;指令的日志级别为&lt;code&gt;debug&lt;/code&gt;: &lt;code&gt;error_log /var/log/nginx/error.log debug;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;你可以为特定的连接启用调试. &lt;code&gt;debug_connection&lt;/code&gt;指令在&lt;code&gt;events&lt;/code&gt;上下文是合法的, 使用IP或CIDR range作为参数. 该指令可以声明多次来添加多个要调试的IP地址或CIDR ranges. 这在生产环境, 但是调试所有连接会导致性能下降的情况下, 调试一个问题会很有用&lt;/li&gt;
&lt;li&gt;你可以调试特定的virtual servers. 因为&lt;code&gt;error_log&lt;/code&gt;在&lt;code&gt;main&lt;/code&gt; &lt;code&gt;http&lt;/code&gt; &lt;code&gt;mail&lt;/code&gt; &lt;code&gt;stream&lt;/code&gt; &lt;code&gt;server&lt;/code&gt; 和&lt;code&gt;location&lt;/code&gt;上下文都有效. 你可以在你需要调试的上下文设置&lt;code&gt;debug&lt;/code&gt;日志级别.&lt;/li&gt;
&lt;li&gt;你可以启用core dumps, 来从中获取backtraces. Core dumps可以通过操作系统启用, 或通过NGINX配置文件.&lt;/li&gt;
&lt;li&gt;你可以使用&lt;code&gt;rewrite_log&lt;/code&gt;记录rewrite 声明的日志: &lt;code&gt;rewrite_log on;&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;NGINX能做很多神奇的配置, 但是也有性能下降的风险. 调试时, 确保你知道如何通过你的配置来追踪你的请求; 如果有问题, 增加调试日志级别来帮助分析. debug日志时相当详细, 找出NGINX对你的请求做了什么以及你的配置在哪儿出错了很有帮助.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2crNKVM"&gt;NGINX如何处理请求&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2iQYNsZ"&gt;管理员调试向导&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2j96jAH"&gt;Rewrite log&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="3113"&gt;3.11.3 总结&lt;a class="headerlink" href="#3113" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;这本书的三个部分集中于高性能负载均衡, 安全, 以及部署和维护NGINX和NGINX Plus servers. 这本书展示了NGINX应用交付平台的一些最强大的功能. NGINX会继续开发神奇的功能, 保持赛道领先.&lt;/p&gt;
&lt;p&gt;这本书展示了很多"简短食谱", 允许你对指令和模块(这些让NGINX成为当今网络之心)有更好的理解. NGINX server不仅仅是web server, 不仅仅时反向代理, 而是一个完整的应用交付平台, 完全有能力通过认证, 并在未来环境中使用.  请知悉.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:39:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-11-operation-best-practices.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-运维-使用`split_clients`进行A-B测试</title><link>https://www.EWhisper.cn/nginx-handbook-3-7-ab-test.html</link><description>&lt;h2 id="37-split_clientsa-b"&gt;3.7 使用&lt;code&gt;split_clients&lt;/code&gt;进行A-B测试&lt;a class="headerlink" href="#37-split_clientsa-b" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="370"&gt;3.7.0 介绍&lt;a class="headerlink" href="#370" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;NGINX有一个叫做&lt;code&gt;split_clients&lt;/code&gt;的模块, 允许你来系统地给予某一个变量key来拆分用户. NGINX通过使用轻量的哈希算法来哈希一个给定的字符串来拆分用户. 然后数学地通过百分比拆分, 映射预定义的值到一个变量, 这个值可以用来改变服务器的响应。&lt;/p&gt;
&lt;h3 id="371-ab"&gt;3.7.1 A/B 测试&lt;a class="headerlink" href="#371-ab" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要拆分两个或更多版本的文件或程序的用户来测试接受度.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;split_clients&lt;/code&gt;模块来直接为你的客户端设置不同的upstream pool:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;split_clients&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;${remote_addr}AAA&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;$variant&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;20.0%&lt;/span&gt;    &lt;span class="s"&gt;&amp;quot;backendv2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;*&lt;/span&gt;        &lt;span class="s"&gt;&amp;quot;backendv1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;split_clients&lt;/code&gt;指令哈希由你提供的字符串作为第一个参数, 并且将散列的百分比提供映射一个变量的值作为第二个参数提供。第三个参数是一个包含key-value对的对象, key是百分比权重, 值是要被分配的值. key可以是一个百分比或一个星号. 星号就是剩下的百分比. 变量&lt;code&gt;$variant&lt;/code&gt;的值将是20%的客户端IP是&lt;code&gt;backendv2&lt;/code&gt;, 剩下的80%是&lt;code&gt;backendv1&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;在本例中, &lt;code&gt;backendv1&lt;/code&gt;和&lt;code&gt;backendv2&lt;/code&gt;代表upstream server池, 可以被用于&lt;code&gt;proxy_pass&lt;/code&gt;指令, 如下:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;proxy_pass&lt;/span&gt; &lt;span class="s"&gt;http://&lt;/span&gt;&lt;span class="nv"&gt;$variant&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;使用变量&lt;code&gt;$variant&lt;/code&gt;, 我们的流量会被分为2个不同的应用server池.&lt;/p&gt;
&lt;p&gt;另一个案例:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
 &lt;span class="kn"&gt;split_clients&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;${remote_addr}AAA&amp;quot;&lt;/span&gt; &lt;span class="nv"&gt;$variant&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="kn"&gt;0.5%&lt;/span&gt;               &lt;span class="s"&gt;.one&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                &lt;span class="kn"&gt;2.0%&lt;/span&gt;               &lt;span class="s"&gt;.two&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                   &lt;span class="kn"&gt;*&lt;/span&gt;                  &lt;span class="s"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
 &lt;span class="kn"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
         &lt;span class="kn"&gt;index&lt;/span&gt; &lt;span class="s"&gt;index&lt;/span&gt;&lt;span class="nv"&gt;${variant}.html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;A/B测试的类型很有用, 如测试不同类型的市场和前端功能的电商网站转化率. 对于应用, 使用金丝雀发布很常见. 这种部署中, 流量被缓慢地切换到新的版本. 拆分不同应用版本的客户端是很有用的, 当回滚新版本的代码, 限制因为一个错误导致的爆炸半径. 不论是因为什么原因要拆分两个不同应用集的客户端, NGINX通过使用&lt;code&gt;split_client&lt;/code&gt;模块都能很容易实现.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jsdkw4"&gt;split_client documentation&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:39:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-7-ab-test.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-运维-使用GeoIP模块通过IP地址定位用户</title><link>https://www.EWhisper.cn/nginx-handbook-3-8-use-geoip-to-get-users-location.html</link><description>&lt;h2 id="38-geoipip"&gt;3.8 使用GeoIP模块通过IP地址定位用户&lt;a class="headerlink" href="#38-geoipip" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="380"&gt;3.8.0 介绍&lt;a class="headerlink" href="#380" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;跟踪, 分析, 和利用你的应用或度量的客户端的位置信息可以帮助你加深对客户的理解. 有很多方法获取你的客户的位置信息, NGINX通过使用GeoIP模块和几个指令很容易地定位他们. 该模块让基于客户位置信息记录位置, 控制访问, 或者基于客户位置做决定变得很容易.  它也允许客户的位置信息被内部查找只要请求被传输到upstream应用, 而不需要再进行查找. 该NGINX模块默认不安装, 可以从源码静态编译, 动态导入, 或通过在Ubuntu安装&lt;code&gt;nginx-full&lt;/code&gt;或&lt;code&gt;nginx-extras&lt;/code&gt;来安装. 在RHEL发行版, 如CentOS, 你可以安装&lt;code&gt;nginx-mod-http-geoip&lt;/code&gt;包并通过&lt;code&gt;load_module&lt;/code&gt;动态导入. 本章会覆盖&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;导入GeoIP动态模块,&lt;/li&gt;
&lt;li&gt;安装GeoIP数据库,&lt;/li&gt;
&lt;li&gt;该模块可用的内建变量,&lt;/li&gt;
&lt;li&gt;控制访问,&lt;/li&gt;
&lt;li&gt;和代理一起使用.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="381-geoip"&gt;3.8.1 使用GeoIP模块和数据库&lt;a class="headerlink" href="#381-geoip" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要安装GeoIP数据库, 并启用在NGINX的内建命令, 来记录和告诉你的应用你的客户端的地理位置.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;下载GeoIP国家和城市数据库, 并unzip它们:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# mkdir /etc/nginx/geoip&lt;/span&gt;
&lt;span class="c1"&gt;# cd /etc/nginx/geoip&lt;/span&gt;
&lt;span class="c1"&gt;# wget &amp;quot;http://geolite.maxmind.com/\&lt;/span&gt;
download/geoip/database/GeoLiteCountry/GeoIP.dat.gz&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;# gunzip GeoIP.dat.gz&lt;/span&gt;
&lt;span class="s2"&gt;# wget &amp;quot;&lt;/span&gt;http://geolite.maxmind.com/&lt;span class="se"&gt;\&lt;/span&gt;
download/geoip/database/GeoLiteCity.dat.gz&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;
&lt;span class="s2"&gt;# gunzip GeoLiteCity.dat.gz&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这些命令在&lt;em&gt;/etc/nginx&lt;/em&gt;下创建一个&lt;em&gt;geoip&lt;/em&gt;目录, 跳转到新目录, 并下载和解压包.&lt;/p&gt;
&lt;p&gt;通过在本地磁盘上的 国家和城市的GeoIP数据库, 我们可以构建NGINX GeoIP模块并使用它们来暴露出给予客户端IP地址的内建指令:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;load_module&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/usr/lib64/nginx/modules/ngx_http_geoip_module.so&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;geoip_country&lt;/span&gt; &lt;span class="s"&gt;/etc/nginx/geoip/GeoIP.dat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;geoip_city&lt;/span&gt; &lt;span class="s"&gt;/etc/nginx/geoip/GeoLiteCity.dat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;geoip_country&lt;/code&gt;指令指定到&lt;em&gt;GeoIP.dat&lt;/em&gt;文件的路径, &lt;em&gt;GeoIP.dat&lt;/em&gt;包含IP地址到国家代码的映射, 只能在HTTP上下文中使用.&lt;/p&gt;
&lt;h3 id="_1"&gt;讨论&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;模块的&lt;code&gt;geoip_country&lt;/code&gt;和&lt;code&gt;geoip_city&lt;/code&gt;暴露一系列可用变量. &lt;code&gt;geoip_country&lt;/code&gt;指令允许你去本你的客户的国家. 这些变量包括&lt;code&gt;$geoip_country_code&lt;/code&gt;, &lt;code&gt;geoip_country_code3&lt;/code&gt;和&lt;code&gt;geoip_country_name&lt;/code&gt;. 国家代码变量返回一个2位国家字母. &lt;code&gt;geoip_country_code3&lt;/code&gt;返回3位国家字母. 国家名变量返回国家的全名.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;geoip_city&lt;/code&gt;指令也会启用几个变量. 和&lt;code&gt;geoip_country&lt;/code&gt;类似. 有&lt;code&gt;$geoip_city_country_code&lt;/code&gt; &lt;code&gt;geoip_city_country_code3&lt;/code&gt; &lt;code&gt;geoip_city_contry_name&lt;/code&gt;. 其他变量有&lt;code&gt;$geoip_city&lt;/code&gt; &lt;code&gt;$geoip_city_continent_code&lt;/code&gt; &lt;code&gt;$geoip_latitude&lt;/code&gt; &lt;code&gt;$geoip_longitude&lt;/code&gt;和&lt;code&gt;$geoip_postal_code&lt;/code&gt;. &lt;code&gt;$geoip_region&lt;/code&gt; &lt;code&gt;$geoip_region_name&lt;/code&gt;描述区域, 领域, 州, 省, 联邦政府地等. 区域是一个两字符代码, 区域名是全名. &lt;code&gt;geoip_area_code&lt;/code&gt;, 只在美国有效, 返回3位数字电话区域码.&lt;/p&gt;
&lt;p&gt;通过这些变量, 你能够记录你的客户端的信息. 你可以选择传递信息到你的应用作为一个header或变量, 或使用NGINX来以特定方式route流量.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://github.com/maxmind/geoipupdate"&gt;GeoIP 升级&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="382"&gt;3.8.2 基于国家限制访问&lt;a class="headerlink" href="#382" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;根据合约或应用需求, 你需要限制来自特定国家的访问.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;映射你想要屏蔽或允许的国家代码到一个变量&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;load_module&lt;/span&gt;
  &lt;span class="s"&gt;&amp;quot;/usr/lib64/nginx/modules/ngx_http_geoip_module.so&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;map&lt;/span&gt; &lt;span class="nv"&gt;$geoip_country_code&lt;/span&gt; &lt;span class="nv"&gt;$country_access&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;&amp;quot;US&amp;quot;&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;&amp;quot;RU&amp;quot;&lt;/span&gt;    &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;default&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kn"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个映射会设置新的变量&lt;code&gt;$country_access&lt;/code&gt;为1或0. 如果客户端IP地址来自美国或俄罗斯, 变量会被设置为0, 其他国家会设置为1.&lt;/p&gt;
&lt;p&gt;然后, 在&lt;code&gt;server&lt;/code&gt;快, 使用&lt;code&gt;if&lt;/code&gt;声明来拒绝不是来自美国和俄罗斯的用户访问:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;if&lt;/span&gt; &lt;span class="s"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$country_access&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;1&amp;#39;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;403&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kn"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;当条件判断为True时, 会返回403 未认证. 否则正常访问.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;这是一个简短的例子, 来说明如何允许特定国家访问. 这个例子可以被扩展, 以符合你的需要.&lt;/p&gt;
&lt;h3 id="383"&gt;3.8.3 找到源客户端&lt;a class="headerlink" href="#383" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要找到客户源IP, 因为在NGINX server前边有代理.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;geoip_proxy&lt;/code&gt;指令来定义你的代理IP地址范围, &lt;code&gt;geoip_proxy_recursive&lt;/code&gt;指令来查找源IP:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;load_module&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/usr/lib64/nginx/modules/ngx_http_geoip_module.so&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;geoip_country&lt;/span&gt; &lt;span class="s"&gt;/etc/nginx/geoip/GeoIP.dat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;geoip_city&lt;/span&gt; &lt;span class="s"&gt;/etc/nginx/geoip/GeoLiteCity.dat&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;geoip_proxy&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="s"&gt;.0.16.0/26&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;geoip_proxy_recursive&lt;/span&gt; &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;...&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;geoip_proxy&lt;/code&gt;指令定义我们的代理服务器的CIDR范围, 指示NGINX利用&lt;code&gt;X-Forwarded-For&lt;/code&gt;头来查找客户端IP地址. &lt;code&gt;geoip_proxy_recursive&lt;/code&gt;指令指示NGINX来递归地查找上个知道的客户端IP的&lt;code&gt;X-Forwarded-For&lt;/code&gt; header.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;你可能会发现你在NGINX前边使用了代理, NGINX会选择代理的IP地址而不是客户端的. 对于这种情况你可以使用&lt;code&gt;geoip_proxy&lt;/code&gt;指令来指示在给定的范围内, NGINX使用&lt;code&gt;X-Forwarded-For&lt;/code&gt; header. &lt;code&gt;geoip_proxy&lt;/code&gt;指令配置一个地址或CIDR范围. 当NGINX前边有多个代理, 可以使用&lt;code&gt;geoip_proxy_recursive&lt;/code&gt;指令来递归地查找&lt;code&gt;X-Forwarded-For&lt;/code&gt;指令, 来找到源客户端. 你可能会在如在NGINX前边使用AWS ELB, 谷歌的负载均衡, 或Azure的负载均衡时用到这些.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:39:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-8-use-geoip-to-get-users-location.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-运维-自动化</title><link>https://www.EWhisper.cn/nginx-handbook-3-6-automatation.html</link><description>&lt;h2 id="36"&gt;3.6 自动化&lt;a class="headerlink" href="#36" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="360"&gt;3.6.0 介绍&lt;a class="headerlink" href="#360" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;有很多方式来自动化NGINX和NGINX Plus的配置文件, 如: 使用配置管理工具或定时任务来从模板配置文件配置. 随着动态环境的增加, 自动化配置的需求变得更急需. 在上一章, 我们确信NGINX配置文件被配置后需要reload.在本章, 我们会讨论更进一步的使用NGINX Plus API和&lt;strong&gt;Consul Template&lt;/strong&gt;的实时(on-the-fly)NGINX配置文件重配置.&lt;/p&gt;
&lt;h3 id="361-nginx-plus"&gt;3.6.1 使用NGINX Plus自动化&lt;a class="headerlink" href="#361-nginx-plus" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要为动态环境重实时配置NGINX Plus的load balance.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用NGINX Plus API来重配置NGINX Plus upstream 池:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ curl &lt;span class="s1"&gt;&amp;#39;http://nginx.local/upstream_conf?\&lt;/span&gt;
&lt;span class="s1"&gt;  add=&amp;amp;upstream=backend&amp;amp;server=10.0.0.42:8080&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;curl&lt;/code&gt;调用到NGINX Plus的请求, 请求一个把一个新的server加到&lt;code&gt;backend&lt;/code&gt; upstream配置.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;更多第一次安装的细节见 3.8 章节, NGINX Plus提供一个API来重新实时配置NGINX Plus. NGINX Plus API允许从upstream 池中添加和移除server, 同时draining 连接. 你可以使用该API来自动化NGINX Plus的应用服务器的创建和释放的配置.&lt;/p&gt;
&lt;h3 id="362-consul-templating"&gt;3.6.2 使用Consul Templating 自动化配置&lt;a class="headerlink" href="#362-consul-templating" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要自动化NGINX配置来通过使用Consul在环境中做出变更.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;consul-template&lt;/code&gt; daemon和一个模板文件来模板化NGINX配置文件:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="x"&gt;upstream backend { &lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt;&lt;span class="nv"&gt;range&lt;/span&gt; &lt;span class="nv"&gt;service&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;app.backend&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;    server &lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt;&lt;span class="nv"&gt;.Address&lt;/span&gt;&lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;;&lt;/span&gt;&lt;span class="cp"&gt;{{&lt;/span&gt;&lt;span class="nv"&gt;end&lt;/span&gt;&lt;span class="cp"&gt;}}&lt;/span&gt;&lt;span class="x"&gt;&lt;/span&gt;
&lt;span class="x"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个例子是Consul模板文件的一个upstream配置块模板. 这个模板会遍历在Consul上标记为&lt;code&gt;app.backend&lt;/code&gt;的节点. 对于Consul上的每个节点, 这个模板会使用那个节点的IP地址产生一条server指令.&lt;/p&gt;
&lt;p&gt;这个&lt;code&gt;consul-template&lt;/code&gt; daemon通过命令行运行, 可以被用于在每次配置文件被模板化变更后reload NGINX:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# consul-template -consul consul.example.internal -template \&lt;/span&gt;
template:/etc/nginx/conf.d/upstream.conf:&lt;span class="s2"&gt;&amp;quot;nginx -s reload&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该指令指示&lt;code&gt;consul-template&lt;/code&gt; daemon 来连接到一个位于&lt;code&gt;consul.example.internal&lt;/code&gt;的Consul 集群, 并使用在当前工作目录的名为&lt;code&gt;template&lt;/code&gt;的文件来模板化该文件, 并输出生成的内容到&lt;code&gt;/etc/nginx/conf.d/upstream.conf&lt;/code&gt;中, 然后在每次模板化文件变更时reload NGINX. &lt;code&gt;-template&lt;/code&gt; 标志接受一个字符串,包括: 模板文件,输出位置,和运行模板过程后执行的命令; 这3个变量以冒号分隔. 如果运行的命令由空格, 确保使用双引号包裹. &lt;code&gt;-consul&lt;/code&gt;标志指示要连接的Consul集群.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;Consul是一个强大的服务发现工具和配置仓库. Consul以key-value 对以类似目录的结构存储节点信息, 允许restful API交互.Consul也在每个客户端上提供一个DNS界面, 允许进行连接到集群的节点的域名查找. 一个单独的, 利用Consul集群的项目是&lt;code&gt;consul-template&lt;/code&gt; daemon; 这个工具模板化在Consul 节点, 服务或 key-value对的文件变化. 这让Consul成为一个自动化NGINX的非常强大的选择. 使用&lt;code&gt;consul-template&lt;/code&gt;你也可以指示该daemon在模板替换变更后来运行一个命令. 通过这样, 可以reload NGINX配置, 并允许NGINX配置在环境中生效. 通过Consul, 你可以在每个客户端上设置健康检查来检查关注的服务的监控状况. 通过失败检测, 你能够通过模板化你的NGINX配置来只给健康的主机发送流量.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://www.consul.io/"&gt;Consul home page&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2iosmkV"&gt;Introduction to Consul Template&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/hashicorp/consul-template"&gt;Consul template GitHub&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:33:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-6-automatation.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-运维-前言和介绍</title><link>https://www.EWhisper.cn/nginx-handbook-3-0-foreword.html</link><description>&lt;h2 id="30"&gt;3.0 前言和介绍&lt;a class="headerlink" href="#30" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;在NGINX CookBook的第一部分, 主题是负载均衡和缓存. 第二部分是NGINX的安全功能, 如认证和加密. 第三部分集中于NGINX的运维问你, 包括部署, 性能调优和解决问题.&lt;/p&gt;
&lt;p&gt;在这部分, 你会看到基于三个大型公有云的NGINX部署实践: Amazon Web Services(AWS), Google Cloud Platform(GCP), 和微软Azure, 包括如何自动化在AWS上部署. 如果你计划使用Docker, 也有相关内容.&lt;/p&gt;
&lt;p&gt;安装也会深入讨论使用Puppet, Chef, Ansible和SaltStack的自动化配置管理. 也介绍了使用NGINX Plus API来实施重配置, 使用Consul进行服务发现和模版配置.&lt;/p&gt;
&lt;p&gt;默认情况下, 大部分系统配置是基于兼容性而不是性能. 然后你要根据你的特定需求进行性能调优. 在本书中, 你会找到在保持兼容性的前提下, 详细的最大化NGINX性能的方法.&lt;/p&gt;
&lt;p&gt;当我碰到部署问题, 我首先会看日志文件, 是很多调试信息的来源. NGINX有维护详细的, 高度配置化的日志来帮助你定位问题. 本书中包含NGINX日志的详细内容.&lt;/p&gt;
&lt;p&gt;它会帮助你安装, 监控, 维护NGINX应用交付平台.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:28:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-0-foreword.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-运维-在Docker 上部署</title><link>https://www.EWhisper.cn/nginx-handbook-3-4-nginx-docker.html</link><description>&lt;h2 id="34-docker"&gt;3.4 在Docker上部署&lt;a class="headerlink" href="#34-docker" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="340"&gt;3.4.0 介绍&lt;a class="headerlink" href="#340" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;Docker是个开源项目, 会自动把Linux应用部署到软件容器中. Docker提供一个额外的抽象层, 在linux上自动化操作系统级别的虚拟化. 容器化环境已经对生产世界造成了巨大的变革. Docker和其他容器平台允许快速, 可靠, 跨平台的应用部署. 本章中, 我们会讨论NGINX官方NGINX Dockerjingxiang,创建你自己的Docker文件来运行NGINX, 在NGINX中使用环境变量, 通用Docker实践.&lt;/p&gt;
&lt;h3 id="341-nginx"&gt;3.4.1 使用NGINX镜像快速运行&lt;a class="headerlink" href="#341-nginx" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要使用Docker Hub中的NGINX镜像快速启动和运行.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ docker pull nginx:latest
$ docker run -it -p &lt;span class="m"&gt;80&lt;/span&gt;:80 -v &lt;span class="nv"&gt;$PWD&lt;/span&gt;/nginx-conf:/etc/nginx &lt;span class="se"&gt;\&lt;/span&gt;
                                   nginx:latest
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;NGINX已经在Docker Hub上制作了一个官方Docker镜像. 官方Docker镜像很容易在Docker中启动和快速运行. 在本节中我们通过2个命令就能启动和运行NGINX 容器. 官方镜像是基于Debian Jessie Docker镜像. 但是你也可以选择基于Alpine Linux构建的官方镜像. 这些官方镜像的Dockerfile和源码可以在GitHub中找到.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://hub.docker.com/_/nginx/"&gt;Official NGINX Docker image, NGINX&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/nginxinc/docker-nginx/"&gt;Docker repo on GitHub&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="342-nginx-dockerfile"&gt;3.4.2 创建一个NGINX Dockerfile&lt;a class="headerlink" href="#342-nginx-dockerfile" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要创建一个NGINX Dockerfile, 用Dockerfile创建Docker镜像.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;CMD&lt;/code&gt;来在镜像实例化为容器时启动NGINX. 你需要在前台运行NGINX. 要这么做, 需要启动NGINX使用&lt;code&gt;-g "daemon off;"&lt;/code&gt;或增加&lt;code&gt;daemon off;&lt;/code&gt;到配置. 本例中稍后使用&lt;code&gt;daemon off;&lt;/code&gt;加到main context. 你也想调节你的access日志输出到&lt;code&gt;/dev/stdout&lt;/code&gt;, 错误日志输出到&lt;code&gt;/dev/stderr&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="s"&gt; centos:7&lt;/span&gt;
&lt;span class="c"&gt;# Install epel repo to get nginx and install nginx&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; yum -y install epel-release &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    yum -y install nginx
&lt;span class="c"&gt;# add local configuration files into the image&lt;/span&gt;
&lt;span class="k"&gt;ADD&lt;/span&gt; /nginx-conf /etc/nginx
&lt;span class="k"&gt;EXPOSE&lt;/span&gt;&lt;span class="s"&gt; 80 443&lt;/span&gt;
&lt;span class="k"&gt;CMD&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;nginx&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;目录结构如下所示:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;.
├── Dockerfile
└── nginx-conf
    ├── conf.d
    │   └── default.conf
    ├── fastcgi.conf
    ├── fastcgi_params
    ├── koi-utf
    ├── koi-win
    ├── mime.types
    ├── nginx.conf
    ├── scgi_params
    ├── uwsgi_params
    └── win-utf
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在本例中, 我选择直接吧nginx-conf目录下所有我的NGINX配置都添加到Dockerfile中.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;当你需要完全控制包的安装和升级, 你会发现创建自己的Dockerfile很有用. 常见操作是保存在你自己的镜像仓库中, 这样你会知道你的基础镜像在上生产之前是可靠的, 经过团队测试的.&lt;/p&gt;
&lt;h3 id="343-nginx-plus"&gt;3.4.3 构建NGINX Plus镜像&lt;a class="headerlink" href="#343-nginx-plus" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="344-nginx"&gt;3.4.4 在NGINX中使用环境变量&lt;a class="headerlink" href="#344-nginx" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;为了在不同的环境中使用相同的容器镜像, 你需要在NGINX配置文件中使用环境变量.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;ngx_http_perl_module&lt;/code&gt;来从你的环境的NGINX中设置变量.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;daemon&lt;/span&gt; &lt;span class="no"&gt;off&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;env&lt;/span&gt; &lt;span class="s"&gt;APP_DNS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;include&lt;/span&gt; &lt;span class="n"&gt;/usr/share/nginx/modules/*.conf&lt;/span&gt;;
&lt;span class="k"&gt;...&lt;/span&gt;
&lt;span class="s"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kn"&gt;perl_set&lt;/span&gt; &lt;span class="nv"&gt;$upstream_app&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;sub&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="nv"&gt;$ENV{&amp;quot;APP_DNS&amp;quot;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="kn"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kn"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;...&lt;/span&gt;
    &lt;span class="s"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="kn"&gt;proxy_pass&lt;/span&gt; &lt;span class="s"&gt;https://&lt;/span&gt;&lt;span class="nv"&gt;$upstream_app&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;要使用&lt;code&gt;perl_set&lt;/code&gt;, 你必须安装&lt;code&gt;ngx_http_perl_module&lt;/code&gt;; 你可以通过动态模块加载或从源码静态构建. NGINX默认从环境中擦除环境变量; 你需要在&lt;code&gt;env&lt;/code&gt;指令中声明任何你不想移除的变量. &lt;code&gt;perl_set&lt;/code&gt;指令有2个参数: 你想要设置的变量名和渲染结果的perl字符串.&lt;/p&gt;
&lt;p&gt;下面是一个Dockerfile, 会动态加载&lt;code&gt;ngx_http_perl_module&lt;/code&gt;, 从包管理工具安装该模块. 当从CentOS的包管理中安装模块, 他们被放在&lt;code&gt;/usr/lib64/nginx/modules/&lt;/code&gt;目录, 配置文件会动态加载在&lt;code&gt;/usr/share/nginx/modules/&lt;/code&gt;目录的模块. 这就是为什么上面的配置块中, 要包含完整的路径.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="s"&gt; centos:7&lt;/span&gt;
&lt;span class="c"&gt;# Install epel repo to get nginx and install nginx&lt;/span&gt;
&lt;span class="k"&gt;RUN&lt;/span&gt; yum -y install epel-release &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    yum -y install nginx nginx-mod-http-perl
&lt;span class="c"&gt;# add local configuration files into the image&lt;/span&gt;
&lt;span class="k"&gt;ADD&lt;/span&gt; /nginx-conf /etc/nginx
&lt;span class="k"&gt;EXPOSE&lt;/span&gt;&lt;span class="s"&gt; 80 443&lt;/span&gt;
&lt;span class="k"&gt;CMD&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;nginx&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;当使用Docker, 典型实践就是利用环境变量来修改容器操作的方式. 你可以在NGINX配置文件中使用环境变量, 这样NGINX可以用于多个, 不同的环境.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:28:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-4-nginx-docker.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category><category>docker</category></item><item><title>NGINX 实战手册-运维-使用Puppet/Chef/Ansible/SaltStack部署</title><link>https://www.EWhisper.cn/nginx-handbook-3-5-nginx-autoconf-tools.html</link><description>&lt;h2 id="35-puppetchefansiblesaltstack"&gt;3.5 使用Puppet/Chef/Ansible/SaltStack&lt;a class="headerlink" href="#35-puppetchefansiblesaltstack" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="350"&gt;3.5.0 介绍&lt;a class="headerlink" href="#350" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;在云的时代, 配置管理工具是无价之宝. 大规模web应用的工程师无法通过代码手把手配置servers, 但是使用其中任何一个配置管理工具都可以做到. 配置管理工具允许工程师一次写入配置和代码到很多有相同配置的server, 通过使用一种可重复, 可测试, 模块化的方式. 本章讨论几个流行的配置管理工具, 以及如何使用他们安装NIGINX和从模版创建一个基本配置. 这些例子非常基础, 但是展示了如何通过每个平台来启动NGINX.&lt;/p&gt;
&lt;h3 id="351-puppet"&gt;3.5.1 使用Puppet安装&lt;a class="headerlink" href="#351-puppet" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要通过Puppet安装和配置NGINX, 以代码形式管理NGINX配置, 并确认你的其他Puppet配置.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;创建一个模块, 用于安装NGINX, 管理你需要的文件, 确保NGINX在运行:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;nginx&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;package&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;nginx&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="k"&gt;ensure&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;installed&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,}&lt;/span&gt;
    &lt;span class="n"&gt;service&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;nginx&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;ensure&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;true&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;hasrestart&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;true&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;restart&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/etc/init.d/nginx reload&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="n"&gt;file&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;nginx.conf&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;path&lt;/span&gt;    &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/etc/nginx/nginx.conf&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="nb"&gt;require&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Package&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;nginx&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;notify&lt;/span&gt;  &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="no"&gt;Service&lt;/span&gt;&lt;span class="o"&gt;[&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;nginx&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;content&lt;/span&gt; &lt;span class="o"&gt;=&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;template&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;nginx/templates/nginx.conf.erb&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
        &lt;span class="n"&gt;user&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;root&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;group&lt;/span&gt;&lt;span class="o"&gt;=&amp;gt;&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;root&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
        &lt;span class="n"&gt;mode&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;0644&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该模块使用包管理工具来确保NGINX被安装. 也会确保NGINX在启动时在运行和可用. 该配置通知Puppet, 该服务有重启命令, 通过&lt;code&gt;hasrestart&lt;/code&gt;指令, 并且我们用NGINX reload命令覆盖&lt;code&gt;restart&lt;/code&gt;命令. 它通过内置Ruby(ERB)模版语言来管理和模板化&lt;code&gt;nginx.conf&lt;/code&gt;文件. 文件的模板化会发生在NGINX包被安装之后(通过&lt;code&gt;require&lt;/code&gt;指令). 但是, 它会通过&lt;code&gt;notify&lt;/code&gt;指令通知NGINX服务来reload. 该模版化配置文件没有包括. 另外, 它可以简单安装一个默认的NGINX配置文件, 或是使用内置Ruby(ERB)或内置Puppet(EPP)模版语言的循环和变量替换.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;Puppet是基于Ruby语言的配置管理工具. 模块被构建进一个特定域的语言, 并通过定义给定server配置的manifest文件调用. Puppet可以用主从或masterless模式运行. 使用Puppet, manifest运行在master上, 然后发到slave上. 这很重要, 因为它确保slave只是被交付对它有用的配置, 对其他server的其他配置是不会给这个slave的. Puppet有很多非常高级的公用模块. 通过这些模块, 会在配置上帮助你飞起. 在GitHub上来自voxpupuli的公共NGINX模块会为你模板化NGINX配置.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://docs.puppet.com/"&gt;Puppet documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jfgpm4"&gt;Puppet package documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jMq2cx"&gt;Puppet service documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jMz4q3"&gt;Puppet file documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2isqAlP"&gt;Puppet templating documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jMspMn"&gt;Voxpupuli NGINX module&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="352-chef"&gt;3.5.2 使用Chef安装&lt;a class="headerlink" href="#352-chef" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;略&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="353-ansible"&gt;3.5.3 使用Ansible安装&lt;a class="headerlink" href="#353-ansible" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要使用Ansible来安装和配置NGINX, 以代码形式管理NGINX配置, 并确认你的其他Ansible配置.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;创建一个安装NGINX和管理&lt;em&gt;nginx.conf&lt;/em&gt;文件playbook. 下列是一个示例的任务文件.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;NGINX | Installing NGINX&lt;/span&gt;
  &lt;span class="nt"&gt;package&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;name=nginx state=present&lt;/span&gt;

&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;NGINX | Starting NGINX&lt;/span&gt;
  &lt;span class="nt"&gt;service&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;nginx&lt;/span&gt;
    &lt;span class="nt"&gt;state&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;started&lt;/span&gt;
    &lt;span class="nt"&gt;enabled&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;yes&lt;/span&gt;
&lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;Copy nginx configuration in place.&lt;/span&gt;
  &lt;span class="nt"&gt;template&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nt"&gt;src&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;nginx.conf.j2&lt;/span&gt;
    &lt;span class="nt"&gt;dest&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/etc/nginx/nginx.conf&amp;quot;&lt;/span&gt;
    &lt;span class="nt"&gt;owner&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;root&lt;/span&gt;
    &lt;span class="nt"&gt;group&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;root&lt;/span&gt;
    &lt;span class="nt"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;0644&lt;/span&gt;
  &lt;span class="nt"&gt;notify&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;reload nginx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;package&lt;/code&gt;块安装NGINX. &lt;code&gt;service&lt;/code&gt;块确保NGINX在启动时被启动和可用. &lt;code&gt;template&lt;/code&gt;块模板化一个&lt;em&gt;Jinja2&lt;/em&gt;文件, 并把结果以root用户和组放到&lt;code&gt;/etc/nginx.conf&lt;/code&gt;中. 该模版块也设置&lt;em&gt;mode&lt;/em&gt;为644, 并通知nginx服务reload. 模板化配置文件没有包含在内. 但是, 可以通过默认的NGINX配置文件来简单, 或者通过Jinja2模版语言的循环和变量替换生成很复杂的模版.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;Ansible是用Python编写的广泛使用的强大配置管理工具. 任务配置使用YAML, 使用Jinja2模版语言生成文件模版. Ansible提供一个有master的叫做Ansible Tower的订阅版. 但是, 它经常用于本地机器或构建服务器直接到客户端或者使用masterless模式. Ansible打包SSH到它的server并运行配置. 和其他配置工具类似, 有很多社区提供的公共roles, Ansible把它叫做Ansible Galaxy. 你可以找到可以用于你的playbook的非常复杂的roles.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://docs.ansible.com/"&gt;Ansible documentation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jfiwGv"&gt;Ansible packages&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2jMGF7E"&gt;Ansible service&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2j8j526"&gt;Ansible template&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://galaxy.ansible.com/"&gt;Ansible Galaxy&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="354-saltstack"&gt;3.5.4 使用SaltStack安装&lt;a class="headerlink" href="#354-saltstack" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要使用SaltStack来安装和配置NGINX, 以代码形式管理NGINX配置, 并确认你的其他SaltStack配置.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;nginx&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;pkg&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;installed&lt;/span&gt;
  &lt;span class="nt"&gt;service&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;name&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;nginx&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;running&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;enable&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;True&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;reload&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;True&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;watch&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;file&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;/etc/nginx/nginx.conf&lt;/span&gt;

&lt;span class="nt"&gt;/etc/nginx/nginx.conf&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;file&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;managed&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;source&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;salt://path/to/nginx.conf&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;user&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;root&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;group&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;root&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;template&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;jinja&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;mode&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;644&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;require&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
      &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="nt"&gt;pkg&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;nginx&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:28:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-3-5-nginx-autoconf-tools.html</guid><category>nginx</category><category>devops</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-安全-实用安全技巧</title><link>https://www.EWhisper.cn/nginx-handbook-2-10-security-tips.html</link><description>&lt;h2 id="210"&gt;2.10 实用安全技巧&lt;a class="headerlink" href="#210" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="2100"&gt;2.10.0 介绍&lt;a class="headerlink" href="#2100" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;安全是分层的, 就像一个洋葱, 你的安全模型确实要被多层加固. 在这部分, 我们介绍许多不同的方法来确保web应用程序NGINX和NGINX Plus. 很多的这些安全方法可以用来加固安全. 下面是一些实用的安全提示,以确保您的用户在使用HTTPS和告诉NGINX满足一个或多个安全方法。&lt;/p&gt;
&lt;h3 id="2101-https"&gt;2.10.1 HTTPS 重定向&lt;a class="headerlink" href="#2101-https" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要重定向未加密的请求到HTTPS.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;rewrite&lt;/code&gt;来发送所有HTTP流量到HTTPS:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt; &lt;span class="s"&gt;default_server&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="s"&gt;[::]:80&lt;/span&gt; &lt;span class="s"&gt;default_server&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;server_name&lt;/span&gt; &lt;span class="s"&gt;_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;301&lt;/span&gt; &lt;span class="s"&gt;https://&lt;/span&gt;&lt;span class="nv"&gt;$host$request_uri&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个配置监听所有hostname的IPv4和IPv6的80端口作为默认的server. &lt;code&gt;return&lt;/code&gt;声明返回301永久重定向到同样的host和请求URI的HTTPS上.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;总是把适当的请求重定向到HTTPS是非常重要的. 你可能会发现你不需要重定向所有的请求, 而是在客户端和server之间传输敏感信息的那些请求. 在本例中, 你可能想要把&lt;code&gt;return&lt;/code&gt;声明放到特定的location里, 如&lt;code&gt;/login&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="2102-ssltlsnginxhttps"&gt;2.10.2 重定向SSL/TLS在NGINX之前已经结束的到HTTPS&lt;a class="headerlink" href="#2102-ssltlsnginxhttps" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要重定向到HTTPS, 然而, 在NGINX之前, 你已经结束了SSL/TLS.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用标准的&lt;code&gt;HTTP_X_Forwarded_Proto&lt;/code&gt; 头来决定是否你需要进行重定向:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt; &lt;span class="s"&gt;default_server&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="s"&gt;[::]:80&lt;/span&gt; &lt;span class="s"&gt;default_server&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;server_name&lt;/span&gt; &lt;span class="s"&gt;_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;if&lt;/span&gt; &lt;span class="s"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$http_x_forwarded_proto&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;http&amp;#39;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;301&lt;/span&gt; &lt;span class="s"&gt;https://&lt;/span&gt;&lt;span class="nv"&gt;$host$request_uri&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个配置和HTTPS重定向很像. 但是, 在这个配置中, 只有头&lt;code&gt;X_Forwarded_Proto&lt;/code&gt;等于HTTP才会重定向.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;这是一个在NGINX之前就结束了SSL/TLS的常见案例. 你可能要这么做的一个原因是节省计算开销. 但是, 你需要确保每个请求都是HTTPS, 但是结束了SSL/TLS的层没有重定向的能力. 但是, 可以设置代理头部. 这个配置可以在Amazon Web Services Elastic Load Balancer上工作, 因为这个如果没有额外的花钱的话就会卸载掉SSL/TLS. 这是一个方便的技巧以确保你的HTTP流量是安全的。&lt;/p&gt;
&lt;h3 id="2103"&gt;2.10.3 满足任意数量的安全方法&lt;a class="headerlink" href="#2103" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要提供多种方式来传输安全到一个不公开的站点.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;satisfy&lt;/code&gt;指令来说明你想要使用任意数量的安全方法:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;satisfy&lt;/span&gt; &lt;span class="s"&gt;any&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;allow&lt;/span&gt; &lt;span class="mi"&gt;192&lt;/span&gt;&lt;span class="s"&gt;.168.1.0/24&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;deny&lt;/span&gt;  &lt;span class="s"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;auth_basic&lt;/span&gt;           &lt;span class="s"&gt;&amp;quot;closed&lt;/span&gt; &lt;span class="s"&gt;site&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;auth_basic_user_file&lt;/span&gt; &lt;span class="s"&gt;conf/htpasswd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该配置告诉NGINX用户请求&lt;code&gt;location /&lt;/code&gt;需要满足其中的一个安全方法: 或者该请求需要来自&lt;em&gt;192.168.1.0/24&lt;/em&gt; CIDR block, 或者能够提供在可以在&lt;code&gt;conf/htpasswd&lt;/code&gt;中找到的用户名密码. &lt;code&gt;satisfy&lt;/code&gt;指令有2个选项: &lt;code&gt;any&lt;/code&gt;或&lt;code&gt;all&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;satifsy&lt;/code&gt;指令是一个提供多种认证的很好的方式. 通过指定&lt;code&gt;any&lt;/code&gt;给&lt;code&gt;satisfy&lt;/code&gt;指令, 用户必须满足其中一个安全. 指定&lt;code&gt;all&lt;/code&gt;给&lt;code&gt;satisfy&lt;/code&gt;指令, 用户必须满足所有的安全认证. 该指令可以和2.1的&lt;code&gt;http_access_module&lt;/code&gt;结合, 2.4的&lt;code&gt;http_auth_basic_module&lt;/code&gt;, 2.5的&lt;code&gt;http_auth_request_module&lt;/code&gt;, 2.7的&lt;code&gt;http_auth_jwt_module&lt;/code&gt;. 只有各个层都安全, 才是真正的安全. &lt;code&gt;satisfy&lt;/code&gt;指令会帮助你为这个location或server实现需要的深度安全规则.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:24:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-2-10-security-tips.html</guid><category>nginx</category><category>安全</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-安全-ModSecurity Web应用防火墙</title><link>https://www.EWhisper.cn/nginx-handbook-2-9-waf.html</link><description>&lt;h2 id="29-modsecurity-web"&gt;2.9 ModSecurity Web应用防火墙&lt;a class="headerlink" href="#29-modsecurity-web" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="290"&gt;2.9.0 介绍&lt;a class="headerlink" href="#290" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;ModSecurity 是一个开源的web应用防火墙(WAF), 首次被构建仅Apache web server. 在2012年, 它作为NGINX的一个模块可供使用, 2016加入NGINX Plus作为一个可选功能. 本章将详细介绍使用NGINX Plus的动态模块功能安装ModSecurity 3.0, 使用开源NGINX安装ModeSecurity 2.9. ModSecurity 3.0比ModSecurity 2.x的安全和性能更出众. 当从开源运行ModSecurity 2.9, 因为它仍然是在Apache上构造, 因此需要比3.0更多的开销, 而3.0是基于NGINX原生设计的.  ModSecurity 3.0 只能用于NGINX Plus订阅.&lt;/p&gt;
&lt;h3 id="291-nginx-plusmodesecurity"&gt;2.9.1 为NGINX Plus安装ModeSecurity&lt;a class="headerlink" href="#291-nginx-plusmodesecurity" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;略过&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="292-nginx-plusmodsecurity"&gt;2.9.2 在NGINX Plus中配置ModSecurity&lt;a class="headerlink" href="#292-nginx-plusmodsecurity" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要配置NGINX Plus使用ModSecurity模块.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;在NGINX Plus配置中启用动态模块, 使用&lt;code&gt;modsecurity_rules_file&lt;/code&gt;来指向一个ModSecurity规则文件:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;load_module modules/ngx_http_modsecurity.so;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;load_module&lt;/code&gt;指令适用于主context, 意味着该指令可以在打开HTTP或Stream块之前使用.&lt;/p&gt;
&lt;p&gt;开启ModeSecurity, 使用指定规则集:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;modsecurity&lt;/span&gt; &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;proxy_pass&lt;/span&gt; &lt;span class="s"&gt;http://backend&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;modsecurity_rules_file&lt;/span&gt; &lt;span class="s"&gt;rule-set-file&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
     &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;ModSecurity的规则可以阻止对常见的web servers和应用的漏洞利用. ModSecurity已知可以防御应用层的攻击, 如HTTP violations, SQL注入, 跨站脚本, 应用层, DDoS, 远程和本地文件攻击. 使用ModSecurity, 你可以订阅恶意用于的实时的黑名单, 来帮助在服务被攻击之前阻止问题. ModSecurity模块也可以启用日志帮助识别新的攻击模式和异常.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2fdZ7Dd"&gt;OWASP ModSecurity 核心规则集&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2eJYuAx"&gt;TrustWave ModSecurity 付费规则集&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="293-modsecurity"&gt;2.9.3 源码安装ModSecurity&lt;a class="headerlink" href="#293-modsecurity" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要在CentOS或RHEL系统上使用NGINX运行ModSecurity.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;从源码编译ModSecurity和NGINX来使用ModSecurity模块.&lt;/p&gt;
&lt;p&gt;首先升级security并安装依赖:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ yum --security update -y &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    yum -y install automake &lt;span class="se"&gt;\&lt;/span&gt;
    autoconf &lt;span class="se"&gt;\&lt;/span&gt;
    curl &lt;span class="se"&gt;\&lt;/span&gt;
    curl-devel &lt;span class="se"&gt;\&lt;/span&gt;
    gcc &lt;span class="se"&gt;\&lt;/span&gt;
    gcc-c++ &lt;span class="se"&gt;\&lt;/span&gt;
    httpd-devel &lt;span class="se"&gt;\&lt;/span&gt;
    libxml2 &lt;span class="se"&gt;\&lt;/span&gt;
    libxml2-devel &lt;span class="se"&gt;\&lt;/span&gt;
    make &lt;span class="se"&gt;\&lt;/span&gt;
    openssl &lt;span class="se"&gt;\&lt;/span&gt;
    openssl-devel &lt;span class="se"&gt;\&lt;/span&gt;
    perl &lt;span class="se"&gt;\&lt;/span&gt;
    wget
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来, 下载安装PCRE库:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; /opt &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    wget http://ftp.exim.org/pub/pcre/pcre-8.39.tar.gz &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    tar -zxf pcre-8.39.tar.gz &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="nb"&gt;cd&lt;/span&gt; pcre-8.39 &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    ./configure &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    make &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    make install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下载zlib源码并安装:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; /opt &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    wget http://zlib.net/zlib-1.2.8.tar.gz &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    tar -zxf zlib-1.2.8.tar.gz &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="nb"&gt;cd&lt;/span&gt; zlib-1.2.8 &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    ./configure &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    make &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    make install
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下载ModSecurity源码并安装:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; /opt &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  wget &lt;span class="se"&gt;\&lt;/span&gt;
  https://www.modsecurity.org/tarball/2.9.1/modsecurity-2.9.1.&lt;span class="se"&gt;\&lt;/span&gt;
tar.gz&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  tar -zxf modsecurity-2.9.1.tar.gz &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="nb"&gt;cd&lt;/span&gt; modsecurity-2.9.1 &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  ./configure --enable-standalone-module &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  make
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从源码下载安装NGINX, 并在配置脚本里包含你需要的所有模块. 本次我们的关注点是ModSecurity:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;cd&lt;/span&gt; /opt &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    wget http://nginx.org/download/nginx-1.11.4.tar.gz &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    tar zxf nginx-1.11.4.tar.gz &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="nb"&gt;cd&lt;/span&gt; nginx-1.11.4 &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    ./configure &lt;span class="se"&gt;\&lt;/span&gt;
        --sbin-path&lt;span class="o"&gt;=&lt;/span&gt;/usr/local/nginx/nginx &lt;span class="se"&gt;\&lt;/span&gt;
        --conf-path&lt;span class="o"&gt;=&lt;/span&gt;/etc/nginx/nginx.conf &lt;span class="se"&gt;\&lt;/span&gt;
        --pid-path&lt;span class="o"&gt;=&lt;/span&gt;/usr/local/nginx/nginx.pid &lt;span class="se"&gt;\&lt;/span&gt;
        --with-pcre&lt;span class="o"&gt;=&lt;/span&gt;../pcre-8.39 &lt;span class="se"&gt;\&lt;/span&gt;
        --with-zlib&lt;span class="o"&gt;=&lt;/span&gt;../zlib-1.2.8 &lt;span class="se"&gt;\&lt;/span&gt;
        --with-http_ssl_module &lt;span class="se"&gt;\&lt;/span&gt;
        --with-stream &lt;span class="se"&gt;\&lt;/span&gt;
        --with-http_ssl_module &lt;span class="se"&gt;\&lt;/span&gt;
        --with-http_secure_link_module &lt;span class="se"&gt;\&lt;/span&gt;
        --add-module&lt;span class="o"&gt;=&lt;/span&gt;../modsecurity-2.9.1/nginx/modsecurity &lt;span class="se"&gt;\&lt;/span&gt;
    &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    make &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    make install &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
    ln -s /usr/local/nginx/nginx /usr/bin/nginx
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这将会把ModSecurity 2.9.1 模块编译并和NGINX一起安装. 从现在开始, 我们可以使用&lt;code&gt;ModSecurityEnabled&lt;/code&gt;和&lt;code&gt;ModSecurityConfig&lt;/code&gt;指令:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt; &lt;span class="s"&gt;default_server&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="s"&gt;[::]:80&lt;/span&gt; &lt;span class="s"&gt;default_server&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;server_name&lt;/span&gt; &lt;span class="s"&gt;_&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
      &lt;span class="kn"&gt;ModSecurityEnabled&lt;/span&gt; &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
      &lt;span class="kn"&gt;ModSecurityConfig&lt;/span&gt; &lt;span class="s"&gt;modsecurity.conf&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;NGINX server的配置会为&lt;code&gt;location /&lt;/code&gt;启用ModSecurity, 并使用位于NGINX配置目录下的ModSecurity配置文件.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;这一节从NGINX源码编译, 并把ModSecurity编译到NGINX中. 推荐从源码编译NGINX的时候, 总是检查你是否使用了最新的稳定版的包. 通过之前的案例, 你可以使用有ModSecurity的开源版本的NGINX来构建你的开源web应用防火墙.&lt;/p&gt;
&lt;h4&gt;参见&lt;/h4&gt;
&lt;p&gt;&lt;a href="https://github.com/SpiderLabs/ModSecurity"&gt;ModSecurity源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="http://bit.ly/2eJYuAx"&gt;Updated and maintained ModSecurity Rules from SpiderLabs&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:22:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-2-9-waf.html</guid><category>nginx</category><category>安全</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-安全-安全链接</title><link>https://www.EWhisper.cn/nginx-handbook-2-6-secure-link.html</link><description>&lt;h2 id="26"&gt;2.6 安全链接&lt;a class="headerlink" href="#26" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="260"&gt;2.6.0 介绍&lt;a class="headerlink" href="#260" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;安全链接(secure links)是一种使用&lt;em&gt;md5&lt;/em&gt;哈希算法保证静态资源安全的方式. 使用这个模块, 你也可以限制该链接接收请求的时长. 使用安全链接使NGINX应用程序服务器确保静态内容安全而无需应用服务器承担这种责任. 这个模块包含在免费开源的NGINX里. 但是, 它没有打进标准的NGINX包, 而是放到了&lt;code&gt;nginx-extras&lt;/code&gt;包里. 当从源码构建NGINX时, 可以选择使用配置参数&lt;code&gt;--with-http_secure_link_module&lt;/code&gt;来启用.&lt;/p&gt;
&lt;h3 id="261-location"&gt;2.6.1 加密Location&lt;a class="headerlink" href="#261-location" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要使用一个密钥来加密一个location块.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用安全链接模块, &lt;code&gt;secure_link_secret&lt;/code&gt;指令来限制对资源的访问的用户有一个安全的链接:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/resources&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;secure_link_secret&lt;/span&gt; &lt;span class="s"&gt;mySecret&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;if&lt;/span&gt; &lt;span class="s"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$secure_link&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;403&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="kn"&gt;rewrite&lt;/span&gt; &lt;span class="s"&gt;^&lt;/span&gt; &lt;span class="s"&gt;/secured/&lt;/span&gt;&lt;span class="nv"&gt;$secure_link&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/secured&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;internal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;root&lt;/span&gt; &lt;span class="s"&gt;/var/www&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;该配置创建了一个内部和一个外部的location块. 外部的location块&lt;code&gt;/resources&lt;/code&gt;会返回403 Forbidden, 除非请求URI包含一个&lt;em&gt;md5&lt;/em&gt;哈希字符串, 这个字符串可以被&lt;code&gt;secure_link_secret&lt;/code&gt;指令提供的secret验证. &lt;code&gt;$secure_link&lt;/code&gt;变量是一个空字符串, 除非在URI的哈希被验证.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;使用secret加密资源是一个很好的确保你的文件受保护的方法. 该secret用于和URI串联 . 该字符串然后会被&lt;code&gt;md5&lt;/code&gt;哈希, &lt;code&gt;md5&lt;/code&gt;哈希后的16禁止数字被用在该URI中. 该哈希被放到链接中, 由NGINX计算. NGINX会知道URI想要访问的路径, 因为哈希后就在URI中 . NGINX也会直到你的secret, 因为指令&lt;code&gt;secure_link_secret&lt;/code&gt;会提供. NGINX能够迅速验证&lt;code&gt;md5&lt;/code&gt;哈希, 并存储在URI的&lt;code&gt;$secure_link&lt;/code&gt;变量中. 如果哈希无法验证, 该变量就是空字符串. 需要注意, 传给&lt;code&gt;secure_link_secret&lt;/code&gt;的参数必须是一个静态字符串, 不能是变量.&lt;/p&gt;
&lt;h3 id="262-secret"&gt;2.6.2 使用secret生成一个安全链接&lt;a class="headerlink" href="#262-secret" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要使用secret从你的应用生成一个安全链接.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;NGINX的安全链接模块接收一个md5哈希(URI路径和secret的联接)过的16进制字符串. 基于上一节, 我们会创建安全的连接, 可以工作在上个配置, 比如&lt;code&gt;/var/www/secured/index.html&lt;/code&gt;. 要生成md5哈希的16进制字符串, 我们可以使用Unix openssl命令:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; -n &lt;span class="s1"&gt;&amp;#39;index.htmlmySecret&amp;#39;&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; openssl md5 -hex
&lt;span class="o"&gt;(&lt;/span&gt;stdin&lt;span class="o"&gt;)=&lt;/span&gt; a53bee08a4bf0bbea978ddf736363a12
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;保护的URI: &lt;em&gt;index.html&lt;/em&gt;; secret: &lt;em&gt;mySecret&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;下边是使用Python 2.7和&lt;em&gt;md5&lt;/em&gt;库生成的:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;md5&lt;/span&gt;
&lt;span class="n"&gt;md5&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;index.htmlmySecret&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hexdigest&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="s1"&gt;&amp;#39;a53bee08a4bf0bbea978ddf736363a12&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;那么我们访问的地址应该是如下所示, 要访问&lt;code&gt;/var/www/secured/index.html&lt;/code&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;www.example.com/resources/a53bee08a4bf0bbea978ddf736363a12/\
index.html
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;要生成这个数字可以由很多种方式, 很多语言都可以实现. 要记住的是: URI路径在secret之前, 字符串中没有回车, 并且使用&lt;em&gt;md5&lt;/em&gt;哈希的16进制数字.&lt;/p&gt;
&lt;h3 id="263-expire-datelocation"&gt;2.6.3 使用Expire Date加密Location&lt;a class="headerlink" href="#263-expire-datelocation" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要生成一个在一段时间后过期的链接.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;利用在安全链接模块的其他指令来在你的加密链接中设置过期日志和使用变量:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;location&lt;/span&gt; &lt;span class="s"&gt;/resources&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;root&lt;/span&gt; &lt;span class="s"&gt;/var/www&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;secure_link&lt;/span&gt; &lt;span class="nv"&gt;$arg_md5,$arg_expires&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;secure_link_md5&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nv"&gt;$secure_link_expires$uri$remote_addr&lt;/span&gt;
   &lt;span class="s"&gt;mySecret&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;if&lt;/span&gt; &lt;span class="s"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$secure_link&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&amp;quot;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;403&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="kn"&gt;if&lt;/span&gt; &lt;span class="s"&gt;(&lt;/span&gt;&lt;span class="nv"&gt;$secure_link&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;0&amp;quot;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;410&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;secure_link&lt;/code&gt;指令有2个用逗号隔开的字段. 第一个字段是&lt;em&gt;md5&lt;/em&gt;哈希的变量. 这个例子使用一个HTTP参数的md5。第二个字段是放置以Unix元年时间格式的链接过期时间的变量. &lt;code&gt;secure_link_md5&lt;/code&gt;指令占用一个单独的字段, 声明用于构造&lt;em&gt;md5&lt;/em&gt;哈希的的格式的字符串. 和其他配置一样, 如果hash没有通过验证, &lt;code&gt;$secure_link&lt;/code&gt;变量设置为空字符串. 或者, 如果哈希匹配但是时间过期, &lt;code&gt;$secure_link&lt;/code&gt;变量设置为0.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;这种用法比之前2.6.1中的更灵活, 看起来更干净. 使用这些指令, 你可以使用可以用在NGINX哈希字符串中的任意数量的变量. 在哈希字符串中使用用户相关的变量会加强安全性, 因为用户不能够得到加密的资源. 推荐使用像是&lt;code&gt;$remote_addr&lt;/code&gt;或&lt;code&gt;$http_x_forwarded_for&lt;/code&gt;或由应用生成的会话cookie作为变量. &lt;code&gt;secure_link&lt;/code&gt;的参数可以来自你喜欢的任何变量, 他们可以被命名为任意合适的名字. 在&lt;code&gt;$secure_link&lt;/code&gt;变量中的条件可以被设置返回已知的Forbidder和Gone的HTTP代码. HTTP 410, Gone, 对于过期链接非常适用, 因为这个条件被认为是永久的.&lt;/p&gt;
&lt;h3 id="264"&gt;2.6.4 生成一个有过期时间的链接&lt;a class="headerlink" href="#264" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要生成一个有过期时间的链接.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;用Unix时间戳格式生成一个过期时间戳. 在Unix系统上, 你可以这样操作:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ date -d &lt;span class="s2"&gt;&amp;quot;2020-12-31 00:00&amp;quot;&lt;/span&gt; +%s
&lt;span class="m"&gt;1609390800&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;接下来你需要连接用在&lt;code&gt;secure_link_md5&lt;/code&gt;指令中的哈希字符串. 在本例中, 使用&lt;code&gt;1293771600/resources/index.html127.0.0.1  mySecret&lt;/code&gt;. md5哈希和刚刚的16进制数字有一些不同. 它是一个二进制格式的md5哈希, 采用base64加密, 用加号(+)转换为连接符(-), 斜杠(/)转换为下划线(_), 等号(=)被移除. 如下所示:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ &lt;span class="nb"&gt;echo&lt;/span&gt; -n &lt;span class="s1"&gt;&amp;#39;1609390800/resources/index.html127.0.0.1 mySecret&amp;#39;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="p"&gt;|&lt;/span&gt; openssl md5 -binary &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="p"&gt;|&lt;/span&gt; openssl base64 &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="p"&gt;|&lt;/span&gt; tr +/ -_ &lt;span class="se"&gt;\&lt;/span&gt;
  &lt;span class="p"&gt;|&lt;/span&gt; tr -d &lt;span class="o"&gt;=&lt;/span&gt;
81CYyxXFADhLHaQD36_BK
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;就得到了哈希, 我们可以用它后边跟着过期日期作为参数.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/resources/index.html?md5=81CYyxXFADhLHaQD36_BK&amp;amp;expires=1609390800'&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以下是使用Python 2.7的标准库的例子:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;datetime&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;datetime&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;base64&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;b64encode&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;md5&lt;/span&gt;
&lt;span class="n"&gt;resource&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;/resources/index.html&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;remote_addr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;127.0.0.1&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;host&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;www.example.com&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;expire&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;datetime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2020&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;31&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;strftime&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;uncoded&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;expire&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;resource&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;remote_addr&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39; mySecret&amp;#39;&lt;/span&gt;
&lt;span class="n"&gt;md5hashed&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;md5&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;new&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uncoded&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;digest&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;b64&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b64encode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;md5hashed&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;hash&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b64&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;+&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;-&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;/&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;_&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;replace&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;=&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;linkformat&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;{}{}?md5={}?expires{}&amp;quot;&lt;/span&gt;
&lt;span class="n"&gt;securelink&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;linkformat&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;host&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;resource&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;expire&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;使用这种方式, 我们能生成用于URL中的特殊格式的加密链接. 提供安全保障的secret绝不会发给客户端. 你可以用尽可能的你需要的其他变量来加密location. md5哈希和base64加密很常见, 轻量, 几乎在所有语言中都可用.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:15:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-2-6-secure-link.html</guid><category>nginx</category><category>安全</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-安全-使用JWT API的安全认证</title><link>https://www.EWhisper.cn/nginx-handbook-2-7-jwt-api-auth.html</link><description>&lt;h2 id="27-jwtapi"&gt;2.7 使用JWT的API认证&lt;a class="headerlink" href="#27-jwtapi" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="270"&gt;2.7.0 介绍&lt;a class="headerlink" href="#270" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;JSON Web Tokens (JWTs)迅速成为一种广为使用和受欢迎的认证方式. 这些认证tokens有能力存储一些用户和用户的认证信息到token里. 这些tokens也可以异步验证, 这意味着负载均衡和代理可以使用公钥来验证该token, 而不需要用于签发token的私钥, 以此提高安全和灵活性.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;NGINX Plus的功能, 略过.&lt;/p&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:15:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-2-7-jwt-api-auth.html</guid><category>nginx</category><category>安全</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-安全-HTTP 子请求认证</title><link>https://www.EWhisper.cn/nginx-handbook-2-5-http-subrequest-auth.html</link><description>&lt;h3 id="251"&gt;2.5.1 介绍&lt;a class="headerlink" href="#251" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;伴随着很多不同的认证方法, NGINX通过启用自请求mid-flight 来使验证认证广泛的认证系统变得容易. HTTP认证请求模块可以启用如LDAP或自定义认证微服务的认证系统. 在请求被执行之前, 认证机制会代理该请求到认证服务. 在这个代理中, 通过NGINX的能力可以操纵需要身份验证服务的请求。因此,它非常灵活。&lt;/p&gt;
&lt;h3 id="252"&gt;2.5.2 认证子请求&lt;a class="headerlink" href="#252" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你有一个第三方的认证系统, 请求认证需要用到这个系统.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;http_auth_request_module&lt;/code&gt;在请求执行前, 让请求到对应的认证服务来进行验证:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;private&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="err"&gt;auth_request&lt;/span&gt; &lt;span class="err"&gt;/auth&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="err"&gt;auth_request_set&lt;/span&gt; &lt;span class="err"&gt;$auth_status&lt;/span&gt; &lt;span class="err"&gt;$upstream_status&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="nt"&gt;auth&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="err"&gt;internal&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="err"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;http&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;auth-server&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="err"&gt;proxy_pass_request_body&lt;/span&gt; &lt;span class="err"&gt;off&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="err"&gt;proxy_set_header&lt;/span&gt; &lt;span class="err"&gt;Content-length&lt;/span&gt; &lt;span class="err"&gt;&amp;quot;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="err"&gt;proxy_set_header&lt;/span&gt; &lt;span class="err"&gt;X-Original-URI&lt;/span&gt; &lt;span class="err"&gt;$request_uri&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;auth_request&lt;/code&gt;指令使用必须是local internal location的URI参数. &lt;code&gt;auth_request_set&lt;/code&gt;指令允许你从认证自请求来设置变量.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;http_auth_request_module&lt;/code&gt;允许对每个NGINX处理的请求做认证. 在响应原服务之前, 会生成一个子请求, 来决定这个请求是否可以访问它请求的资源.  整个请求会被代理到自请求块 location. 通过自请求的状态码来确定是否可以访问资源. 如果自请求返回200 HTTP 状态码, 认证成功, 请求被响应. 如果返回HTTP 401或403, 会向原请求返回同样的代码.&lt;/p&gt;
&lt;p&gt;如果你的认证服务不需要请求body, 你可以抛弃掉请求body, 通过&lt;code&gt;proxy_pass_reqeust_body&lt;/code&gt;指令(如上例子所示). 这会减少请求size和时间. 因为请求体被忽略, &lt;code&gt;Content-Length&lt;/code&gt; header可以设为空字符串. 如果你的认证服务需要直到原请求的URI, 你可以把这个值放到一个自定义的header, 让你的认证服务来检查和验证. 如果从子请求到认证服务见你想要保留一些东西, 你可以使用  &lt;code&gt;auth_request_set&lt;/code&gt;指令来创建相应数据之外新的变量.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:13:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-2-5-http-subrequest-auth.html</guid><category>nginx</category><category>安全</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-安全-加密</title><link>https://www.EWhisper.cn/nginx-handbook-2-3-encrypt.html</link><description>&lt;h2 id="23"&gt;2.3 加密&lt;a class="headerlink" href="#23" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="230"&gt;2.3.0 介绍&lt;a class="headerlink" href="#230" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;网络是个很可怕的地方, 但不需太过担心. 加密传输信息变得越来越容易, 越来越唾手可得, 因为签名证书在&lt;em&gt;Let's Encrypt&lt;/em&gt;和&lt;em&gt;Amazon Web Services&lt;/em&gt;变得越来越便宜. 二者都提供有限用途的免费证书. 在本章, 我们将讨论如何确保NGINX和客户端之间, 以及NGINX和upstream之间的信息安全.&lt;/p&gt;
&lt;h3 id="231"&gt;2.3.1 客户端加密&lt;a class="headerlink" href="#231" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;需要加密NGINX和客户端之间的流量.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用SSL模块, 如&lt;code&gt;ngx_http_ssl_module&lt;/code&gt;或&lt;code&gt;ngx_stream_ssl_module&lt;/code&gt;来加密流量.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;All&lt;/span&gt; &lt;span class="err"&gt;directives&lt;/span&gt; &lt;span class="err"&gt;used&lt;/span&gt; &lt;span class="err"&gt;below&lt;/span&gt; &lt;span class="err"&gt;are&lt;/span&gt; &lt;span class="err"&gt;also&lt;/span&gt; &lt;span class="err"&gt;valid&lt;/span&gt; &lt;span class="err"&gt;in&lt;/span&gt; &lt;span class="err"&gt;stream&lt;/span&gt;
    &lt;span class="err"&gt;server&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
        &lt;span class="err"&gt;listen&lt;/span&gt; &lt;span class="err"&gt;8083&lt;/span&gt; &lt;span class="err"&gt;ssl&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="err"&gt;ssl_protocols&lt;/span&gt;       &lt;span class="err"&gt;TLSv1.2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;协议&lt;/span&gt;
        &lt;span class="err"&gt;ssl_ciphers&lt;/span&gt;         &lt;span class="n"&gt;AES128-SHA&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;AES256-SHA&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;密码套件&lt;/span&gt;
        &lt;span class="err"&gt;ssl_certificate&lt;/span&gt;     &lt;span class="err"&gt;/usr/local/nginx/conf/cert.pem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;证书&lt;/span&gt;
        &lt;span class="err"&gt;ssl_certificate_key&lt;/span&gt; &lt;span class="err"&gt;/usr/local/nginx/conf/cert.key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;密钥&lt;/span&gt;
        &lt;span class="err"&gt;ssl_session_cache&lt;/span&gt;   &lt;span class="n"&gt;shared&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;SSL&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;ssl会话缓存&lt;/span&gt;
        &lt;span class="err"&gt;ssl_session_timeout&lt;/span&gt; &lt;span class="err"&gt;10m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="err"&gt;#&lt;/span&gt; &lt;span class="err"&gt;ssl会话超时&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;讨论&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;不要使用SSL(Secure Socket Layer)协议, 1 - 3版都被认为不安全&lt;/li&gt;
&lt;li&gt;TLS是默认的协议(Transport Layer Security), TLS还算安全.&lt;/li&gt;
&lt;li&gt;当使用签名证书, 你需要把证书和证书认证链连接到一块. 你的证书应该在证书链文件的上方.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;SSL会话缓存, 缓存后无需negotiate 版本和密码套件, 可以提升性能.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="232-upstream"&gt;2.3.2 Upstream 加密&lt;a class="headerlink" href="#232-upstream" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;为了合规, 或者你的upstream在你的安全网络之外, 你需要加密NGINX和upstream之间的流量.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;使用HTTP 代理模块的SSL指令&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="err"&gt;proxy_pass&lt;/span&gt; &lt;span class="n"&gt;https&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="n"&gt;upstream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;example&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;proxy_ssl_verify&lt;/span&gt; &lt;span class="err"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;proxy_ssl_verify_depth&lt;/span&gt; &lt;span class="err"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="err"&gt;proxy_ssl_protocols&lt;/span&gt; &lt;span class="err"&gt;TLSv1.2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;配置的指令确保NGINX在upsteam上验证证书和证书链2层认证深度是合法的. 默认NGINX&lt;strong&gt;不验证&lt;/strong&gt;upstream证书, 接收所有TLS版本.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;如果要加密upstream 流量, 你至少应该开启验证.&lt;/li&gt;
&lt;li&gt;其他可用指令, 如&lt;code&gt;proxy_ssl_certificate&lt;/code&gt;和&lt;code&gt;proxy_ssl_certificate_key&lt;/code&gt;, 允许你锁定upstream加密以增强安全性.&lt;/li&gt;
&lt;/ul&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:08:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-2-3-encrypt.html</guid><category>nginx</category><category>安全</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-安全-HTTP 基本认证</title><link>https://www.EWhisper.cn/nginx-handbook-2-4-http-basic-auth.html</link><description>&lt;h2 id="24-http"&gt;2.4 HTTP基本认证&lt;a class="headerlink" href="#24-http" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="240"&gt;2.4.0 介绍&lt;a class="headerlink" href="#240" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;基本认证是一个保护私有内容的简单方法. 这个认证方法可以很容易的用于隐藏&lt;strong&gt;开发网站&lt;/strong&gt;或者隐藏特权的内容. 推荐在需要基本认证的locations或servers上设置一个速率限制来组织暴力攻击. 也推荐如上章那样, 使用HTTPS, 因为每个认证请求, 用户名和密码是通过base64加密字符串, 作为一个header发送到server的. 如果使用HTTP, 意味着用户名和密码都可以被捕获.&lt;/p&gt;
&lt;h3 id="241-user-file"&gt;2.4.1 创建一个User File&lt;a class="headerlink" href="#241-user-file" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要一个HTTP基本认证用户文件来存储用户名和密码.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;生成一个下列格式的文件, 密码可以通过以下允许的格式来加密或哈希:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;# comment
name1:password1
name2:password2:comment
name3:password3
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;NGINX可以理解几种格式的密码, 其中一种加密是用C函数&lt;code&gt;crypt()&lt;/code&gt;. 该函数被暴露给&lt;code&gt;openssl passwd&lt;/code&gt;命令, 可以用如下方式生成加密字符串:&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$ openssl passwd MyPassword1234&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;会输出一个字符串, NGINX可以用在密码文件里.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;也可以用Apache的&lt;code&gt;htpasswd&lt;/code&gt;来生成密码. &lt;code&gt;htpasswd&lt;/code&gt;和&lt;code&gt;openssl&lt;/code&gt; 都会生成&lt;em&gt;apr1&lt;/em&gt; 算法的密码. 密码也可以用LDAP和Dovecot使用的加盐sha-1 格式. NGINX支持更多的格式和哈希算法, 但是, 大部分都被认为不安全, 因为可以被轻易破解.&lt;/p&gt;
&lt;h3 id="242"&gt;2.4.2 使用基本认证&lt;a class="headerlink" href="#242" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要用基本认证来保护NGINX location或server.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;location / {
    auth_basic          &amp;quot;Private site&amp;quot;;
    auth_basic_user_file conf.d/passwd;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;code&gt;auth_basic&lt;/code&gt;指令可以用于HTTP, server, 或location块里. 当未认证用户访问, &lt;code&gt;auth_basic&lt;/code&gt;指令会把字符串显示到基本认证的弹出窗口.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;基本认证通过server返回一个带有&lt;code&gt;WWW-Authenticate&lt;/code&gt;的401未认证HTTP code. 该header会有一个值&lt;code&gt;Basic realm="your string."&lt;/code&gt;. 该响应会导致浏览器提示输入用户名和密码. 输入的用户名和密码会通过base64加密, 通过一个叫做&lt;code&gt;Authorization&lt;/code&gt;的请求头发送. Server会机密密码, 并根据&lt;code&gt;auth_basic_user_file&lt;/code&gt;提供的密码做验证. 因为用户名密码仅仅是通过base64加密. 所以推荐使用HTTPS传输.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:08:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-2-4-http-basic-auth.html</guid><category>nginx</category><category>安全</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-安全-限制使用</title><link>https://www.EWhisper.cn/nginx-handbook-2-2-limit-usage.html</link><description>&lt;h2 id="22"&gt;2.2 限制使用&lt;a class="headerlink" href="#22" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="220"&gt;2.2.0 介绍&lt;a class="headerlink" href="#220" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;该章节关注于: 限制使用和滥用, 连接数, 请求服务速率, 带宽使用量. 区分开连接和请求是很重要的: 连接(TCP连接)是网络层, 在这层上, 请求被执行, 因此两者并不一样.&lt;/p&gt;
&lt;p&gt;在HTTP/1和HTTP/1.1中, 一个连接请求只能使用一次; 而在HTTP/2中, 多个请求可以使用同一个TCP连接.&lt;/p&gt;
&lt;h3 id="221"&gt;2.2.1 限制连接&lt;a class="headerlink" href="#221" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要基于预定义的key来限制连接数, 比如key是客户端IP地址.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;创建一个共享内存区域来存放连接metrics, 并使用&lt;code&gt;limit_conn&lt;/code&gt; 指令来限制打开的连接数:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kn"&gt;limit_conn_zone&lt;/span&gt; &lt;span class="nv"&gt;$binary_remote_addr&lt;/span&gt; &lt;span class="s"&gt;zone=limitbyaddr:10m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kn"&gt;limit_conn_status&lt;/span&gt; &lt;span class="mi"&gt;429&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kn"&gt;...&lt;/span&gt;
  &lt;span class="s"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;...&lt;/span&gt;
      &lt;span class="s"&gt;limit_conn&lt;/span&gt; &lt;span class="s"&gt;limitbyaddr&lt;/span&gt; &lt;span class="mi"&gt;40&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;...&lt;/span&gt;
  &lt;span class="err"&gt;}&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;img align="absmiddle" alt="✔" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2714.png" title=":heavy_check_mark:" width="20px"&gt;  &lt;/p&gt;
&lt;p&gt;429: Too Many Requests&lt;/p&gt;
&lt;p&gt;预定义的key用的是:二进制格式的客户端IP地址.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;使用IP地址, 就像上个例子中那样, 如果很多用户都在同一个网络来自同一个IP可能很危险, 比如用的是一个NAT(网络地址转换). 整个组都会被限制. &lt;code&gt;limit_conn_zone&lt;/code&gt;指令只适用于HTTP块. 可以利用在HTTP块中的NGINX的任何变量来构建一个字符串来限制. 利用变量可以在应用级别识别具体的用户, 像是session cookie, 基于使用案例可能是一个更干净的解决方案. &lt;code&gt;limit_conn&lt;/code&gt;和&lt;code&gt;limit_conn_status&lt;/code&gt;指令在HTTP, server, 和location块中都能用. &lt;code&gt;limit_conn_status&lt;/code&gt;默认是503, 服务不可用. 429会更合适, 因为500界别的服务不可用意味着错误.&lt;/p&gt;
&lt;h3 id="222"&gt;2.2.2 限制速率&lt;a class="headerlink" href="#222" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;h4&gt;问题&lt;/h4&gt;
&lt;p&gt;你需要基于预定义的key来限制请求速率, 比如客户端IP地址.&lt;/p&gt;
&lt;h4&gt;解决方案&lt;/h4&gt;
&lt;p&gt;利用速率限制模块来限制:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;http&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="kn"&gt;limit_req_zone&lt;/span&gt; &lt;span class="nv"&gt;$binary_remote_addr&lt;/span&gt; &lt;span class="s"&gt;zone=limitbyaddr:10m&lt;/span&gt; &lt;span class="s"&gt;rate=1r/s&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kn"&gt;limit_req_status&lt;/span&gt; &lt;span class="mi"&gt;429&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kn"&gt;...&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="kn"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;...&lt;/span&gt;
      &lt;span class="s"&gt;limit_req&lt;/span&gt; &lt;span class="s"&gt;zone=limitbyaddr&lt;/span&gt; &lt;span class="s"&gt;burst=10&lt;/span&gt; &lt;span class="s"&gt;nodelay&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;...&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个zone用关键字参数设置了速率. &lt;code&gt;limit_req&lt;/code&gt;指令有2个关键字参数: &lt;code&gt;zone&lt;/code&gt;和&lt;code&gt;burst&lt;/code&gt;. 当给定zone的请求速率超出了, 请求会延迟直到达到他们的最大burst size, 这个由&lt;code&gt;burst&lt;/code&gt;关键字参数提供. 默认&lt;code&gt;burst&lt;/code&gt;关键字参数为0. &lt;code&gt;limit_req&lt;/code&gt;也有第三个可选的参数, &lt;code&gt;nodelay&lt;/code&gt;. 这个参数允许客户端在被限制之前使用它的&lt;code&gt;burst&lt;/code&gt;而不用延迟. &lt;code&gt;limit_req_status&lt;/code&gt; 和&lt;code&gt;limit_req&lt;/code&gt; 可以用在HTTP, server, 和location. &lt;code&gt;limit_req_zone&lt;/code&gt;只适用于HTTP块.&lt;/p&gt;
&lt;h4&gt;讨论&lt;/h4&gt;
&lt;p&gt;速率限制模块在组织恶意请求, 同时仍为每个人提供一定质量的服务时非常有用. 有很多限制请求速率的原因, 其中之一就是安全. 你可以通过在你的登陆页面设置非常严格的限制来防止恶意攻击. 你可以通过设置对所有请求的完善的限制来阻止恶意用户尝试对你的应用使用拒绝式服务攻击或浪费资源的计划. 速率限制模块的配置和2.2.1中的很类似. 速率可以被设置为每秒多少请求或每分钟多少请求. 当超过限制, 会记录事件日志. 例子中没有提到这个指令&lt;code&gt;limit_req_log_level&lt;/code&gt; , 默认是&lt;code&gt;error&lt;/code&gt;, 但是也可以设置为&lt;code&gt;info&lt;/code&gt; , &lt;code&gt;notice&lt;/code&gt;, &lt;code&gt;warn&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="223"&gt;2.2.3 限制带宽&lt;a class="headerlink" href="#223" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;待补充&lt;/p&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:05:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-2-2-limit-usage.html</guid><category>nginx</category><category>安全</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 实战手册-安全-访问控制</title><link>https://www.EWhisper.cn/nginx-handbook-2-1-control-access.html</link><description>&lt;h2 id="211"&gt;2.1.1 介绍&lt;a class="headerlink" href="#211" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;控制你的web应用或你的web应用的子网的访问是很重要的业务. 在NGINX中, 访问控制有多种形式, 像是在网络层拒绝掉, 基于认证策略的允许, 或 HTTP指令浏览器如何响应. 本章我们将讨论基于网络属性, 认证和如何防止&lt;em&gt;跨域资源共享(Cross-Origin Resource Sharing(CORS))&lt;/em&gt;的访问控制.&lt;/p&gt;
&lt;h2 id="212-ip"&gt;2.1.2 基于IP地址的访问&lt;a class="headerlink" href="#212-ip" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="_1"&gt;问题&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;你需要基于客户端的IP地址的控制.&lt;/p&gt;
&lt;h3 id="_2"&gt;解决方案&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;使用HTTP访问模块来控制对受保护资源的访问:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;location&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="err"&gt;deny&lt;/span&gt; &lt;span class="err"&gt;10.0.0.1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="err"&gt;allow&lt;/span&gt; &lt;span class="err"&gt;10.0.0.0/20&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="err"&gt;allow&lt;/span&gt; &lt;span class="err"&gt;2001:0&lt;/span&gt;&lt;span class="n"&gt;db8&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;:/&lt;/span&gt;&lt;span class="mi"&gt;32&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="err"&gt;deny&lt;/span&gt; &lt;span class="err"&gt;all&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在HTTP, server, 和location上下文中, &lt;code&gt;allow&lt;/code&gt;和&lt;code&gt;deny&lt;/code&gt;指令提供对给出的client, IP, CIDR range, Unix socket, 或all 关键字的允许和禁止访问的能力. 规则被依次检查, 直到发现匹配的地址.&lt;/p&gt;
&lt;h3 id="_3"&gt;讨论&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;保护在互联网上的有价值的资源和服务必须在对应的层上做. NGINX提供对其中一些层的能力. &lt;code&gt;deny&lt;/code&gt; 指令组织访问给定的上下文, &lt;code&gt;allow&lt;/code&gt;指令可以用于限制访问. 你可以使用IP地址, IPv4或IPv6, CIDR block ranges, 关键字&lt;code&gt;all&lt;/code&gt;, 和Unix socket. 通常要保护某个资源, 应该允许特定区域的内网IP地址, 并拒绝所有.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 20:00:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-handbook-2-1-control-access.html</guid><category>nginx</category><category>安全</category><category>译文</category><category>最佳实践</category></item><item><title>NGINX 配置SSL 支持</title><link>https://www.EWhisper.cn/nginx-conf-add-ssl-support.html</link><description>&lt;p&gt;&lt;img alt="nginx+ssl" src="./images/nginx-ssl-certificate.jpg"&gt;&lt;/p&gt;
&lt;h2 id="_1"&gt;前言&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://www.EWhisper.cn/tencentyun-apply-ssl-certificate.html"&gt;上篇文章&lt;/a&gt;中, 我们已经申请好了SSL证书. 那么现在, 我们就要配置全站SSL了! &lt;img align="absmiddle" alt="💪" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f4aa.png" title=":muscle:" width="20px"&gt;&lt;img align="absmiddle" alt="💪" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f4aa.png" title=":muscle:" width="20px"&gt;&lt;img align="absmiddle" alt="💪" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f4aa.png" title=":muscle:" width="20px"&gt;&lt;/p&gt;
&lt;p&gt;这次的工作主要是NGINX的配置, 同时会有一些我的博客本身的配置.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;博客本身配置更改包括: (这篇文章就先不细说了)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网页内链接全部从http改为https(其实配置下SITEURL, 工具会自动生成好) 并重新发布. (特别要注意, 如果有的站内css, js等没有用https就尴尬了, 会被各类浏览器拦截掉, 并提示"不安全的脚本")&lt;/li&gt;
&lt;li&gt;网站有用到的第三方工具(如拨测), 把网站的地址改为 https开头的.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id="nginx"&gt;NGINX配置&lt;a class="headerlink" href="#nginx" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;首先, 创建并上传准备好的证书文件到指定目录: (crt和key文件)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo mkdir -p /etc/pki/nginx/
&lt;span class="c1"&gt;# 通过sftp上传到该目录&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;进行nginx.conf 的ssl配置, 本次主要涉及到server块的配置更改, 如下: (具体的指令作用见注释)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;listen&lt;/span&gt;       &lt;span class="mi"&gt;80&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;server_name&lt;/span&gt;  &lt;span class="s"&gt;www.ewhisper.cn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;301&lt;/span&gt; &lt;span class="s"&gt;https://&lt;/span&gt;&lt;span class="nv"&gt;$host$request_uri&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="kn"&gt;listen&lt;/span&gt;       &lt;span class="mi"&gt;443&lt;/span&gt; &lt;span class="s"&gt;ssl&lt;/span&gt; &lt;span class="s"&gt;http2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;server_name&lt;/span&gt;  &lt;span class="s"&gt;www.ewhisper.cn&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="kn"&gt;root&lt;/span&gt;         &lt;span class="s"&gt;/usr/share/nginx/html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# 静态博客的存放位置&lt;/span&gt;

        &lt;span class="kn"&gt;ssl_certificate&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/etc/pki/nginx/1_www.ewhisper.cn_bundle.crt&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# 证书路径&lt;/span&gt;
        &lt;span class="kn"&gt;ssl_certificate_key&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;/etc/pki/nginx/2_www.ewhisper.cn.key&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# 证书密钥路径&lt;/span&gt;
        &lt;span class="kn"&gt;ssl_session_cache&lt;/span&gt; &lt;span class="s"&gt;shared:SSL:50m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# ssl session cache分配50m空间, 缓存ssl session&lt;/span&gt;
        &lt;span class="kn"&gt;ssl_session_timeout&lt;/span&gt;  &lt;span class="s"&gt;1d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# ssl session 超时时间为1天&lt;/span&gt;
        &lt;span class="kn"&gt;ssl_session_tickets&lt;/span&gt; &lt;span class="no"&gt;off&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# ssl session ticket 机制, 部分版本有bug, 视情况开启.&lt;/span&gt;

        &lt;span class="kn"&gt;ssl_protocols&lt;/span&gt; &lt;span class="s"&gt;TLSv1.2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# ssl 协议版本&lt;/span&gt;
        &lt;span class="kn"&gt;ssl_ciphers&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# ssl ciphers&lt;/span&gt;
        &lt;span class="kn"&gt;ssl_prefer_server_ciphers&lt;/span&gt; &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# 倾向于使用server端的ciphers&lt;/span&gt;

        &lt;span class="c1"&gt;# HSTS 6 months&lt;/span&gt;
        &lt;span class="kn"&gt;add_header&lt;/span&gt; &lt;span class="s"&gt;Strict-Transport-Security&lt;/span&gt; &lt;span class="s"&gt;max-age=15768000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  
        &lt;span class="c1"&gt;# 添加个http header, 告诉浏览器直接转到https, 此功能有风险, 慎重选择. &lt;/span&gt;
        &lt;span class="c1"&gt;# (比如你的证书过期忘记续了, 那么用户想转到http都没办法)&lt;/span&gt;

        &lt;span class="kn"&gt;ssl_stapling&lt;/span&gt; &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# 启用ssl OCSP stapling功能, 服务端主动查询OCSP结果, 提高TLS效率&lt;/span&gt;
        &lt;span class="kn"&gt;ssl_stapling_verify&lt;/span&gt; &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# 开启OCSP stapling 验证&lt;/span&gt;

        &lt;span class="c1"&gt;# Load configuration files for the default server block.&lt;/span&gt;
        &lt;span class="kn"&gt;include&lt;/span&gt; &lt;span class="s"&gt;/etc/nginx/default.d/*.conf&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;  &lt;span class="c1"&gt;# 我的博客的location在这里配置&lt;/span&gt;

        &lt;span class="c1"&gt;#location / {&lt;/span&gt;
        &lt;span class="c1"&gt;#}&lt;/span&gt;

        &lt;span class="kn"&gt;error_page&lt;/span&gt; &lt;span class="mi"&gt;404&lt;/span&gt; &lt;span class="s"&gt;/404.html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/40x.html&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="kn"&gt;error_page&lt;/span&gt; &lt;span class="mi"&gt;500&lt;/span&gt; &lt;span class="mi"&gt;502&lt;/span&gt; &lt;span class="mi"&gt;503&lt;/span&gt; &lt;span class="mi"&gt;504&lt;/span&gt; &lt;span class="s"&gt;/50X.html&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="kn"&gt;location&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="s"&gt;/50X.html&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;blockquote&gt;
&lt;p&gt;&lt;img align="absmiddle" alt="📓" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f4d3.png" title=":notebook:" width="20px"&gt; 说明:&lt;/p&gt;
&lt;p&gt;以上的某些指令, 我先大概介绍下, 后续会有文章做详细介绍.&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;return 301 https://$host$request_uri;&lt;/code&gt;   HTTP的全部永久重定向到https对应的URL&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/usr/share/nginx/html&lt;/code&gt;  静态博客的存放位置&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ssl_session_timeout  1d;&lt;/code&gt;  ssl session 超时时间为1天&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ssl_session_tickets off;  #&lt;/code&gt;  ssl session ticket 机制, 部分版本有bug, 视情况开启.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ssl_prefer_server_ciphers on;&lt;/code&gt;  倾向于使用server端的ciphers&lt;/li&gt;
&lt;li&gt;HSTS功能:　添加个HTTP header, 告诉浏览器直接转到https, &lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;此功能有风险, 慎重选择.  (比如你的证书过期忘记续了, 那么用户想转到HTTP都没办法)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ssl_stapling on;&lt;/code&gt;  启用ssl OCSP stapling功能, 服务端主动查询OCSP结果, 提高TLS握手效率&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/etc/nginx/default.d/*.conf;&lt;/code&gt;  我的博客&lt;code&gt;location&lt;/code&gt;配置&lt;br&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img align="absmiddle" alt="📓" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f4d3.png" title=":notebook:" width="20px"&gt; 小技巧:&lt;/p&gt;
&lt;p&gt;火狐浏览器背后的基金会, 开源了一个非常好用的工具: &lt;a href="https://mozilla.github.io/server-side-tls/ssl-config-generator/"&gt;ssl-config-generator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在这上边, 点一点就可以自动生成推荐的SSL配置了.&lt;/p&gt;
&lt;p&gt;&lt;img alt="ssl-config-generator" src="./images/ssl-config-generator.png"&gt;&lt;/p&gt;
&lt;p&gt;提一点, 如上图所示, 第二列一定要根据你的客户浏览器或客户端的版本使用情况慎重选择. &lt;/p&gt;
&lt;p&gt;比如, 用户还在用Windows XP, IE6, Java 6, 那么只能选择Old.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;接下来, 就是要重启nginx来生效了. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;$ sudo nginx -t  &lt;span class="c1"&gt;# 测试配置, 没问题再重启&lt;/span&gt;
$ sudo systemctl reload nginx.service
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;重启后, 测试发现 css js都没有生效. &lt;img align="absmiddle" alt="😱" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f631.png" title=":scream:" width="20px"&gt;&lt;img align="absmiddle" alt="😱" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f631.png" title=":scream:" width="20px"&gt;&lt;img align="absmiddle" alt="😱" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f631.png" title=":scream:" width="20px"&gt;&lt;/p&gt;
&lt;p&gt;因为之前nginx刚配置过缓存. 当时脑子没转过来, 没有第一时间意识到可能是浏览器缓存的问题. 就直接nginx stop 再start了下. 结果悲催的我的网站可用性就从100%跌到99.81%了.&lt;/p&gt;
&lt;p&gt;&lt;img alt="网站可用性" src="images/index.png"&gt;&lt;/p&gt;
&lt;p&gt;后来终于意识到可能是浏览器缓存的问题了, 清理了缓存后, 再启动, 终于页面显示正常, 图标也从"不安全"变成了小锁.&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="./images/ssl-ewhisper.png"&gt;&lt;/p&gt;
&lt;p&gt;测试访问http://www.ewhisper.cn, 也会被强制转到 https://www.ewhisper.cn. 完美!&lt;img align="absmiddle" alt="🎉" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f389.png" title=":tada:" width="20px"&gt;&lt;img align="absmiddle" alt="🎉" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f389.png" title=":tada:" width="20px"&gt;&lt;img align="absmiddle" alt="🎉" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f389.png" title=":tada:" width="20px"&gt;&lt;/p&gt;
&lt;h2 id="ssl"&gt;我的SSL评级&lt;a class="headerlink" href="#ssl" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;再来介绍个好东西 - &lt;a href="https://www.ssllabs.com/ssltest/analyze.html"&gt;SSL Labs&lt;/a&gt;. 可以对你的网站进行SSL 安全评级. &lt;/p&gt;
&lt;p&gt;点击链接, 输入网站地址, 喝杯茶, 结果就出来了 - &lt;strong&gt;A+&lt;/strong&gt; 哈哈哈哈哈!!!!&lt;/p&gt;
&lt;p&gt;&lt;img alt="我的网站SSL评分" src="./images/ewhisper-ssl-report.png"&gt;&lt;/p&gt;
&lt;p&gt;最后附上我的&lt;a href="https://www.EWhisper.cn/assets/SSL_Server_Test_ www.ewhisper.cn.pdf"&gt;完整报告&lt;/a&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Wed, 19 Jun 2019 19:26:20 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-06-19:/nginx-conf-add-ssl-support.html</guid><category>nginx</category><category>ssl</category><category>拨测</category><category>可用性</category></item><item><title>我的个人博客迁移到Docker啦</title><link>https://www.EWhisper.cn/ewhisper-blog-moved-to-docker.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;网站架构&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#_2"&gt;数据流向&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;网站架构&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;容器化简单步骤&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#nginx"&gt;直接启动NGINX容器&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_5"&gt;其他容器化方式&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#dockerfile"&gt;Dockerfile 封装镜像&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#-docker-compose"&gt;简单容器编排工具 - docker compose&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_6"&gt;查看状态和日志&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;p&gt;2019年5月10日起, 我的个人博客 - https://www.EWhisper.cn 正式运行在docker里边了! &lt;img align="absmiddle" alt="🎉" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f389.png" title=":tada:" width="20px"&gt;&lt;img align="absmiddle" alt="🎉" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f389.png" title=":tada:" width="20px"&gt;&lt;img align="absmiddle" alt="🎉" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f389.png" title=":tada:" width="20px"&gt; &lt;/p&gt;
&lt;p&gt;我把相关的源码, Docker镜像分别上传到了GitHub和Docker Hub. 地址如下:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GitHub: https://github.com/east4ming/my-tencentyun-nginx&lt;/li&gt;
&lt;li&gt;Docker Hub: https://cloud.docker.com/u/caseycui/repository/docker/caseycui/my-tencentyun-nginx&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="欢迎上&amp;quot;船&amp;quot;" src="./images/illustration-com-container-party.png"&gt;&lt;/p&gt;
&lt;h2 id="_1"&gt;网站架构&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="_2"&gt;数据流向&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;我的博客网站的架构其实&lt;strong&gt;非常非常&lt;/strong&gt;简单. 说白了, 就是&lt;strong&gt;NGINX + 静态页面&lt;/strong&gt;. (对的, 你没有看错, 我的网站是个全静态网站, 没有动态页面). &lt;/p&gt;
&lt;p&gt;之前的数据流向大概是:&lt;/p&gt;
&lt;p&gt;用户 -&amp;gt; 域名 -&amp;gt; DNS -&amp;gt; 腾讯云主机外网IP -&amp;gt; 腾讯云主机内网IP -&amp;gt; NGINX 80和443端口  (NGINX作为Web Server, 后端没有App Server和DB)&lt;/p&gt;
&lt;p&gt;现在加了一层Docker, 多了一层 主机 -&amp;gt; docker sdn的转发. 如下:&lt;/p&gt;
&lt;p&gt;用户 -&amp;gt; 域名 -&amp;gt; DNS -&amp;gt; 腾讯云主机外网IP -&amp;gt; 腾讯云主机内网IP -&amp;gt; &lt;strong&gt;Docker SDN端口映射&lt;/strong&gt;(443指向docker的443, 80之下那个docker的80) -&amp;gt; Docker的NGINX容器的 80和443端口 &lt;/p&gt;
&lt;h3 id="_3"&gt;网站架构&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;从头开始说起吧, 我的博客是一个&lt;strong&gt;静态站点&lt;/strong&gt;. &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;我写博文是先通过MarkDown 写.md格式的文本.&lt;/li&gt;
&lt;li&gt;然后通过&lt;strong&gt;静态站点生成器&lt;/strong&gt;(static site generator) -- &lt;a href="http://www.getpelican.com/"&gt;Pelican&lt;/a&gt; (我用的这个不算最主流的, 主流的如: Hexo等)将我的MarkDown 文本, 根据Pelican中定义的主题, 渲染为一个相应风格HTML文件. &lt;/li&gt;
&lt;li&gt;整个站点, 包括以下内容都是一个个的HTML页面.&lt;ol&gt;
&lt;li&gt;Index页面&lt;/li&gt;
&lt;li&gt;about  和 contact 页面&lt;/li&gt;
&lt;li&gt;标签 类别页面&lt;/li&gt;
&lt;li&gt;RSS 订阅页面&lt;/li&gt;
&lt;li&gt;每一篇博文&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;整个网站呢, 实际上就是:&lt;ol&gt;
&lt;li&gt;HTML(和CSS JS)&lt;/li&gt;
&lt;li&gt;静态内容(如: 图片, 图片目前部分在本地, 部分调用图床外链如&lt;a href="https://www.yupoo.com"&gt;又拍&lt;/a&gt; 七牛 CND等)&lt;/li&gt;
&lt;li&gt;其他功能通过插件(也是JS, 外部的JS)实现, 如:&lt;ol&gt;
&lt;li&gt;评论框 (国内可能看不见, 被屏蔽了....)&lt;/li&gt;
&lt;li&gt;转发条&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Pelican 生成的所有的静态站点内容, 都全部通过rsync等工具同步到我的腾讯云主机的&lt;code&gt;/usr/share/nginx/html&lt;/code&gt; 目录下, 并启动NGINX, 配置80, 443端口监听并处理静态内容就可以了.  &lt;ol&gt;
&lt;li&gt;以前, 我是直接通过&lt;code&gt;systemctl&lt;/code&gt; 在云主机上启动的NGINX&lt;/li&gt;
&lt;li&gt;现在, 是通过docker启动的NGINX镜像.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_4"&gt;容器化简单步骤&lt;a class="headerlink" href="#_4" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;因为我这个只涉及NGINX的容器化, 而且NGINX有官方提供的标准镜像. 所以容器化非常简单, 最简单的方式, 就是&lt;strong&gt;直接启动NGINX容器&lt;/strong&gt;, 如下:&lt;/p&gt;
&lt;h3 id="nginx"&gt;直接启动NGINX容器&lt;a class="headerlink" href="#nginx" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;其实, 直接启动&lt;strong&gt;NGINX&lt;/strong&gt;容器就好了, 你只需要把以下内容挂载卷或者暴露出来:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;挂载卷&lt;ol&gt;
&lt;li&gt;NGINX相关配置(包括: &lt;code&gt;/etc/nginx&lt;/code&gt;下面的nginx.conf文件, conf.d和default.d文件夹)&lt;/li&gt;
&lt;li&gt;静态站点文件(pelican生成的, 放到&lt;code&gt;/usr/share/nginx/html&lt;/code&gt;的文件)&lt;/li&gt;
&lt;li&gt;证书文件(向云供应商或证书供应商申请到的证书, 放到&lt;code&gt;/etc/pki/nginx&lt;/code&gt; 文件夹)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;暴露端口&lt;ol&gt;
&lt;li&gt;80&lt;/li&gt;
&lt;li&gt;443&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;命令如下: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo docker run --name my-tencentyun-nginx -d &lt;span class="se"&gt;\&lt;/span&gt;
  -p &lt;span class="m"&gt;80&lt;/span&gt;:80 -p &lt;span class="m"&gt;443&lt;/span&gt;:443 &lt;span class="se"&gt;\&lt;/span&gt;
  -v /etc/nginx/nginx.conf:/etc/nginx/nginx.conf &lt;span class="se"&gt;\&lt;/span&gt;
  -v /etc/nginx/conf.d:/etc/nginx/conf.d &lt;span class="se"&gt;\&lt;/span&gt;
  -v /etc/nginx/default.d:/etc/nginx/default.d &lt;span class="se"&gt;\&lt;/span&gt;
  -v /usr/share/nginx/html:/usr/share/nginx/html &lt;span class="se"&gt;\&lt;/span&gt;
  -v /etc/pki/nginx:/etc/pki/nginx:ro &lt;span class="se"&gt;\&lt;/span&gt;
  nginx
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的命令就不细说了, 很容易理解的. &lt;code&gt;-p&lt;/code&gt;是暴露端口, &lt;code&gt;-v&lt;/code&gt;是把主机的磁盘挂载到容器里, &lt;code&gt;-d&lt;/code&gt;是后台运行.&lt;/p&gt;
&lt;p&gt;启动后, 你的NGINX docker容器就会自动下载并启动运行, 你的网站也可以正式对外服务啦. &lt;img align="absmiddle" alt="🎉" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f389.png" title=":tada:" width="20px"&gt;&lt;img align="absmiddle" alt="🎉" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f389.png" title=":tada:" width="20px"&gt;&lt;img align="absmiddle" alt="🎉" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f389.png" title=":tada:" width="20px"&gt;&lt;/p&gt;
&lt;h2 id="_5"&gt;其他容器化方式&lt;a class="headerlink" href="#_5" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;自己本地或单机玩玩, 上边的容器化方式完全够用了. 但是如果我们有以下需求:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;多人合作. 需要封装成新的镜像, 将镜像提供给别人使用.&lt;/li&gt;
&lt;li&gt;更好地编排与管理. 管理一个项目, 需要启动多少个web server, 多少个app server, 多少个db. 相互之间如何交互.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么久需要其他的容器化方式.&lt;/p&gt;
&lt;h3 id="dockerfile"&gt;Dockerfile 封装镜像&lt;a class="headerlink" href="#dockerfile" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这种其实是团队, 公司, 或生产上推荐的一种方式. 开发负责写代码, 编译代码, 写Dockerfile, 构建镜像. 并把镜像上传到共有或私有的镜像仓库. 然后另外的团队角色, 如: 测试, 运维, 再从仓库中拉取镜像并启动, 测试, 上线. &lt;/p&gt;
&lt;p&gt;这也实现了docker的最大优势, 他们的slogan: &lt;strong&gt;"build, share and run any application, anywhere"&lt;/strong&gt;. &lt;/p&gt;
&lt;p&gt;能做到这一点, 也是因为OS+语言+组件+应用包, 整个打包成了一个镜像, 实现了环境的一致性.&lt;/p&gt;
&lt;p&gt;还有一个有点, 因为有Dockerfile, 也方便进行追溯和理解镜像. (如果只是一个镜像的话, 很难知道镜像是怎么做出来的).&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;创建个项目, 本地文件夹是&lt;strong&gt;my-tencentyun-nginx&lt;/strong&gt;, GitHub是: https://github.com/east4ming/my-tencentyun-nginx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将相关源码和站点文件放到该目录中(配置文件, 站点文件, 证书)&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt; 注意: &lt;/p&gt;
&lt;p&gt;证书key包含重要的私密信息, 千万不要上传到公网上!&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建&lt;code&gt;Dockerfile&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构建镜像: &lt;code&gt;sudo docker build -t caseycui/my-tencentyun-nginx .&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(可选) 推送镜像到Docker Hub: &lt;code&gt;sudo docker push caseycui/my-tencentyun-nginx&lt;/code&gt; (我这边是Docker Hub直接oauth连接到Github, 我的对应的Github仓库代码有更新, 就会自动构建)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;运行镜像: &lt;code&gt;sudo docker run --name my-tencentyun-nginx -v /etc/pki/nginx:/etc/pki/nginx:ro -d -p 80:80 -p 443:443 caseycui/my-tencentyun-nginx&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Dockerfile 如下:&lt;/p&gt;
&lt;p&gt;最简单的Dockerfile, 就是在nginx镜像的基础上, 把我们自己的nginx配置文件和静态站点文件复制进去, 生成一个新镜像.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;FROM&lt;/span&gt;&lt;span class="s"&gt; nginx:latest&lt;/span&gt;

&lt;span class="k"&gt;COPY&lt;/span&gt; pelican-output /usr/share/nginx/html
&lt;span class="k"&gt;COPY&lt;/span&gt; nginx.conf /etc/nginx/nginx.conf
&lt;span class="k"&gt;COPY&lt;/span&gt; default.d /etc/nginx/default.d
&lt;span class="c"&gt;#COPY conf.d /etc/nginx/conf.d  # 这边注释掉, 是因为这个目录里还没有内容&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="-docker-compose"&gt;简单容器编排工具 - docker compose&lt;a class="headerlink" href="#-docker-compose" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;适用场景&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;docker compose是docker官方出品的容器编排工具, 简单易用. 小规模用用还是挺舒服的. 大规模, 企业级的现在都是使用Kubernetes.&lt;/p&gt;
&lt;p&gt;我这里用docker compose其实是杀鸡用牛刀了, 没啥必要. 它适用于哪种场景呢? &lt;/p&gt;
&lt;p&gt;比如, 我一个项目要上线, 包括: web server, app server, db. 那么这时候docker compose就很合适了. 通过它来编排这3类容器, 使它们相互协作和交互. &lt;/p&gt;
&lt;p&gt;docker-compose是通过&lt;code&gt;docker-compose.yaml&lt;/code&gt;来定义这些编排内容的. 示例如下:&lt;/p&gt;
&lt;p&gt;一个web容器, 一个redis容器. 挂载哪些卷, 怎么编译...&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;version&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;3&amp;#39;&lt;/span&gt;
&lt;span class="nt"&gt;services&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;web&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nt"&gt;build&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;.&lt;/span&gt;
    &lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;5000:5000&amp;quot;&lt;/span&gt;
    &lt;span class="nt"&gt;volumes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;.:/code&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;logvolume01:/var/log&lt;/span&gt;
    &lt;span class="nt"&gt;links&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;redis&lt;/span&gt;
  &lt;span class="nt"&gt;redis&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;redis&lt;/span&gt;
&lt;span class="nt"&gt;volumes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;logvolume01&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p p-Indicator"&gt;{}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;strong&gt;步骤&lt;/strong&gt;:&lt;/p&gt;
&lt;p&gt;创建&lt;code&gt;docker-compose.yaml&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;web&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
  &lt;span class="nt"&gt;image&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;nginx&lt;/span&gt;
  &lt;span class="nt"&gt;volumes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./nginx.conf:/etc/nginx/nginx.conf&lt;/span&gt;
   &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./default.d:/etc/nginx/default.d&lt;/span&gt;
   &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./conf.d:/etc/nginx/conf.d&lt;/span&gt;
   &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;./pelican-output:/usr/share/nginx/html&lt;/span&gt;
   &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="l l-Scalar l-Scalar-Plain"&gt;/etc/pki/nginx:/etc/pki/nginx:ro&lt;/span&gt;
  &lt;span class="nt"&gt;ports&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;80:80&amp;quot;&lt;/span&gt;
   &lt;span class="p p-Indicator"&gt;-&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;443:443&amp;quot;&lt;/span&gt;
  &lt;span class="nt"&gt;command&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p p-Indicator"&gt;[&lt;/span&gt;&lt;span class="nv"&gt;nginx&lt;/span&gt;&lt;span class="p p-Indicator"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;-g&amp;#39;&lt;/span&gt;&lt;span class="p p-Indicator"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;daemon&lt;/span&gt;&lt;span class="nv"&gt; &lt;/span&gt;&lt;span class="s"&gt;off;&amp;#39;&lt;/span&gt;&lt;span class="p p-Indicator"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;运行: &lt;code&gt;sudo nohup docker-compose up &amp;amp;&lt;/code&gt;&lt;/p&gt;
&lt;h2 id="_6"&gt;查看状态和日志&lt;a class="headerlink" href="#_6" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;查看状态: &lt;code&gt;sudo docker ps &amp;lt;container name&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看日志: &lt;code&gt;sudo docker logs &amp;lt;container name&amp;gt;&lt;/code&gt;&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Fri, 10 May 2019 10:32:00 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-05-10:/ewhisper-blog-moved-to-docker.html</guid><category>nginx</category><category>github</category><category>docker</category><category>containers</category></item><item><title>苹果ATS合规对Web服务器的影响</title><link>https://www.EWhisper.cn/apple-ats-effect-on-web-server.html</link><description>&lt;div class="toc"&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="#_1"&gt;一 前言&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#11-ats"&gt;1.1 ATS要求&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_2"&gt;二 检查项&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#21-apache"&gt;2.1 Apache 检查项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#22-nginx"&gt;2.2 NGINX检查项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#23-weblogic"&gt;2.3 WebLogic 检查项&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_3"&gt;三 修改配置项&lt;/a&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href="#31-apache"&gt;3.1 Apache 配置项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#32-nginx"&gt;3.2 NGINX 配置项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="#33-weblogic"&gt;3.3 WebLogic 配置项&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="#_4"&gt;四 注意项&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;h2 id="_1"&gt;一 前言&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img align="absmiddle" alt="📓" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f4d3.png" title=":notebook:" width="20px"&gt; 说明:&lt;/p&gt;
&lt;p&gt;这篇文章是在太平保险期间, 我和同时Huang Wentao一起收集资料并实验后协作完成的.&lt;/p&gt;
&lt;p&gt;本文写于2年前, 时至今日可能规范, 软件版本或配置项都发生变化. 如果要应用, 请应用前进行完善测试.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="11-ats"&gt;1.1 ATS要求&lt;a class="headerlink" href="#11-ats" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;协商的传输层安全（TLS）版本必须为TLS 1.2;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接必须使用AES-128或AES-256对称密码，协商的秘钥交换协议必须是以下之一：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384&lt;/li&gt;
&lt;li&gt;TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256&lt;/li&gt;
&lt;li&gt;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA384&lt;/li&gt;
&lt;li&gt;TLS_ECDHE_ECDSA_WITH_AES_256_CBC_SHA&lt;/li&gt;
&lt;li&gt;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA256&lt;/li&gt;
&lt;li&gt;TLS_ECDHE_ECDSA_WITH_AES_128_CBC_SHA&lt;/li&gt;
&lt;li&gt;TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384&lt;/li&gt;
&lt;li&gt;TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256&lt;/li&gt;
&lt;li&gt;TLS_ECDHE_RSA_WITH_AES_256_CBC_SHA384&lt;/li&gt;
&lt;li&gt;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA256&lt;/li&gt;
&lt;li&gt;TLS_ECDHE_RSA_WITH_AES_128_CBC_SHA&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Leaf server（设备服务器）证书必须使用以下类型的密钥之一签名&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Rivest-Shamir-Adleman (RSA)秘钥，长度至少为2048位&lt;/li&gt;
&lt;li&gt;Elliptic-Curve Cryptography (ECC) 秘钥，长度至少为256位&lt;/li&gt;
&lt;li&gt;此外，leaf server证书散列算法必须是具有至少256（即SHA-256或更大）的摘要长度（有时称为“指纹”）的安全散列算法2（SHA-2）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_2"&gt;二 检查项&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;h3 id="21-apache"&gt;2.1 Apache 检查项&lt;a class="headerlink" href="#21-apache" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;OpenSSL版本: 需要大于 &lt;a href="https://www.openssl.org/news/changelog.txt"&gt;1.0.1&lt;/a&gt; (OpenSSL从1.0.1以后开始支持TLS 1.2)&lt;/li&gt;
&lt;li&gt;当前加密套件使用的密钥交换协议.&lt;ol&gt;
&lt;li&gt;查看当前加密套件支持的协议. 要保证支持的协议中有以上ATS 中所要求的.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;当前密钥长度/指纹算法是否满足:&lt;ol&gt;
&lt;li&gt;如果是RSA密钥, 则至少要为2048位;&lt;/li&gt;
&lt;li&gt;如果是ECC密钥, 则至少为256位.&lt;/li&gt;
&lt;li&gt;指纹安全散列算法要为 SHA-2&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Apache版本:&lt;ol&gt;
&lt;li&gt;&lt;a href="http://svn.apache.org/repos/asf/httpd/httpd/branches/2.2.x/CHANGES"&gt;Apache 2.2.23&lt;/a&gt; 或&lt;a href="http://svn.apache.org/repos/asf/httpd/httpd/branches/2.4.x/CHANGES"&gt;2.4.0&lt;/a&gt; 以上版本都是支持的.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="22-nginx"&gt;2.2 NGINX检查项&lt;a class="headerlink" href="#22-nginx" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;OpenSSL 版本: 需要大于1.0.1&lt;/li&gt;
&lt;li&gt;当前加密套件使用的密钥交换协议.&lt;ol&gt;
&lt;li&gt;查看当前加密套件支持的协议. 要保证支持的协议中有以上ATS 中所要求的.&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;当前密钥长度/指纹算法是否满足:&lt;ol&gt;
&lt;li&gt;如果是RSA密钥, 则至少要为2048位;&lt;/li&gt;
&lt;li&gt;如果是ECC密钥, 则至少为256位.&lt;/li&gt;
&lt;li&gt;指纹安全散列算法要为 SHA-2&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;NGINX版本: 建议使用&lt;a href="http://nginx.org/en/CHANGES-1.12"&gt;1.1.13&lt;/a&gt;以上版本.&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="23-weblogic"&gt;2.3 WebLogic 检查项&lt;a class="headerlink" href="#23-weblogic" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;JDK版本: 需要版本为JDK 7 以上.&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="_3"&gt;三 修改配置项&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img align="absmiddle" alt="📓" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f4d3.png" title=":notebook:" width="20px"&gt; 说明:&lt;/p&gt;
&lt;p&gt;除了以上检查项中版本不符合的需要升级、证书的算法、秘钥长度需要达到要求外，还有其他配置项要进行配置.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="31-apache"&gt;3.1 Apache 配置项&lt;a class="headerlink" href="#31-apache" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;示例: Apache版本2.2.23(~~待确定~~)，OpenSSL版本1.0.1e. (最大兼容性配置)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nt"&gt;&amp;lt;VirtualHost&lt;/span&gt; &lt;span class="err"&gt;*:443&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    ...
    SSLEngine on
    SSLCertificateFile      /path/to/signed_certificate
    SSLCertificateChainFile /path/to/intermediate_certificate
    SSLCertificateKeyFile   /path/to/private/key

    # Uncomment the following directive when using client certificate authentication
    #SSLCACertificateFile    /path/to/ca_certs_for_client_authentication


    # HSTS (mod_headers is required) (15768000 seconds = 6 months)
    Header always set Strict-Transport-Security &amp;quot;max-age=15768000&amp;quot;
    ...
&lt;span class="nt"&gt;&amp;lt;/VirtualHost&amp;gt;&lt;/span&gt;

# old configuration, tweak to your needs
SSLProtocol             all -SSLv2
SSLCipherSuite          ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:ECDHE-RSA-DES-CBC3-SHA:ECDHE-ECDSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:DES-CBC3-SHA:HIGH:SEED:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!RSAPSK:!aDH:!aECDH:!EDH-DSS-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA:!SRP
SSLHonorCipherOrder     on
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="32-nginx"&gt;3.2 NGINX 配置项&lt;a class="headerlink" href="#32-nginx" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;举例：Nginx版本1.11.0，OpenSSL版本1.0.1e (最大兼容性配置)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="mi"&gt;80&lt;/span&gt; &lt;span class="s"&gt;default_server&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="s"&gt;[::]:80&lt;/span&gt; &lt;span class="s"&gt;default_server&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;# Redirect all HTTP requests to HTTPS with a 301 Moved Permanently response.&lt;/span&gt;
    &lt;span class="kn"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;301&lt;/span&gt; &lt;span class="s"&gt;https://&lt;/span&gt;&lt;span class="nv"&gt;$host$request_uri&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;server&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="mi"&gt;443&lt;/span&gt; &lt;span class="s"&gt;ssl&lt;/span&gt; &lt;span class="s"&gt;http2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;listen&lt;/span&gt; &lt;span class="s"&gt;[::]:443&lt;/span&gt; &lt;span class="s"&gt;ssl&lt;/span&gt; &lt;span class="s"&gt;http2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;# certs sent to the client in SERVER HELLO are concatenated in ssl_certificate&lt;/span&gt;
    &lt;span class="kn"&gt;ssl_certificate&lt;/span&gt; &lt;span class="s"&gt;/path/to/signed_cert_plus_intermediates&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;ssl_certificate_key&lt;/span&gt; &lt;span class="s"&gt;/path/to/private_key&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;ssl_session_timeout&lt;/span&gt; &lt;span class="s"&gt;1d&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;ssl_session_cache&lt;/span&gt; &lt;span class="s"&gt;shared:SSL:50m&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;ssl_session_tickets&lt;/span&gt; &lt;span class="no"&gt;off&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;# Diffie-Hellman parameter for DHE ciphersuites, recommended 2048 bits&lt;/span&gt;
    &lt;span class="kn"&gt;ssl_dhparam&lt;/span&gt; &lt;span class="s"&gt;/path/to/dhparam.pem&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;# old configuration. tweak to your needs.&lt;/span&gt;
    &lt;span class="kn"&gt;ssl_protocols&lt;/span&gt; &lt;span class="s"&gt;SSLv3&lt;/span&gt; &lt;span class="s"&gt;TLSv1&lt;/span&gt; &lt;span class="s"&gt;TLSv1.1&lt;/span&gt; &lt;span class="s"&gt;TLSv1.2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;ssl_ciphers&lt;/span&gt; &lt;span class="s"&gt;&amp;#39;ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-DSS-AES128-GCM-SHA256:kEDH+AESGCM:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA384:ECDHE-RSA-AES256-SHA:ECDHE-ECDSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-DSS-AES128-SHA256:DHE-RSA-AES256-SHA256:DHE-DSS-AES256-SHA:DHE-RSA-AES256-SHA:ECDHE-RSA-DES-CBC3-SHA:ECDHE-ECDSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:AES:DES-CBC3-SHA:HIGH:SEED:!aNULL:!eNULL:!EXPORT:!DES:!RC4:!MD5:!PSK:!RSAPSK:!aDH:!aECDH:!EDH-DSS-DES-CBC3-SHA:!KRB5-DES-CBC3-SHA:!SRP&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;ssl_prefer_server_ciphers&lt;/span&gt; &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;# HSTS (ngx_http_headers_module is required) (15768000 seconds = 6 months)&lt;/span&gt;
    &lt;span class="kn"&gt;add_header&lt;/span&gt; &lt;span class="s"&gt;Strict-Transport-Security&lt;/span&gt; &lt;span class="s"&gt;max-age=15768000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;# OCSP Stapling ---&lt;/span&gt;
    &lt;span class="c1"&gt;# fetch OCSP records from URL in ssl_certificate and cache them&lt;/span&gt;
    &lt;span class="kn"&gt;ssl_stapling&lt;/span&gt; &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kn"&gt;ssl_stapling_verify&lt;/span&gt; &lt;span class="no"&gt;on&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;## verify chain of trust of OCSP response using Root CA and Intermediate certs&lt;/span&gt;
    &lt;span class="kn"&gt;ssl_trusted_certificate&lt;/span&gt; &lt;span class="s"&gt;/path/to/root_CA_cert_plus_intermediates&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kn"&gt;resolver&lt;/span&gt; &lt;span class="s"&gt;&amp;lt;IP&lt;/span&gt; &lt;span class="s"&gt;DNS&lt;/span&gt; &lt;span class="s"&gt;resolver&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kn"&gt;....&lt;/span&gt;
&lt;span class="err"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="33-weblogic"&gt;3.3 WebLogic 配置项&lt;a class="headerlink" href="#33-weblogic" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;需要在Oracle官网下载java 7相关的policyfile&lt;br&gt;
解压后，替换&lt;code&gt;JAVA_HOME/jre/lib/security&lt;/code&gt;下的&lt;code&gt;local_policy.jar&lt;/code&gt;、&lt;code&gt;US_export_policy.jar&lt;/code&gt;文件。&lt;/p&gt;
&lt;h2 id="_4"&gt;四 注意项&lt;a class="headerlink" href="#_4" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;升级OpenSSL，可能会影响sftp、ssh等和ssl有关的协议，需谨慎操作。&lt;/li&gt;
&lt;li&gt;考虑到旧的ssl版本漏洞，以及兼容性，建议都要禁用掉ssl V2及以下版本协议。(最新的建议是SSL v3也禁用)&lt;/li&gt;
&lt;/ol&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Sat, 30 Mar 2019 19:37:41 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-03-30:/apple-ats-effect-on-web-server.html</guid><category>ATS</category><category>apple</category><category>ssl</category><category>nginx</category><category>apache</category><category>tls</category><category>openssl</category></item><item><title>HTTPS基础原理和配置 - 加密协议SSL和TLS</title><link>https://www.EWhisper.cn/https-101-chapter-1.html</link><description>&lt;blockquote&gt;
&lt;p&gt;近期又碰到了SSL相关的事情, 就心血来潮开个新专题 - 《HTTPS基础原理和配置》&lt;/p&gt;
&lt;p&gt;本文是第一篇文章， 主要介绍SSL TLS加密协议的相关内容。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id="_1"&gt;加密协议历史概要&lt;a class="headerlink" href="#_1" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;SSL TLS加密协议其实并没有很长的历史，1995年&lt;strong&gt;网景&lt;/strong&gt;发布了SSL v2.0，这也是web加密的开始。这使得电子商务领域，人们可以在线提交密码和信用卡，并且至少是相当安全的。&lt;/p&gt;
&lt;p&gt;SSLv3.0很快发布，这版被保罗·柯克（Paul Coker）及其他人完全重写。这是一个非常坚实的协议。事实上，IETF采用SSL v3.0，并使它成为并不是网景独有的协议，叫做TLS（Transport Layer Security）。SSL意思是安全套接字层，但现在叫传输层安全。&lt;/p&gt;
&lt;p&gt;所以，TLS v1.0几乎和SSL v3.0 一模一样，只是进行了一两个小优化，并且IAF使之标准化。如果你深究这些协议，TLS v1.0实际上就是SSL v3.1；所以你可以认为他们是连续的。&lt;/p&gt;
&lt;p&gt;但是最终IETF提出了新版本v1.1（一些小优化），然后是v1.2，引入了一些新的加密算法。但是看到这你可能会想“好吧，有些客户端支持这些，有些客户端支持更新的，这取决于它们发布的时间. 安全性上可能差不太多". 但实际在安全意义上，这些中的大多数已经以被破解了。&lt;/p&gt;
&lt;h3 id="_2"&gt;关键历史节点&lt;a class="headerlink" href="#_2" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;SSL v2.0 1995年 网景 发布&lt;/li&gt;
&lt;li&gt;SSL v3.0 1996年发布 修复v2的主要问题&lt;/li&gt;
&lt;li&gt;TLS v1.0 1999年 IETF发布；对SSLv3小优化&lt;/li&gt;
&lt;li&gt;TLS v1.1 2006年 发布 小优化&lt;/li&gt;
&lt;li&gt;TLS v1.2 2008年发布 改进hash和AEAD模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_3"&gt;&lt;img align="absmiddle" alt="😂" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f602.png" title=":joy:" width="20px"&gt;被破解历史概要&lt;a class="headerlink" href="#_3" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;首先是SSL v2.0, 设计之初就被破解&lt;img align="absmiddle" alt="😂" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f602.png" title=":joy:" width="20px"&gt;&lt;img align="absmiddle" alt="😂" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f602.png" title=":joy:" width="20px"&gt;&lt;img align="absmiddle" alt="😂" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f602.png" title=":joy:" width="20px"&gt;, 所以，ssl v2.0确实不推荐使用；已经被破解很长很长时间了，不安全。 我们经常听到的支持的SSL版本一般也是从SSL v3.0开始的.&lt;/p&gt;
&lt;p&gt;SSL v3.0呢, 之前一直在用，直到2014年11月被破解。&lt;/p&gt;
&lt;p&gt;TLS呢, v1.0和v1.1基本安全。&lt;/p&gt;
&lt;p&gt;最新的v1.2(其实现在已经不算最新的了, TLS v1.3已经出来了, 但是目前主流的最新协议还是1.2), 是唯一一个还没有针对性攻击的版本(PS: 当然, 近期也有针对TLS v1.2的漏洞爆出, 但还算OK)。&lt;/p&gt;
&lt;p&gt;TLS有一个混乱的历史，并没有真正最好的安全记录，但TLS v1.2一直还是最好的，当涉及到与浏览器和服务的交互，它内置在几乎一切的浏览器和服务器中(最新的)。&lt;/p&gt;
&lt;p&gt;所以，TLS v1.2是大势所趋, 如果涉及到关键业务数据交互, 如&lt;strong&gt;用户关键信息&lt;/strong&gt; &lt;strong&gt;支付&lt;/strong&gt; &lt;strong&gt;金融&lt;/strong&gt;等场景, TLS v1.2才能真正有保障, 而其他老的加密协议, 都已经被破解了, 黑客想拿到你的数据(如果你用老的加密协议)只是时间问题, 并不存在技术上的难点。所以评估ATS(苹果的安全相关要求)合规也要求该版本。&lt;/p&gt;
&lt;h3 id="_4"&gt;&lt;img align="absmiddle" alt="😂" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f602.png" title=":joy:" width="20px"&gt;被破解关键历史节点&lt;a class="headerlink" href="#_4" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;SSL v2.0 1995发布 - 设计之初被破解&lt;/li&gt;
&lt;li&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;SSL v3.0 1996发布 – 被POODLE破解（2014 .11）&lt;/li&gt;
&lt;li&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;TSL v1.0 1999发布 – BEAST(2011)和Lucky 13(2013)发现漏洞&lt;/li&gt;
&lt;li&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;T​LS v1.1 2006发布 – 被Lucky 13(2013)和RC4(2013,2015)发现漏洞&lt;/li&gt;
&lt;li&gt;TLS v1.2 2008发布 – 只有在AEAD模式下是安全的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="_5"&gt;客户端兼容性&lt;a class="headerlink" href="#_5" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt; 注意:&lt;/p&gt;
&lt;p&gt;如果有条件, 强烈建议&lt;strong&gt;只选择 TLS v1.2&lt;/strong&gt;版本. (对于传统企业, 真的挺难做到的)​&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据以上的内容来看, 那我只选择TLS v1.2协议好了, 但实际情况是, TLS v1.2 是&lt;strong&gt;2008&lt;/strong&gt;年才发布的(标注发布), 而真正要落到实处所需要的时间更长. 所以很多客户端并不支持TLS v1.2. &lt;/p&gt;
&lt;p&gt;这些客户端, 是&lt;strong&gt;广义&lt;/strong&gt;的客户端, 包括: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;操作系统&lt;/li&gt;
&lt;li&gt;浏览器&lt;/li&gt;
&lt;li&gt;手机&lt;/li&gt;
&lt;li&gt;胖客户端(如Java客户端)&lt;/li&gt;
&lt;li&gt;...&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，如果你计划服务器只选择1.2版本，你就可能失去了很多潜在客户(还在用旧的客户端的客户, 当然, 说不定用着旧电脑的员工也被拒之门外了...)。这并不是最好的举动，除非对绝对安全非常敏感。否则的话, 还是建议支持更多的安全协议让更多的客户可以兼容. 是吧? 毕竟比起http这种裸奔, 其他旧的协议好歹还是穿着衣服的.&lt;img align="absmiddle" alt="😏" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/1f60f.png" title=":smirk:" width="20px"&gt;&lt;/p&gt;
&lt;p&gt;但是, 另一些大平台, 已经开始倾向于v1.2。比如ios之前的&lt;a href="https://developer.apple.com/news/?id=12212016b&amp;amp;1482372961"&gt;ATS合规要求&lt;/a&gt;, 比如&lt;a href="https://www.microsoft.com/security/blog/2017/06/20/tls-1-2-support-at-microsoft/"&gt;微软建议你放弃TLS v1.0和 TLS v1.1的支持&lt;/a&gt;。因此，行业正在朝着标准迈进。&lt;/p&gt;
&lt;h3 id="tls-v12"&gt;支持TLS v1.2客户端列表&lt;a class="headerlink" href="#tls-v12" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Windows 8 以上 (Windows Server 2008以上 - 2017年下半年才支持) (&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt; win7不支持! 更别提win xp了)&lt;/li&gt;
&lt;li&gt;&lt;a href="https://access.redhat.com/blogs/766093/posts/1976123"&gt;RHEL 或 CentOS ≥ 6.5&lt;/a&gt; (&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;用CentOS 5.X的注意了啊, 不支持TLS v1.2 ​)&lt;/li&gt;
&lt;li&gt;Chrome ≥ 30&lt;/li&gt;
&lt;li&gt;安卓 ≥ 5.0&lt;/li&gt;
&lt;li&gt;火狐浏览器 ≥ 27&lt;/li&gt;
&lt;li&gt;IE/Edge ≥ 11 (&lt;img align="absmiddle" alt="❗" class="emojione" height="20px" src="https://cdn.jsdelivr.net/emojione/assets/4.0/png/64/2757.png" title=":exclamation:" width="20px"&gt;主流的IE8 9 10都不支持!)&lt;/li&gt;
&lt;li&gt;iOS ≥ 5&lt;ul&gt;
&lt;li&gt;注意：iOS 9应用需要TLS 1.2支持。(ATS合规要求, 当时后来好像很难推下去)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="tls-10"&gt;支持TLS 1.0 客户端列表&lt;a class="headerlink" href="#tls-10" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;TLS 1.0 （真正安全的最老版本）几乎都支持（除了win xp sp2)。&lt;/p&gt;
&lt;p&gt;&lt;img alt="win xp sp2" src="./images/winxpsp2.png"&gt;&lt;/p&gt;
&lt;h2 id="_6"&gt;配置建议&lt;a class="headerlink" href="#_6" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;再次推荐&lt;a href="https://www.ssllabs.com/"&gt;SSL Labs&lt;/a&gt;, 打分如下:&lt;/p&gt;
&lt;p&gt;&lt;img alt="SSL Labs打分示例" src="./images/ssl-labs-example.png"&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id="_7"&gt;高安全性 低兼容性&lt;a class="headerlink" href="#_7" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;SSLProtocol             all -SSLv3 -TLSv1 -TLSv1.1&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;只支持TLS v1.2.&lt;/strong&gt; 当你配置加密协议时，如果只选择TLS&lt;br&gt;
1.2,得分会是&lt;strong&gt;A&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id="_8"&gt;中安全性 高兼容性&lt;a class="headerlink" href="#_8" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;SSLProtocol             all -SSLv3&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;只支持&lt;strong&gt;TLS&lt;/strong&gt;协议, 得分也会是&lt;strong&gt;A&lt;/strong&gt;. (之前的, 近期不确定, 感兴趣的可以测一下).&lt;/p&gt;
&lt;h3 id="_9"&gt;低安全性 最大兼容性&lt;a class="headerlink" href="#_9" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;SSLProtocol             all&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果使用SSLv3.0，有风险，得C。&lt;/p&gt;
&lt;h2 id="_10"&gt;总结&lt;a class="headerlink" href="#_10" title="Permanent link"&gt;&amp;para;&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;选择加密协议, 要根据具体的需求, 有侧重, 也要做到安全性和兼容性的兼顾.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我之前有个相关的PPT, 感兴趣的话后续发上来.&lt;/p&gt;
&lt;/blockquote&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">东风微鸣</dc:creator><pubDate>Sat, 30 Mar 2019 00:08:23 +0800</pubDate><guid isPermaLink="false">tag:www.ewhisper.cn,2019-03-30:/https-101-chapter-1.html</guid><category>linux</category><category>openssl</category><category>ssl</category><category>nginx</category><category>centos</category></item></channel></rss>